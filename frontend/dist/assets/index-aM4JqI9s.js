var tt=Object.defineProperty;var nt=(R,E,U)=>E in R?tt(R,E,{enumerable:!0,configurable:!0,writable:!0,value:U}):R[E]=U;var le=(R,E,U)=>nt(R,typeof E!="symbol"?E+"":E,U);(function(){const E=document.createElement("link").relList;if(E&&E.supports&&E.supports("modulepreload"))return;for(const K of document.querySelectorAll('link[rel="modulepreload"]'))H(K);new MutationObserver(K=>{for(const W of K)if(W.type==="childList")for(const G of W.addedNodes)G.tagName==="LINK"&&G.rel==="modulepreload"&&H(G)}).observe(document,{childList:!0,subtree:!0});function U(K){const W={};return K.integrity&&(W.integrity=K.integrity),K.referrerPolicy&&(W.referrerPolicy=K.referrerPolicy),K.crossOrigin==="use-credentials"?W.credentials="include":K.crossOrigin==="anonymous"?W.credentials="omit":W.credentials="same-origin",W}function H(K){if(K.ep)return;K.ep=!0;const W=U(K);fetch(K.href,W)}})();var n,l$1,u$2,i$3,r,o,e,f$2,c$1,s$1,a$1,p$1={},v$1=[],y$1=/acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i,d$2=Array.isArray;function w$1(R,E){for(var U in E)R[U]=E[U];return R}function _(R){R&&R.parentNode&&R.parentNode.removeChild(R)}function g(R,E,U){var H,K,W,G={};for(W in E)W=="key"?H=E[W]:W=="ref"?K=E[W]:G[W]=E[W];if(arguments.length>2&&(G.children=arguments.length>3?n.call(arguments,2):U),typeof R=="function"&&R.defaultProps!=null)for(W in R.defaultProps)G[W]===void 0&&(G[W]=R.defaultProps[W]);return m$1(R,G,H,K,null)}function m$1(R,E,U,H,K){var W={type:R,props:E,key:U,ref:H,__k:null,__:null,__b:0,__e:null,__c:null,constructor:void 0,__v:K??++u$2,__i:-1,__u:0};return K==null&&l$1.vnode!=null&&l$1.vnode(W),W}function k(R){return R.children}function x(R,E){this.props=R,this.context=E}function C(R,E){if(E==null)return R.__?C(R.__,R.__i+1):null;for(var U;E<R.__k.length;E++)if((U=R.__k[E])!=null&&U.__e!=null)return U.__e;return typeof R.type=="function"?C(R):null}function S(R){var E,U;if((R=R.__)!=null&&R.__c!=null){for(R.__e=R.__c.base=null,E=0;E<R.__k.length;E++)if((U=R.__k[E])!=null&&U.__e!=null){R.__e=R.__c.base=U.__e;break}return S(R)}}function M(R){(!R.__d&&(R.__d=!0)&&i$3.push(R)&&!P.__r++||r!==l$1.debounceRendering)&&((r=l$1.debounceRendering)||o)(P)}function P(){var R,E,U,H,K,W,G,Z;for(i$3.sort(e);R=i$3.shift();)R.__d&&(E=i$3.length,H=void 0,W=(K=(U=R).__v).__e,G=[],Z=[],U.__P&&((H=w$1({},K)).__v=K.__v+1,l$1.vnode&&l$1.vnode(H),j(U.__P,H,K,U.__n,U.__P.namespaceURI,32&K.__u?[W]:null,G,W??C(K),!!(32&K.__u),Z),H.__v=K.__v,H.__.__k[H.__i]=H,z(G,H,Z),H.__e!=W&&S(H)),i$3.length>E&&i$3.sort(e));P.__r=0}function $(R,E,U,H,K,W,G,Z,Y,X,Q){var J,ne,re,ae,te,se,ie=H&&H.__k||v$1,ye=E.length;for(Y=I(U,E,ie,Y,ye),J=0;J<ye;J++)(re=U.__k[J])!=null&&(ne=re.__i===-1?p$1:ie[re.__i]||p$1,re.__i=J,se=j(R,re,ne,K,W,G,Z,Y,X,Q),ae=re.__e,re.ref&&ne.ref!=re.ref&&(ne.ref&&V(ne.ref,null,re),Q.push(re.ref,re.__c||ae,re)),te==null&&ae!=null&&(te=ae),4&re.__u||ne.__k===re.__k?Y=A(re,Y,R):typeof re.type=="function"&&se!==void 0?Y=se:ae&&(Y=ae.nextSibling),re.__u&=-7);return U.__e=te,Y}function I(R,E,U,H,K){var W,G,Z,Y,X,Q=U.length,J=Q,ne=0;for(R.__k=new Array(K),W=0;W<K;W++)(G=E[W])!=null&&typeof G!="boolean"&&typeof G!="function"?(Y=W+ne,(G=R.__k[W]=typeof G=="string"||typeof G=="number"||typeof G=="bigint"||G.constructor==String?m$1(null,G,null,null,null):d$2(G)?m$1(k,{children:G},null,null,null):G.constructor===void 0&&G.__b>0?m$1(G.type,G.props,G.key,G.ref?G.ref:null,G.__v):G).__=R,G.__b=R.__b+1,Z=null,(X=G.__i=L(G,U,Y,J))!==-1&&(J--,(Z=U[X])&&(Z.__u|=2)),Z==null||Z.__v===null?(X==-1&&ne--,typeof G.type!="function"&&(G.__u|=4)):X!=Y&&(X==Y-1?ne--:X==Y+1?ne++:(X>Y?ne--:ne++,G.__u|=4))):R.__k[W]=null;if(J)for(W=0;W<Q;W++)(Z=U[W])!=null&&!(2&Z.__u)&&(Z.__e==H&&(H=C(Z)),q(Z,Z));return H}function A(R,E,U){var H,K;if(typeof R.type=="function"){for(H=R.__k,K=0;H&&K<H.length;K++)H[K]&&(H[K].__=R,E=A(H[K],E,U));return E}R.__e!=E&&(E&&R.type&&!U.contains(E)&&(E=C(R)),U.insertBefore(R.__e,E||null),E=R.__e);do E=E&&E.nextSibling;while(E!=null&&E.nodeType==8);return E}function L(R,E,U,H){var K,W,G=R.key,Z=R.type,Y=E[U];if(Y===null||Y&&G==Y.key&&Z===Y.type&&!(2&Y.__u))return U;if(H>(Y!=null&&!(2&Y.__u)?1:0))for(K=U-1,W=U+1;K>=0||W<E.length;){if(K>=0){if((Y=E[K])&&!(2&Y.__u)&&G==Y.key&&Z===Y.type)return K;K--}if(W<E.length){if((Y=E[W])&&!(2&Y.__u)&&G==Y.key&&Z===Y.type)return W;W++}}return-1}function T(R,E,U){E[0]=="-"?R.setProperty(E,U??""):R[E]=U==null?"":typeof U!="number"||y$1.test(E)?U:U+"px"}function F(R,E,U,H,K){var W;e:if(E=="style")if(typeof U=="string")R.style.cssText=U;else{if(typeof H=="string"&&(R.style.cssText=H=""),H)for(E in H)U&&E in U||T(R.style,E,"");if(U)for(E in U)H&&U[E]===H[E]||T(R.style,E,U[E])}else if(E[0]=="o"&&E[1]=="n")W=E!=(E=E.replace(f$2,"$1")),E=E.toLowerCase()in R||E=="onFocusOut"||E=="onFocusIn"?E.toLowerCase().slice(2):E.slice(2),R.l||(R.l={}),R.l[E+W]=U,U?H?U.u=H.u:(U.u=c$1,R.addEventListener(E,W?a$1:s$1,W)):R.removeEventListener(E,W?a$1:s$1,W);else{if(K=="http://www.w3.org/2000/svg")E=E.replace(/xlink(H|:h)/,"h").replace(/sName$/,"s");else if(E!="width"&&E!="height"&&E!="href"&&E!="list"&&E!="form"&&E!="tabIndex"&&E!="download"&&E!="rowSpan"&&E!="colSpan"&&E!="role"&&E!="popover"&&E in R)try{R[E]=U??"";break e}catch{}typeof U=="function"||(U==null||U===!1&&E[4]!="-"?R.removeAttribute(E):R.setAttribute(E,E=="popover"&&U==1?"":U))}}function O(R){return function(E){if(this.l){var U=this.l[E.type+R];if(E.t==null)E.t=c$1++;else if(E.t<U.u)return;return U(l$1.event?l$1.event(E):E)}}}function j(R,E,U,H,K,W,G,Z,Y,X){var Q,J,ne,re,ae,te,se,ie,ye,me,_e,oe,ue,he,we,xe,ke,ce=E.type;if(E.constructor!==void 0)return null;128&U.__u&&(Y=!!(32&U.__u),W=[Z=E.__e=U.__e]),(Q=l$1.__b)&&Q(E);e:if(typeof ce=="function")try{if(ie=E.props,ye="prototype"in ce&&ce.prototype.render,me=(Q=ce.contextType)&&H[Q.__c],_e=Q?me?me.props.value:Q.__:H,U.__c?se=(J=E.__c=U.__c).__=J.__E:(ye?E.__c=J=new ce(ie,_e):(E.__c=J=new x(ie,_e),J.constructor=ce,J.render=B),me&&me.sub(J),J.props=ie,J.state||(J.state={}),J.context=_e,J.__n=H,ne=J.__d=!0,J.__h=[],J._sb=[]),ye&&J.__s==null&&(J.__s=J.state),ye&&ce.getDerivedStateFromProps!=null&&(J.__s==J.state&&(J.__s=w$1({},J.__s)),w$1(J.__s,ce.getDerivedStateFromProps(ie,J.__s))),re=J.props,ae=J.state,J.__v=E,ne)ye&&ce.getDerivedStateFromProps==null&&J.componentWillMount!=null&&J.componentWillMount(),ye&&J.componentDidMount!=null&&J.__h.push(J.componentDidMount);else{if(ye&&ce.getDerivedStateFromProps==null&&ie!==re&&J.componentWillReceiveProps!=null&&J.componentWillReceiveProps(ie,_e),!J.__e&&(J.shouldComponentUpdate!=null&&J.shouldComponentUpdate(ie,J.__s,_e)===!1||E.__v==U.__v)){for(E.__v!=U.__v&&(J.props=ie,J.state=J.__s,J.__d=!1),E.__e=U.__e,E.__k=U.__k,E.__k.some(function(pe){pe&&(pe.__=E)}),oe=0;oe<J._sb.length;oe++)J.__h.push(J._sb[oe]);J._sb=[],J.__h.length&&G.push(J);break e}J.componentWillUpdate!=null&&J.componentWillUpdate(ie,J.__s,_e),ye&&J.componentDidUpdate!=null&&J.__h.push(function(){J.componentDidUpdate(re,ae,te)})}if(J.context=_e,J.props=ie,J.__P=R,J.__e=!1,ue=l$1.__r,he=0,ye){for(J.state=J.__s,J.__d=!1,ue&&ue(E),Q=J.render(J.props,J.state,J.context),we=0;we<J._sb.length;we++)J.__h.push(J._sb[we]);J._sb=[]}else do J.__d=!1,ue&&ue(E),Q=J.render(J.props,J.state,J.context),J.state=J.__s;while(J.__d&&++he<25);J.state=J.__s,J.getChildContext!=null&&(H=w$1(w$1({},H),J.getChildContext())),ye&&!ne&&J.getSnapshotBeforeUpdate!=null&&(te=J.getSnapshotBeforeUpdate(re,ae)),Z=$(R,d$2(xe=Q!=null&&Q.type===k&&Q.key==null?Q.props.children:Q)?xe:[xe],E,U,H,K,W,G,Z,Y,X),J.base=E.__e,E.__u&=-161,J.__h.length&&G.push(J),se&&(J.__E=J.__=null)}catch(pe){if(E.__v=null,Y||W!=null)if(pe.then){for(E.__u|=Y?160:128;Z&&Z.nodeType==8&&Z.nextSibling;)Z=Z.nextSibling;W[W.indexOf(Z)]=null,E.__e=Z}else for(ke=W.length;ke--;)_(W[ke]);else E.__e=U.__e,E.__k=U.__k;l$1.__e(pe,E,U)}else W==null&&E.__v==U.__v?(E.__k=U.__k,E.__e=U.__e):Z=E.__e=N(U.__e,E,U,H,K,W,G,Y,X);return(Q=l$1.diffed)&&Q(E),128&E.__u?void 0:Z}function z(R,E,U){for(var H=0;H<U.length;H++)V(U[H],U[++H],U[++H]);l$1.__c&&l$1.__c(E,R),R.some(function(K){try{R=K.__h,K.__h=[],R.some(function(W){W.call(K)})}catch(W){l$1.__e(W,K.__v)}})}function N(R,E,U,H,K,W,G,Z,Y){var X,Q,J,ne,re,ae,te,se=U.props,ie=E.props,ye=E.type;if(ye=="svg"?K="http://www.w3.org/2000/svg":ye=="math"?K="http://www.w3.org/1998/Math/MathML":K||(K="http://www.w3.org/1999/xhtml"),W!=null){for(X=0;X<W.length;X++)if((re=W[X])&&"setAttribute"in re==!!ye&&(ye?re.localName==ye:re.nodeType==3)){R=re,W[X]=null;break}}if(R==null){if(ye==null)return document.createTextNode(ie);R=document.createElementNS(K,ye,ie.is&&ie),Z&&(l$1.__m&&l$1.__m(E,W),Z=!1),W=null}if(ye===null)se===ie||Z&&R.data===ie||(R.data=ie);else{if(W=W&&n.call(R.childNodes),se=U.props||p$1,!Z&&W!=null)for(se={},X=0;X<R.attributes.length;X++)se[(re=R.attributes[X]).name]=re.value;for(X in se)if(re=se[X],X!="children"){if(X=="dangerouslySetInnerHTML")J=re;else if(!(X in ie)){if(X=="value"&&"defaultValue"in ie||X=="checked"&&"defaultChecked"in ie)continue;F(R,X,null,re,K)}}for(X in ie)re=ie[X],X=="children"?ne=re:X=="dangerouslySetInnerHTML"?Q=re:X=="value"?ae=re:X=="checked"?te=re:Z&&typeof re!="function"||se[X]===re||F(R,X,re,se[X],K);if(Q)Z||J&&(Q.__html===J.__html||Q.__html===R.innerHTML)||(R.innerHTML=Q.__html),E.__k=[];else if(J&&(R.innerHTML=""),$(R,d$2(ne)?ne:[ne],E,U,H,ye=="foreignObject"?"http://www.w3.org/1999/xhtml":K,W,G,W?W[0]:U.__k&&C(U,0),Z,Y),W!=null)for(X=W.length;X--;)_(W[X]);Z||(X="value",ye=="progress"&&ae==null?R.removeAttribute("value"):ae!==void 0&&(ae!==R[X]||ye=="progress"&&!ae||ye=="option"&&ae!==se[X])&&F(R,X,ae,se[X],K),X="checked",te!==void 0&&te!==R[X]&&F(R,X,te,se[X],K))}return R}function V(R,E,U){try{if(typeof R=="function"){var H=typeof R.__u=="function";H&&R.__u(),H&&E==null||(R.__u=R(E))}else R.current=E}catch(K){l$1.__e(K,U)}}function q(R,E,U){var H,K;if(l$1.unmount&&l$1.unmount(R),(H=R.ref)&&(H.current&&H.current!==R.__e||V(H,null,E)),(H=R.__c)!=null){if(H.componentWillUnmount)try{H.componentWillUnmount()}catch(W){l$1.__e(W,E)}H.base=H.__P=null}if(H=R.__k)for(K=0;K<H.length;K++)H[K]&&q(H[K],E,U||typeof R.type!="function");U||_(R.__e),R.__c=R.__=R.__e=void 0}function B(R,E,U){return this.constructor(R,U)}function D(R,E,U){var H,K,W,G;E==document&&(E=document.documentElement),l$1.__&&l$1.__(R,E),K=(H=typeof U=="function")?null:E.__k,W=[],G=[],j(E,R=(!H&&U||E).__k=g(k,null,[R]),K||p$1,p$1,E.namespaceURI,!H&&U?[U]:K?null:E.firstChild?n.call(E.childNodes):null,W,!H&&U?U:K?K.__e:E.firstChild,H,G),z(W,R,G)}n=v$1.slice,l$1={__e:function(R,E,U,H){for(var K,W,G;E=E.__;)if((K=E.__c)&&!K.__)try{if((W=K.constructor)&&W.getDerivedStateFromError!=null&&(K.setState(W.getDerivedStateFromError(R)),G=K.__d),K.componentDidCatch!=null&&(K.componentDidCatch(R,H||{}),G=K.__d),G)return K.__E=K}catch(Z){R=Z}throw R}},u$2=0,x.prototype.setState=function(R,E){var U;U=this.__s!=null&&this.__s!==this.state?this.__s:this.__s=w$1({},this.state),typeof R=="function"&&(R=R(w$1({},U),this.props)),R&&w$1(U,R),R!=null&&this.__v&&(E&&this._sb.push(E),M(this))},x.prototype.forceUpdate=function(R){this.__v&&(this.__e=!0,R&&this.__h.push(R),M(this))},x.prototype.render=k,i$3=[],o=typeof Promise=="function"?Promise.prototype.then.bind(Promise.resolve()):setTimeout,e=function(R,E){return R.__v.__b-E.__v.__b},P.__r=0,f$2=/(PointerCapture)$|Capture$/i,c$1=0,s$1=O(!1),a$1=O(!0);var f$1=0;function u$1(R,E,U,H,K,W){E||(E={});var G,Z,Y=E;"ref"in E&&(G=E.ref,delete E.ref);var X={type:R,props:Y,key:U,ref:G,__k:null,__:null,__b:0,__e:null,__c:null,constructor:void 0,__v:--f$1,__i:-1,__u:0,__source:K,__self:W};if(typeof R=="function"&&(G=R.defaultProps))for(Z in G)Y[Z]===void 0&&(Y[Z]=G[Z]);return l$1.vnode&&l$1.vnode(X),X}var i$2;(i$2=typeof globalThis<"u"?globalThis:typeof window<"u"?window:void 0)!=null&&i$2.__PREACT_DEVTOOLS__&&i$2.__PREACT_DEVTOOLS__.attachPreact("10.25.2",l$1,{Fragment:k,Component:x});var t={};function a(R){return R.type===k?"Fragment":typeof R.type=="function"?R.type.displayName||R.type.name:typeof R.type=="string"?R.type:"#text"}var i$1=[],s=[];function c(){return i$1.length>0?i$1[i$1.length-1]:null}var l=!0;function u(R){return typeof R.type=="function"&&R.type!=k}function f(R){for(var E=[R],U=R;U.__o!=null;)E.push(U.__o),U=U.__o;return E.reduce(function(H,K){H+="  in "+a(K);var W=K.__source;return W?H+=" (at "+W.fileName+":"+W.lineNumber+")":l&&console.warn("Add @babel/plugin-transform-react-jsx-source to get a more detailed component stack. Note that you should not add it to production builds of your App for bundle size reasons."),l=!1,H+`
`},"")}var d$1=typeof WeakMap=="function";function p(R){var E=[];return R.__k&&R.__k.forEach(function(U){U&&typeof U.type=="function"?E.push.apply(E,p(U)):U&&typeof U.type=="string"&&E.push(U.type)}),E}function h(R){return R?typeof R.type=="function"?R.__==null?R.__e!=null&&R.__e.parentNode!=null?R.__e.parentNode.localName:"":h(R.__):R.type:""}var v=x.prototype.setState;function y(R){return R==="table"||R==="tfoot"||R==="tbody"||R==="thead"||R==="td"||R==="tr"||R==="th"}x.prototype.setState=function(R,E){return this.__v==null&&this.state==null&&console.warn(`Calling "this.setState" inside the constructor of a component is a no-op and might be a bug in your application. Instead, set "this.state = {}" directly.

`+f(c())),v.call(this,R,E)};var m=/^(address|article|aside|blockquote|details|div|dl|fieldset|figcaption|figure|footer|form|h1|h2|h3|h4|h5|h6|header|hgroup|hr|main|menu|nav|ol|p|pre|search|section|table|ul)$/,b=x.prototype.forceUpdate;function w(R){var E=R.props,U=a(R),H="";for(var K in E)if(E.hasOwnProperty(K)&&K!=="children"){var W=E[K];typeof W=="function"&&(W="function "+(W.displayName||W.name)+"() {}"),W=Object(W)!==W||W.toString?W+"":Object.prototype.toString.call(W),H+=" "+K+"="+JSON.stringify(W)}var G=E.children;return"<"+U+H+(G&&G.length?">..</"+U+">":" />")}x.prototype.forceUpdate=function(R){return this.__v==null?console.warn(`Calling "this.forceUpdate" inside the constructor of a component is a no-op and might be a bug in your application.

`+f(c())):this.__P==null&&console.warn(`Can't call "this.forceUpdate" on an unmounted component. This is a no-op, but it indicates a memory leak in your application. To fix, cancel all subscriptions and asynchronous tasks in the componentWillUnmount method.

`+f(this.__v)),b.call(this,R)},l$1.__m=function(R,E){var U=R.type,H=E.map(function(K){return K&&K.localName}).filter(Boolean);console.error("Expected a DOM node of type "+U+" but found "+H.join(", ")+` as available DOM-node(s), this is caused by the SSR'd HTML containing different DOM-nodes compared to the hydrated one.

`+f(R))},function(){(function(){var te=l$1.__b,se=l$1.diffed,ie=l$1.__,ye=l$1.vnode,me=l$1.__r;l$1.diffed=function(_e){u(_e)&&s.pop(),i$1.pop(),se&&se(_e)},l$1.__b=function(_e){u(_e)&&i$1.push(_e),te&&te(_e)},l$1.__=function(_e,oe){s=[],ie&&ie(_e,oe)},l$1.vnode=function(_e){_e.__o=s.length>0?s[s.length-1]:null,ye&&ye(_e)},l$1.__r=function(_e){u(_e)&&s.push(_e),me&&me(_e)}})();var R=!1,E=l$1.__b,U=l$1.diffed,H=l$1.vnode,K=l$1.__r,W=l$1.__e,G=l$1.__,Z=l$1.__h,Y=d$1?{useEffect:new WeakMap,useLayoutEffect:new WeakMap,lazyPropTypes:new WeakMap}:null,X=[];l$1.__e=function(te,se,ie,ye){if(se&&se.__c&&typeof te.then=="function"){var me=te;te=new Error("Missing Suspense. The throwing component was: "+a(se));for(var _e=se;_e;_e=_e.__)if(_e.__c&&_e.__c.__c){te=me;break}if(te instanceof Error)throw te}try{(ye=ye||{}).componentStack=f(se),W(te,se,ie,ye),typeof te.then!="function"&&setTimeout(function(){throw te})}catch(oe){throw oe}},l$1.__=function(te,se){if(!se)throw new Error(`Undefined parent passed to render(), this is the second argument.
Check if the element is available in the DOM/has the correct id.`);var ie;switch(se.nodeType){case 1:case 11:case 9:ie=!0;break;default:ie=!1}if(!ie){var ye=a(te);throw new Error("Expected a valid HTML node as a second argument to render.	Received "+se+" instead: render(<"+ye+" />, "+se+");")}G&&G(te,se)},l$1.__b=function(te){var se=te.type;if(R=!0,se===void 0)throw new Error(`Undefined component passed to createElement()

You likely forgot to export your component or might have mixed up default and named imports`+w(te)+`

`+f(te));if(se!=null&&typeof se=="object")throw se.__k!==void 0&&se.__e!==void 0?new Error("Invalid type passed to createElement(): "+se+`

Did you accidentally pass a JSX literal as JSX twice?

  let My`+a(te)+" = "+w(se)+`;
  let vnode = <My`+a(te)+` />;

This usually happens when you export a JSX literal and not the component.

`+f(te)):new Error("Invalid type passed to createElement(): "+(Array.isArray(se)?"array":se));if(te.ref!==void 0&&typeof te.ref!="function"&&typeof te.ref!="object"&&!("$$typeof"in te))throw new Error(`Component's "ref" property should be a function, or an object created by createRef(), but got [`+typeof te.ref+`] instead
`+w(te)+`

`+f(te));if(typeof te.type=="string"){for(var ie in te.props)if(ie[0]==="o"&&ie[1]==="n"&&typeof te.props[ie]!="function"&&te.props[ie]!=null)throw new Error(`Component's "`+ie+'" property should be a function, but got ['+typeof te.props[ie]+`] instead
`+w(te)+`

`+f(te))}if(typeof te.type=="function"&&te.type.propTypes){if(te.type.displayName==="Lazy"&&Y&&!Y.lazyPropTypes.has(te.type)){var ye="PropTypes are not supported on lazy(). Use propTypes on the wrapped component itself. ";try{var me=te.type();Y.lazyPropTypes.set(te.type,!0),console.warn(ye+"Component wrapped in lazy() is "+a(me))}catch{console.warn(ye+"We will log the wrapped component's name once it is loaded.")}}var _e=te.props;te.type.__f&&delete(_e=function(oe,ue){for(var he in ue)oe[he]=ue[he];return oe}({},_e)).ref,function(oe,ue,he,we,xe){Object.keys(oe).forEach(function(ke){var ce;try{ce=oe[ke](ue,ke,we,"prop",null,"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED")}catch(pe){ce=pe}ce&&!(ce.message in t)&&(t[ce.message]=!0,console.error("Failed prop type: "+ce.message+(xe&&`
`+xe()||"")))})}(te.type.propTypes,_e,0,a(te),function(){return f(te)})}E&&E(te)};var Q,J=0;l$1.__r=function(te){K&&K(te),R=!0;var se=te.__c;if(se===Q?J++:J=1,J>=25)throw new Error("Too many re-renders. This is limited to prevent an infinite loop which may lock up your browser. The component causing this is: "+a(te));Q=se},l$1.__h=function(te,se,ie){if(!te||!R)throw new Error("Hook can only be invoked from render methods.");Z&&Z(te,se,ie)};var ne=function(te,se){return{get:function(){var ie="get"+te+se;X&&X.indexOf(ie)<0&&(X.push(ie),console.warn("getting vnode."+te+" is deprecated, "+se))},set:function(){var ie="set"+te+se;X&&X.indexOf(ie)<0&&(X.push(ie),console.warn("setting vnode."+te+" is not allowed, "+se))}}},re={nodeName:ne("nodeName","use vnode.type"),attributes:ne("attributes","use vnode.props"),children:ne("children","use vnode.props.children")},ae=Object.create({},re);l$1.vnode=function(te){var se=te.props;if(te.type!==null&&se!=null&&("__source"in se||"__self"in se)){var ie=te.props={};for(var ye in se){var me=se[ye];ye==="__source"?te.__source=me:ye==="__self"?te.__self=me:ie[ye]=me}}te.__proto__=ae,H&&H(te)},l$1.diffed=function(te){var se,ie=te.type,ye=te.__;if(te.__k&&te.__k.forEach(function(Ee){if(typeof Ee=="object"&&Ee&&Ee.type===void 0){var de=Object.keys(Ee).join(",");throw new Error("Objects are not valid as a child. Encountered an object with the keys {"+de+`}.

`+f(te))}}),te.__c===Q&&(J=0),typeof ie=="string"&&(y(ie)||ie==="p"||ie==="a"||ie==="button")){var me=h(ye);if(me!==""&&y(ie))ie==="table"&&me!=="td"&&y(me)?(console.log(me,ye.__e),console.error("Improper nesting of table. Your <table> should not have a table-node parent."+w(te)+`

`+f(te))):ie!=="thead"&&ie!=="tfoot"&&ie!=="tbody"||me==="table"?ie==="tr"&&me!=="thead"&&me!=="tfoot"&&me!=="tbody"?console.error("Improper nesting of table. Your <tr> should have a <thead/tbody/tfoot> parent."+w(te)+`

`+f(te)):ie==="td"&&me!=="tr"?console.error("Improper nesting of table. Your <td> should have a <tr> parent."+w(te)+`

`+f(te)):ie==="th"&&me!=="tr"&&console.error("Improper nesting of table. Your <th> should have a <tr>."+w(te)+`

`+f(te)):console.error("Improper nesting of table. Your <thead/tbody/tfoot> should have a <table> parent."+w(te)+`

`+f(te));else if(ie==="p"){var _e=p(te).filter(function(Ee){return m.test(Ee)});_e.length&&console.error("Improper nesting of paragraph. Your <p> should not have "+_e.join(", ")+" as child-elements."+w(te)+`

`+f(te))}else ie!=="a"&&ie!=="button"||p(te).indexOf(ie)!==-1&&console.error("Improper nesting of interactive content. Your <"+ie+"> should not have other "+(ie==="a"?"anchor":"button")+" tags as child-elements."+w(te)+`

`+f(te))}if(R=!1,U&&U(te),te.__k!=null)for(var oe=[],ue=0;ue<te.__k.length;ue++){var he=te.__k[ue];if(he&&he.key!=null){var we=he.key;if(oe.indexOf(we)!==-1){console.error('Following component has two or more children with the same key attribute: "'+we+`". This may cause glitches and misbehavior in rendering process. Component: 

`+w(te)+`

`+f(te));break}oe.push(we)}}if(te.__c!=null&&te.__c.__H!=null){var xe=te.__c.__H.__;if(xe)for(var ke=0;ke<xe.length;ke+=1){var ce=xe[ke];if(ce.__H){for(var pe=0;pe<ce.__H.length;pe++)if((se=ce.__H[pe])!=se){var ve=a(te);console.warn("Invalid argument passed to hook. Hooks should not be called with NaN in the dependency array. Hook index "+ke+" in component "+ve+" was called with NaN.")}}}}}}();function number$2(R){if(!Number.isSafeInteger(R)||R<0)throw new Error(`Wrong positive integer: ${R}`)}function bytes$2(R,...E){if(!(R instanceof Uint8Array))throw new Error("Expected Uint8Array");if(E.length>0&&!E.includes(R.length))throw new Error(`Expected Uint8Array of length ${E}, not of length=${R.length}`)}function hash$1(R){if(typeof R!="function"||typeof R.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");number$2(R.outputLen),number$2(R.blockLen)}function exists$1(R,E=!0){if(R.destroyed)throw new Error("Hash instance has been destroyed");if(E&&R.finished)throw new Error("Hash#digest() has already been called")}function output$1(R,E){bytes$2(R);const U=E.outputLen;if(R.length<U)throw new Error(`digestInto() expects output buffer of length at least ${U}`)}const crypto$3=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */const u8a$2=R=>R instanceof Uint8Array,createView$3=R=>new DataView(R.buffer,R.byteOffset,R.byteLength),rotr$3=(R,E)=>R<<32-E|R>>>E,isLE$2=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!isLE$2)throw new Error("Non little-endian hardware is not supported");function utf8ToBytes$5(R){if(typeof R!="string")throw new Error(`utf8ToBytes expected string, got ${typeof R}`);return new Uint8Array(new TextEncoder().encode(R))}function toBytes$3(R){if(typeof R=="string"&&(R=utf8ToBytes$5(R)),!u8a$2(R))throw new Error(`expected Uint8Array, got ${typeof R}`);return R}function concatBytes$4(...R){const E=new Uint8Array(R.reduce((H,K)=>H+K.length,0));let U=0;return R.forEach(H=>{if(!u8a$2(H))throw new Error("Uint8Array expected");E.set(H,U),U+=H.length}),E}let Hash$3=class{clone(){return this._cloneInto()}};function wrapConstructor$3(R){const E=H=>R().update(toBytes$3(H)).digest(),U=R();return E.outputLen=U.outputLen,E.blockLen=U.blockLen,E.create=()=>R(),E}function randomBytes$2(R=32){if(crypto$3&&typeof crypto$3.getRandomValues=="function")return crypto$3.getRandomValues(new Uint8Array(R));throw new Error("crypto.getRandomValues must be defined")}function setBigUint64$3(R,E,U,H){if(typeof R.setBigUint64=="function")return R.setBigUint64(E,U,H);const K=BigInt(32),W=BigInt(4294967295),G=Number(U>>K&W),Z=Number(U&W),Y=H?4:0,X=H?0:4;R.setUint32(E+Y,G,H),R.setUint32(E+X,Z,H)}let SHA2$1=class extends Hash$3{constructor(E,U,H,K){super(),this.blockLen=E,this.outputLen=U,this.padOffset=H,this.isLE=K,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(E),this.view=createView$3(this.buffer)}update(E){exists$1(this);const{view:U,buffer:H,blockLen:K}=this;E=toBytes$3(E);const W=E.length;for(let G=0;G<W;){const Z=Math.min(K-this.pos,W-G);if(Z===K){const Y=createView$3(E);for(;K<=W-G;G+=K)this.process(Y,G);continue}H.set(E.subarray(G,G+Z),this.pos),this.pos+=Z,G+=Z,this.pos===K&&(this.process(U,0),this.pos=0)}return this.length+=E.length,this.roundClean(),this}digestInto(E){exists$1(this),output$1(E,this),this.finished=!0;const{buffer:U,view:H,blockLen:K,isLE:W}=this;let{pos:G}=this;U[G++]=128,this.buffer.subarray(G).fill(0),this.padOffset>K-G&&(this.process(H,0),G=0);for(let J=G;J<K;J++)U[J]=0;setBigUint64$3(H,K-8,BigInt(this.length*8),W),this.process(H,0);const Z=createView$3(E),Y=this.outputLen;if(Y%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const X=Y/4,Q=this.get();if(X>Q.length)throw new Error("_sha2: outputLen bigger than state");for(let J=0;J<X;J++)Z.setUint32(4*J,Q[J],W)}digest(){const{buffer:E,outputLen:U}=this;this.digestInto(E);const H=E.slice(0,U);return this.destroy(),H}_cloneInto(E){E||(E=new this.constructor),E.set(...this.get());const{blockLen:U,buffer:H,length:K,finished:W,destroyed:G,pos:Z}=this;return E.length=K,E.pos=Z,E.finished=W,E.destroyed=G,K%U&&E.buffer.set(H),E}};const Chi$3=(R,E,U)=>R&E^~R&U,Maj$3=(R,E,U)=>R&E^R&U^E&U,SHA256_K$3=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),IV$1=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),SHA256_W$3=new Uint32Array(64);let SHA256$3=class extends SHA2$1{constructor(){super(64,32,8,!1),this.A=IV$1[0]|0,this.B=IV$1[1]|0,this.C=IV$1[2]|0,this.D=IV$1[3]|0,this.E=IV$1[4]|0,this.F=IV$1[5]|0,this.G=IV$1[6]|0,this.H=IV$1[7]|0}get(){const{A:E,B:U,C:H,D:K,E:W,F:G,G:Z,H:Y}=this;return[E,U,H,K,W,G,Z,Y]}set(E,U,H,K,W,G,Z,Y){this.A=E|0,this.B=U|0,this.C=H|0,this.D=K|0,this.E=W|0,this.F=G|0,this.G=Z|0,this.H=Y|0}process(E,U){for(let J=0;J<16;J++,U+=4)SHA256_W$3[J]=E.getUint32(U,!1);for(let J=16;J<64;J++){const ne=SHA256_W$3[J-15],re=SHA256_W$3[J-2],ae=rotr$3(ne,7)^rotr$3(ne,18)^ne>>>3,te=rotr$3(re,17)^rotr$3(re,19)^re>>>10;SHA256_W$3[J]=te+SHA256_W$3[J-7]+ae+SHA256_W$3[J-16]|0}let{A:H,B:K,C:W,D:G,E:Z,F:Y,G:X,H:Q}=this;for(let J=0;J<64;J++){const ne=rotr$3(Z,6)^rotr$3(Z,11)^rotr$3(Z,25),re=Q+ne+Chi$3(Z,Y,X)+SHA256_K$3[J]+SHA256_W$3[J]|0,te=(rotr$3(H,2)^rotr$3(H,13)^rotr$3(H,22))+Maj$3(H,K,W)|0;Q=X,X=Y,Y=Z,Z=G+re|0,G=W,W=K,K=H,H=re+te|0}H=H+this.A|0,K=K+this.B|0,W=W+this.C|0,G=G+this.D|0,Z=Z+this.E|0,Y=Y+this.F|0,X=X+this.G|0,Q=Q+this.H|0,this.set(H,K,W,G,Z,Y,X,Q)}roundClean(){SHA256_W$3.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}};const sha256$3=wrapConstructor$3(()=>new SHA256$3);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const _0n$9=BigInt(0),_1n$9=BigInt(1),_2n$5=BigInt(2),u8a$1=R=>R instanceof Uint8Array,hexes$3=Array.from({length:256},(R,E)=>E.toString(16).padStart(2,"0"));function bytesToHex$3(R){if(!u8a$1(R))throw new Error("Uint8Array expected");let E="";for(let U=0;U<R.length;U++)E+=hexes$3[R[U]];return E}function numberToHexUnpadded$1(R){const E=R.toString(16);return E.length&1?`0${E}`:E}function hexToNumber$1(R){if(typeof R!="string")throw new Error("hex string expected, got "+typeof R);return BigInt(R===""?"0":`0x${R}`)}function hexToBytes$3(R){if(typeof R!="string")throw new Error("hex string expected, got "+typeof R);const E=R.length;if(E%2)throw new Error("padded hex string expected, got unpadded hex of length "+E);const U=new Uint8Array(E/2);for(let H=0;H<U.length;H++){const K=H*2,W=R.slice(K,K+2),G=Number.parseInt(W,16);if(Number.isNaN(G)||G<0)throw new Error("Invalid byte sequence");U[H]=G}return U}function bytesToNumberBE$1(R){return hexToNumber$1(bytesToHex$3(R))}function bytesToNumberLE$1(R){if(!u8a$1(R))throw new Error("Uint8Array expected");return hexToNumber$1(bytesToHex$3(Uint8Array.from(R).reverse()))}function numberToBytesBE$1(R,E){return hexToBytes$3(R.toString(16).padStart(E*2,"0"))}function numberToBytesLE$1(R,E){return numberToBytesBE$1(R,E).reverse()}function numberToVarBytesBE$1(R){return hexToBytes$3(numberToHexUnpadded$1(R))}function ensureBytes$1(R,E,U){let H;if(typeof E=="string")try{H=hexToBytes$3(E)}catch(W){throw new Error(`${R} must be valid hex string, got "${E}". Cause: ${W}`)}else if(u8a$1(E))H=Uint8Array.from(E);else throw new Error(`${R} must be hex string or Uint8Array`);const K=H.length;if(typeof U=="number"&&K!==U)throw new Error(`${R} expected ${U} bytes, got ${K}`);return H}function concatBytes$3(...R){const E=new Uint8Array(R.reduce((H,K)=>H+K.length,0));let U=0;return R.forEach(H=>{if(!u8a$1(H))throw new Error("Uint8Array expected");E.set(H,U),U+=H.length}),E}function equalBytes$2(R,E){if(R.length!==E.length)return!1;for(let U=0;U<R.length;U++)if(R[U]!==E[U])return!1;return!0}function utf8ToBytes$4(R){if(typeof R!="string")throw new Error(`utf8ToBytes expected string, got ${typeof R}`);return new Uint8Array(new TextEncoder().encode(R))}function bitLen$1(R){let E;for(E=0;R>_0n$9;R>>=_1n$9,E+=1);return E}function bitGet$1(R,E){return R>>BigInt(E)&_1n$9}const bitSet$1=(R,E,U)=>R|(U?_1n$9:_0n$9)<<BigInt(E),bitMask$1=R=>(_2n$5<<BigInt(R-1))-_1n$9,u8n$1=R=>new Uint8Array(R),u8fr$1=R=>Uint8Array.from(R);function createHmacDrbg$1(R,E,U){if(typeof R!="number"||R<2)throw new Error("hashLen must be a number");if(typeof E!="number"||E<2)throw new Error("qByteLen must be a number");if(typeof U!="function")throw new Error("hmacFn must be a function");let H=u8n$1(R),K=u8n$1(R),W=0;const G=()=>{H.fill(1),K.fill(0),W=0},Z=(...J)=>U(K,H,...J),Y=(J=u8n$1())=>{K=Z(u8fr$1([0]),J),H=Z(),J.length!==0&&(K=Z(u8fr$1([1]),J),H=Z())},X=()=>{if(W++>=1e3)throw new Error("drbg: tried 1000 values");let J=0;const ne=[];for(;J<E;){H=Z();const re=H.slice();ne.push(re),J+=H.length}return concatBytes$3(...ne)};return(J,ne)=>{G(),Y(J);let re;for(;!(re=ne(X()));)Y();return G(),re}}const validatorFns$1={bigint:R=>typeof R=="bigint",function:R=>typeof R=="function",boolean:R=>typeof R=="boolean",string:R=>typeof R=="string",stringOrUint8Array:R=>typeof R=="string"||R instanceof Uint8Array,isSafeInteger:R=>Number.isSafeInteger(R),array:R=>Array.isArray(R),field:(R,E)=>E.Fp.isValid(R),hash:R=>typeof R=="function"&&Number.isSafeInteger(R.outputLen)};function validateObject$1(R,E,U={}){const H=(K,W,G)=>{const Z=validatorFns$1[W];if(typeof Z!="function")throw new Error(`Invalid validator "${W}", expected function`);const Y=R[K];if(!(G&&Y===void 0)&&!Z(Y,R))throw new Error(`Invalid param ${String(K)}=${Y} (${typeof Y}), expected ${W}`)};for(const[K,W]of Object.entries(E))H(K,W,!1);for(const[K,W]of Object.entries(U))H(K,W,!0);return R}const ut$1=Object.freeze(Object.defineProperty({__proto__:null,bitGet:bitGet$1,bitLen:bitLen$1,bitMask:bitMask$1,bitSet:bitSet$1,bytesToHex:bytesToHex$3,bytesToNumberBE:bytesToNumberBE$1,bytesToNumberLE:bytesToNumberLE$1,concatBytes:concatBytes$3,createHmacDrbg:createHmacDrbg$1,ensureBytes:ensureBytes$1,equalBytes:equalBytes$2,hexToBytes:hexToBytes$3,hexToNumber:hexToNumber$1,numberToBytesBE:numberToBytesBE$1,numberToBytesLE:numberToBytesLE$1,numberToHexUnpadded:numberToHexUnpadded$1,numberToVarBytesBE:numberToVarBytesBE$1,utf8ToBytes:utf8ToBytes$4,validateObject:validateObject$1},Symbol.toStringTag,{value:"Module"}));/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const _0n$8=BigInt(0),_1n$8=BigInt(1),_2n$4=BigInt(2),_3n$3=BigInt(3),_4n$1=BigInt(4),_5n$1=BigInt(5),_8n$1=BigInt(8);BigInt(9);BigInt(16);function mod$1(R,E){const U=R%E;return U>=_0n$8?U:E+U}function pow$1(R,E,U){if(U<=_0n$8||E<_0n$8)throw new Error("Expected power/modulo > 0");if(U===_1n$8)return _0n$8;let H=_1n$8;for(;E>_0n$8;)E&_1n$8&&(H=H*R%U),R=R*R%U,E>>=_1n$8;return H}function pow2$1(R,E,U){let H=R;for(;E-- >_0n$8;)H*=H,H%=U;return H}function invert$1(R,E){if(R===_0n$8||E<=_0n$8)throw new Error(`invert: expected positive integers, got n=${R} mod=${E}`);let U=mod$1(R,E),H=E,K=_0n$8,W=_1n$8;for(;U!==_0n$8;){const Z=H/U,Y=H%U,X=K-W*Z;H=U,U=Y,K=W,W=X}if(H!==_1n$8)throw new Error("invert: does not exist");return mod$1(K,E)}function tonelliShanks$1(R){const E=(R-_1n$8)/_2n$4;let U,H,K;for(U=R-_1n$8,H=0;U%_2n$4===_0n$8;U/=_2n$4,H++);for(K=_2n$4;K<R&&pow$1(K,E,R)!==R-_1n$8;K++);if(H===1){const G=(R+_1n$8)/_4n$1;return function(Y,X){const Q=Y.pow(X,G);if(!Y.eql(Y.sqr(Q),X))throw new Error("Cannot find square root");return Q}}const W=(U+_1n$8)/_2n$4;return function(Z,Y){if(Z.pow(Y,E)===Z.neg(Z.ONE))throw new Error("Cannot find square root");let X=H,Q=Z.pow(Z.mul(Z.ONE,K),U),J=Z.pow(Y,W),ne=Z.pow(Y,U);for(;!Z.eql(ne,Z.ONE);){if(Z.eql(ne,Z.ZERO))return Z.ZERO;let re=1;for(let te=Z.sqr(ne);re<X&&!Z.eql(te,Z.ONE);re++)te=Z.sqr(te);const ae=Z.pow(Q,_1n$8<<BigInt(X-re-1));Q=Z.sqr(ae),J=Z.mul(J,ae),ne=Z.mul(ne,Q),X=re}return J}}function FpSqrt$1(R){if(R%_4n$1===_3n$3){const E=(R+_1n$8)/_4n$1;return function(H,K){const W=H.pow(K,E);if(!H.eql(H.sqr(W),K))throw new Error("Cannot find square root");return W}}if(R%_8n$1===_5n$1){const E=(R-_5n$1)/_8n$1;return function(H,K){const W=H.mul(K,_2n$4),G=H.pow(W,E),Z=H.mul(K,G),Y=H.mul(H.mul(Z,_2n$4),G),X=H.mul(Z,H.sub(Y,H.ONE));if(!H.eql(H.sqr(X),K))throw new Error("Cannot find square root");return X}}return tonelliShanks$1(R)}const FIELD_FIELDS$1=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function validateField$1(R){const E={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},U=FIELD_FIELDS$1.reduce((H,K)=>(H[K]="function",H),E);return validateObject$1(R,U)}function FpPow$1(R,E,U){if(U<_0n$8)throw new Error("Expected power > 0");if(U===_0n$8)return R.ONE;if(U===_1n$8)return E;let H=R.ONE,K=E;for(;U>_0n$8;)U&_1n$8&&(H=R.mul(H,K)),K=R.sqr(K),U>>=_1n$8;return H}function FpInvertBatch$1(R,E){const U=new Array(E.length),H=E.reduce((W,G,Z)=>R.is0(G)?W:(U[Z]=W,R.mul(W,G)),R.ONE),K=R.inv(H);return E.reduceRight((W,G,Z)=>R.is0(G)?W:(U[Z]=R.mul(W,U[Z]),R.mul(W,G)),K),U}function nLength$1(R,E){const U=E!==void 0?E:R.toString(2).length,H=Math.ceil(U/8);return{nBitLength:U,nByteLength:H}}function Field$1(R,E,U=!1,H={}){if(R<=_0n$8)throw new Error(`Expected Field ORDER > 0, got ${R}`);const{nBitLength:K,nByteLength:W}=nLength$1(R,E);if(W>2048)throw new Error("Field lengths over 2048 bytes are not supported");const G=FpSqrt$1(R),Z=Object.freeze({ORDER:R,BITS:K,BYTES:W,MASK:bitMask$1(K),ZERO:_0n$8,ONE:_1n$8,create:Y=>mod$1(Y,R),isValid:Y=>{if(typeof Y!="bigint")throw new Error(`Invalid field element: expected bigint, got ${typeof Y}`);return _0n$8<=Y&&Y<R},is0:Y=>Y===_0n$8,isOdd:Y=>(Y&_1n$8)===_1n$8,neg:Y=>mod$1(-Y,R),eql:(Y,X)=>Y===X,sqr:Y=>mod$1(Y*Y,R),add:(Y,X)=>mod$1(Y+X,R),sub:(Y,X)=>mod$1(Y-X,R),mul:(Y,X)=>mod$1(Y*X,R),pow:(Y,X)=>FpPow$1(Z,Y,X),div:(Y,X)=>mod$1(Y*invert$1(X,R),R),sqrN:Y=>Y*Y,addN:(Y,X)=>Y+X,subN:(Y,X)=>Y-X,mulN:(Y,X)=>Y*X,inv:Y=>invert$1(Y,R),sqrt:H.sqrt||(Y=>G(Z,Y)),invertBatch:Y=>FpInvertBatch$1(Z,Y),cmov:(Y,X,Q)=>Q?X:Y,toBytes:Y=>U?numberToBytesLE$1(Y,W):numberToBytesBE$1(Y,W),fromBytes:Y=>{if(Y.length!==W)throw new Error(`Fp.fromBytes: expected ${W}, got ${Y.length}`);return U?bytesToNumberLE$1(Y):bytesToNumberBE$1(Y)}});return Object.freeze(Z)}function getFieldBytesLength$1(R){if(typeof R!="bigint")throw new Error("field order must be bigint");const E=R.toString(2).length;return Math.ceil(E/8)}function getMinHashLength$1(R){const E=getFieldBytesLength$1(R);return E+Math.ceil(E/2)}function mapHashToField$1(R,E,U=!1){const H=R.length,K=getFieldBytesLength$1(E),W=getMinHashLength$1(E);if(H<16||H<W||H>1024)throw new Error(`expected ${W}-1024 bytes of input, got ${H}`);const G=U?bytesToNumberBE$1(R):bytesToNumberLE$1(R),Z=mod$1(G,E-_1n$8)+_1n$8;return U?numberToBytesLE$1(Z,K):numberToBytesBE$1(Z,K)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const _0n$7=BigInt(0),_1n$7=BigInt(1);function wNAF$1(R,E){const U=(K,W)=>{const G=W.negate();return K?G:W},H=K=>{const W=Math.ceil(E/K)+1,G=2**(K-1);return{windows:W,windowSize:G}};return{constTimeNegate:U,unsafeLadder(K,W){let G=R.ZERO,Z=K;for(;W>_0n$7;)W&_1n$7&&(G=G.add(Z)),Z=Z.double(),W>>=_1n$7;return G},precomputeWindow(K,W){const{windows:G,windowSize:Z}=H(W),Y=[];let X=K,Q=X;for(let J=0;J<G;J++){Q=X,Y.push(Q);for(let ne=1;ne<Z;ne++)Q=Q.add(X),Y.push(Q);X=Q.double()}return Y},wNAF(K,W,G){const{windows:Z,windowSize:Y}=H(K);let X=R.ZERO,Q=R.BASE;const J=BigInt(2**K-1),ne=2**K,re=BigInt(K);for(let ae=0;ae<Z;ae++){const te=ae*Y;let se=Number(G&J);G>>=re,se>Y&&(se-=ne,G+=_1n$7);const ie=te,ye=te+Math.abs(se)-1,me=ae%2!==0,_e=se<0;se===0?Q=Q.add(U(me,W[ie])):X=X.add(U(_e,W[ye]))}return{p:X,f:Q}},wNAFCached(K,W,G,Z){const Y=K._WINDOW_SIZE||1;let X=W.get(K);return X||(X=this.precomputeWindow(K,Y),Y!==1&&W.set(K,Z(X))),this.wNAF(Y,X,G)}}}function validateBasic$1(R){return validateField$1(R.Fp),validateObject$1(R,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...nLength$1(R.n,R.nBitLength),...R,p:R.Fp.ORDER})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function validatePointOpts$1(R){const E=validateBasic$1(R);validateObject$1(E,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:U,Fp:H,a:K}=E;if(U){if(!H.eql(K,H.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if(typeof U!="object"||typeof U.beta!="bigint"||typeof U.splitScalar!="function")throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...E})}const{bytesToNumberBE:b2n$1,hexToBytes:h2b$1}=ut$1,DER$1={Err:class extends Error{constructor(E=""){super(E)}},_parseInt(R){const{Err:E}=DER$1;if(R.length<2||R[0]!==2)throw new E("Invalid signature integer tag");const U=R[1],H=R.subarray(2,U+2);if(!U||H.length!==U)throw new E("Invalid signature integer: wrong length");if(H[0]&128)throw new E("Invalid signature integer: negative");if(H[0]===0&&!(H[1]&128))throw new E("Invalid signature integer: unnecessary leading zero");return{d:b2n$1(H),l:R.subarray(U+2)}},toSig(R){const{Err:E}=DER$1,U=typeof R=="string"?h2b$1(R):R;if(!(U instanceof Uint8Array))throw new Error("ui8a expected");let H=U.length;if(H<2||U[0]!=48)throw new E("Invalid signature tag");if(U[1]!==H-2)throw new E("Invalid signature: incorrect length");const{d:K,l:W}=DER$1._parseInt(U.subarray(2)),{d:G,l:Z}=DER$1._parseInt(W);if(Z.length)throw new E("Invalid signature: left bytes after parsing");return{r:K,s:G}},hexFromSig(R){const E=X=>Number.parseInt(X[0],16)&8?"00"+X:X,U=X=>{const Q=X.toString(16);return Q.length&1?`0${Q}`:Q},H=E(U(R.s)),K=E(U(R.r)),W=H.length/2,G=K.length/2,Z=U(W),Y=U(G);return`30${U(G+W+4)}02${Y}${K}02${Z}${H}`}},_0n$6=BigInt(0),_1n$6=BigInt(1);BigInt(2);const _3n$2=BigInt(3);BigInt(4);function weierstrassPoints$1(R){const E=validatePointOpts$1(R),{Fp:U}=E,H=E.toBytes||((ae,te,se)=>{const ie=te.toAffine();return concatBytes$3(Uint8Array.from([4]),U.toBytes(ie.x),U.toBytes(ie.y))}),K=E.fromBytes||(ae=>{const te=ae.subarray(1),se=U.fromBytes(te.subarray(0,U.BYTES)),ie=U.fromBytes(te.subarray(U.BYTES,2*U.BYTES));return{x:se,y:ie}});function W(ae){const{a:te,b:se}=E,ie=U.sqr(ae),ye=U.mul(ie,ae);return U.add(U.add(ye,U.mul(ae,te)),se)}if(!U.eql(U.sqr(E.Gy),W(E.Gx)))throw new Error("bad generator point: equation left != right");function G(ae){return typeof ae=="bigint"&&_0n$6<ae&&ae<E.n}function Z(ae){if(!G(ae))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function Y(ae){const{allowedPrivateKeyLengths:te,nByteLength:se,wrapPrivateKey:ie,n:ye}=E;if(te&&typeof ae!="bigint"){if(ae instanceof Uint8Array&&(ae=bytesToHex$3(ae)),typeof ae!="string"||!te.includes(ae.length))throw new Error("Invalid key");ae=ae.padStart(se*2,"0")}let me;try{me=typeof ae=="bigint"?ae:bytesToNumberBE$1(ensureBytes$1("private key",ae,se))}catch{throw new Error(`private key must be ${se} bytes, hex or bigint, not ${typeof ae}`)}return ie&&(me=mod$1(me,ye)),Z(me),me}const X=new Map;function Q(ae){if(!(ae instanceof J))throw new Error("ProjectivePoint expected")}class J{constructor(te,se,ie){if(this.px=te,this.py=se,this.pz=ie,te==null||!U.isValid(te))throw new Error("x required");if(se==null||!U.isValid(se))throw new Error("y required");if(ie==null||!U.isValid(ie))throw new Error("z required")}static fromAffine(te){const{x:se,y:ie}=te||{};if(!te||!U.isValid(se)||!U.isValid(ie))throw new Error("invalid affine point");if(te instanceof J)throw new Error("projective point not allowed");const ye=me=>U.eql(me,U.ZERO);return ye(se)&&ye(ie)?J.ZERO:new J(se,ie,U.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(te){const se=U.invertBatch(te.map(ie=>ie.pz));return te.map((ie,ye)=>ie.toAffine(se[ye])).map(J.fromAffine)}static fromHex(te){const se=J.fromAffine(K(ensureBytes$1("pointHex",te)));return se.assertValidity(),se}static fromPrivateKey(te){return J.BASE.multiply(Y(te))}_setWindowSize(te){this._WINDOW_SIZE=te,X.delete(this)}assertValidity(){if(this.is0()){if(E.allowInfinityPoint&&!U.is0(this.py))return;throw new Error("bad point: ZERO")}const{x:te,y:se}=this.toAffine();if(!U.isValid(te)||!U.isValid(se))throw new Error("bad point: x or y not FE");const ie=U.sqr(se),ye=W(te);if(!U.eql(ie,ye))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){const{y:te}=this.toAffine();if(U.isOdd)return!U.isOdd(te);throw new Error("Field doesn't support isOdd")}equals(te){Q(te);const{px:se,py:ie,pz:ye}=this,{px:me,py:_e,pz:oe}=te,ue=U.eql(U.mul(se,oe),U.mul(me,ye)),he=U.eql(U.mul(ie,oe),U.mul(_e,ye));return ue&&he}negate(){return new J(this.px,U.neg(this.py),this.pz)}double(){const{a:te,b:se}=E,ie=U.mul(se,_3n$2),{px:ye,py:me,pz:_e}=this;let oe=U.ZERO,ue=U.ZERO,he=U.ZERO,we=U.mul(ye,ye),xe=U.mul(me,me),ke=U.mul(_e,_e),ce=U.mul(ye,me);return ce=U.add(ce,ce),he=U.mul(ye,_e),he=U.add(he,he),oe=U.mul(te,he),ue=U.mul(ie,ke),ue=U.add(oe,ue),oe=U.sub(xe,ue),ue=U.add(xe,ue),ue=U.mul(oe,ue),oe=U.mul(ce,oe),he=U.mul(ie,he),ke=U.mul(te,ke),ce=U.sub(we,ke),ce=U.mul(te,ce),ce=U.add(ce,he),he=U.add(we,we),we=U.add(he,we),we=U.add(we,ke),we=U.mul(we,ce),ue=U.add(ue,we),ke=U.mul(me,_e),ke=U.add(ke,ke),we=U.mul(ke,ce),oe=U.sub(oe,we),he=U.mul(ke,xe),he=U.add(he,he),he=U.add(he,he),new J(oe,ue,he)}add(te){Q(te);const{px:se,py:ie,pz:ye}=this,{px:me,py:_e,pz:oe}=te;let ue=U.ZERO,he=U.ZERO,we=U.ZERO;const xe=E.a,ke=U.mul(E.b,_3n$2);let ce=U.mul(se,me),pe=U.mul(ie,_e),ve=U.mul(ye,oe),Ee=U.add(se,ie),de=U.add(me,_e);Ee=U.mul(Ee,de),de=U.add(ce,pe),Ee=U.sub(Ee,de),de=U.add(se,ye);let be=U.add(me,oe);return de=U.mul(de,be),be=U.add(ce,ve),de=U.sub(de,be),be=U.add(ie,ye),ue=U.add(_e,oe),be=U.mul(be,ue),ue=U.add(pe,ve),be=U.sub(be,ue),we=U.mul(xe,de),ue=U.mul(ke,ve),we=U.add(ue,we),ue=U.sub(pe,we),we=U.add(pe,we),he=U.mul(ue,we),pe=U.add(ce,ce),pe=U.add(pe,ce),ve=U.mul(xe,ve),de=U.mul(ke,de),pe=U.add(pe,ve),ve=U.sub(ce,ve),ve=U.mul(xe,ve),de=U.add(de,ve),ce=U.mul(pe,de),he=U.add(he,ce),ce=U.mul(be,de),ue=U.mul(Ee,ue),ue=U.sub(ue,ce),ce=U.mul(Ee,pe),we=U.mul(be,we),we=U.add(we,ce),new J(ue,he,we)}subtract(te){return this.add(te.negate())}is0(){return this.equals(J.ZERO)}wNAF(te){return re.wNAFCached(this,X,te,se=>{const ie=U.invertBatch(se.map(ye=>ye.pz));return se.map((ye,me)=>ye.toAffine(ie[me])).map(J.fromAffine)})}multiplyUnsafe(te){const se=J.ZERO;if(te===_0n$6)return se;if(Z(te),te===_1n$6)return this;const{endo:ie}=E;if(!ie)return re.unsafeLadder(this,te);let{k1neg:ye,k1:me,k2neg:_e,k2:oe}=ie.splitScalar(te),ue=se,he=se,we=this;for(;me>_0n$6||oe>_0n$6;)me&_1n$6&&(ue=ue.add(we)),oe&_1n$6&&(he=he.add(we)),we=we.double(),me>>=_1n$6,oe>>=_1n$6;return ye&&(ue=ue.negate()),_e&&(he=he.negate()),he=new J(U.mul(he.px,ie.beta),he.py,he.pz),ue.add(he)}multiply(te){Z(te);let se=te,ie,ye;const{endo:me}=E;if(me){const{k1neg:_e,k1:oe,k2neg:ue,k2:he}=me.splitScalar(se);let{p:we,f:xe}=this.wNAF(oe),{p:ke,f:ce}=this.wNAF(he);we=re.constTimeNegate(_e,we),ke=re.constTimeNegate(ue,ke),ke=new J(U.mul(ke.px,me.beta),ke.py,ke.pz),ie=we.add(ke),ye=xe.add(ce)}else{const{p:_e,f:oe}=this.wNAF(se);ie=_e,ye=oe}return J.normalizeZ([ie,ye])[0]}multiplyAndAddUnsafe(te,se,ie){const ye=J.BASE,me=(oe,ue)=>ue===_0n$6||ue===_1n$6||!oe.equals(ye)?oe.multiplyUnsafe(ue):oe.multiply(ue),_e=me(this,se).add(me(te,ie));return _e.is0()?void 0:_e}toAffine(te){const{px:se,py:ie,pz:ye}=this,me=this.is0();te==null&&(te=me?U.ONE:U.inv(ye));const _e=U.mul(se,te),oe=U.mul(ie,te),ue=U.mul(ye,te);if(me)return{x:U.ZERO,y:U.ZERO};if(!U.eql(ue,U.ONE))throw new Error("invZ was invalid");return{x:_e,y:oe}}isTorsionFree(){const{h:te,isTorsionFree:se}=E;if(te===_1n$6)return!0;if(se)return se(J,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:te,clearCofactor:se}=E;return te===_1n$6?this:se?se(J,this):this.multiplyUnsafe(E.h)}toRawBytes(te=!0){return this.assertValidity(),H(J,this,te)}toHex(te=!0){return bytesToHex$3(this.toRawBytes(te))}}J.BASE=new J(E.Gx,E.Gy,U.ONE),J.ZERO=new J(U.ZERO,U.ONE,U.ZERO);const ne=E.nBitLength,re=wNAF$1(J,E.endo?Math.ceil(ne/2):ne);return{CURVE:E,ProjectivePoint:J,normPrivateKeyToScalar:Y,weierstrassEquation:W,isWithinCurveOrder:G}}function validateOpts$1(R){const E=validateBasic$1(R);return validateObject$1(E,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...E})}function weierstrass$1(R){const E=validateOpts$1(R),{Fp:U,n:H}=E,K=U.BYTES+1,W=2*U.BYTES+1;function G(de){return _0n$6<de&&de<U.ORDER}function Z(de){return mod$1(de,H)}function Y(de){return invert$1(de,H)}const{ProjectivePoint:X,normPrivateKeyToScalar:Q,weierstrassEquation:J,isWithinCurveOrder:ne}=weierstrassPoints$1({...E,toBytes(de,be,$e){const Ae=be.toAffine(),Re=U.toBytes(Ae.x),Ce=concatBytes$3;return $e?Ce(Uint8Array.from([be.hasEvenY()?2:3]),Re):Ce(Uint8Array.from([4]),Re,U.toBytes(Ae.y))},fromBytes(de){const be=de.length,$e=de[0],Ae=de.subarray(1);if(be===K&&($e===2||$e===3)){const Re=bytesToNumberBE$1(Ae);if(!G(Re))throw new Error("Point is not on curve");const Ce=J(Re);let Se=U.sqrt(Ce);const Te=(Se&_1n$6)===_1n$6;return($e&1)===1!==Te&&(Se=U.neg(Se)),{x:Re,y:Se}}else if(be===W&&$e===4){const Re=U.fromBytes(Ae.subarray(0,U.BYTES)),Ce=U.fromBytes(Ae.subarray(U.BYTES,2*U.BYTES));return{x:Re,y:Ce}}else throw new Error(`Point of length ${be} was invalid. Expected ${K} compressed bytes or ${W} uncompressed bytes`)}}),re=de=>bytesToHex$3(numberToBytesBE$1(de,E.nByteLength));function ae(de){const be=H>>_1n$6;return de>be}function te(de){return ae(de)?Z(-de):de}const se=(de,be,$e)=>bytesToNumberBE$1(de.slice(be,$e));class ie{constructor(be,$e,Ae){this.r=be,this.s=$e,this.recovery=Ae,this.assertValidity()}static fromCompact(be){const $e=E.nByteLength;return be=ensureBytes$1("compactSignature",be,$e*2),new ie(se(be,0,$e),se(be,$e,2*$e))}static fromDER(be){const{r:$e,s:Ae}=DER$1.toSig(ensureBytes$1("DER",be));return new ie($e,Ae)}assertValidity(){if(!ne(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!ne(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(be){return new ie(this.r,this.s,be)}recoverPublicKey(be){const{r:$e,s:Ae,recovery:Re}=this,Ce=he(ensureBytes$1("msgHash",be));if(Re==null||![0,1,2,3].includes(Re))throw new Error("recovery id invalid");const Se=Re===2||Re===3?$e+E.n:$e;if(Se>=U.ORDER)throw new Error("recovery id 2 or 3 invalid");const Te=Re&1?"03":"02",Ne=X.fromHex(Te+re(Se)),Ie=Y(Se),Be=Z(-Ce*Ie),Le=Z(Ae*Ie),Ue=X.BASE.multiplyAndAddUnsafe(Ne,Be,Le);if(!Ue)throw new Error("point at infinify");return Ue.assertValidity(),Ue}hasHighS(){return ae(this.s)}normalizeS(){return this.hasHighS()?new ie(this.r,Z(-this.s),this.recovery):this}toDERRawBytes(){return hexToBytes$3(this.toDERHex())}toDERHex(){return DER$1.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return hexToBytes$3(this.toCompactHex())}toCompactHex(){return re(this.r)+re(this.s)}}const ye={isValidPrivateKey(de){try{return Q(de),!0}catch{return!1}},normPrivateKeyToScalar:Q,randomPrivateKey:()=>{const de=getMinHashLength$1(E.n);return mapHashToField$1(E.randomBytes(de),E.n)},precompute(de=8,be=X.BASE){return be._setWindowSize(de),be.multiply(BigInt(3)),be}};function me(de,be=!0){return X.fromPrivateKey(de).toRawBytes(be)}function _e(de){const be=de instanceof Uint8Array,$e=typeof de=="string",Ae=(be||$e)&&de.length;return be?Ae===K||Ae===W:$e?Ae===2*K||Ae===2*W:de instanceof X}function oe(de,be,$e=!0){if(_e(de))throw new Error("first arg must be private key");if(!_e(be))throw new Error("second arg must be public key");return X.fromHex(be).multiply(Q(de)).toRawBytes($e)}const ue=E.bits2int||function(de){const be=bytesToNumberBE$1(de),$e=de.length*8-E.nBitLength;return $e>0?be>>BigInt($e):be},he=E.bits2int_modN||function(de){return Z(ue(de))},we=bitMask$1(E.nBitLength);function xe(de){if(typeof de!="bigint")throw new Error("bigint expected");if(!(_0n$6<=de&&de<we))throw new Error(`bigint expected < 2^${E.nBitLength}`);return numberToBytesBE$1(de,E.nByteLength)}function ke(de,be,$e=ce){if(["recovered","canonical"].some(De=>De in $e))throw new Error("sign() legacy options not supported");const{hash:Ae,randomBytes:Re}=E;let{lowS:Ce,prehash:Se,extraEntropy:Te}=$e;Ce==null&&(Ce=!0),de=ensureBytes$1("msgHash",de),Se&&(de=ensureBytes$1("prehashed msgHash",Ae(de)));const Ne=he(de),Ie=Q(be),Be=[xe(Ie),xe(Ne)];if(Te!=null){const De=Te===!0?Re(U.BYTES):Te;Be.push(ensureBytes$1("extraEntropy",De))}const Le=concatBytes$3(...Be),Ue=Ne;function Me(De){const He=ue(De);if(!ne(He))return;const qe=Y(He),Fe=X.BASE.multiply(He).toAffine(),Pe=Z(Fe.x);if(Pe===_0n$6)return;const Oe=Z(qe*Z(Ue+Pe*Ie));if(Oe===_0n$6)return;let Ke=(Fe.x===Pe?0:2)|Number(Fe.y&_1n$6),Ge=Oe;return Ce&&ae(Oe)&&(Ge=te(Oe),Ke^=1),new ie(Pe,Ge,Ke)}return{seed:Le,k2sig:Me}}const ce={lowS:E.lowS,prehash:!1},pe={lowS:E.lowS,prehash:!1};function ve(de,be,$e=ce){const{seed:Ae,k2sig:Re}=ke(de,be,$e),Ce=E;return createHmacDrbg$1(Ce.hash.outputLen,Ce.nByteLength,Ce.hmac)(Ae,Re)}X.BASE._setWindowSize(8);function Ee(de,be,$e,Ae=pe){var Fe;const Re=de;if(be=ensureBytes$1("msgHash",be),$e=ensureBytes$1("publicKey",$e),"strict"in Ae)throw new Error("options.strict was renamed to lowS");const{lowS:Ce,prehash:Se}=Ae;let Te,Ne;try{if(typeof Re=="string"||Re instanceof Uint8Array)try{Te=ie.fromDER(Re)}catch(Pe){if(!(Pe instanceof DER$1.Err))throw Pe;Te=ie.fromCompact(Re)}else if(typeof Re=="object"&&typeof Re.r=="bigint"&&typeof Re.s=="bigint"){const{r:Pe,s:Oe}=Re;Te=new ie(Pe,Oe)}else throw new Error("PARSE");Ne=X.fromHex($e)}catch(Pe){if(Pe.message==="PARSE")throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(Ce&&Te.hasHighS())return!1;Se&&(be=E.hash(be));const{r:Ie,s:Be}=Te,Le=he(be),Ue=Y(Be),Me=Z(Le*Ue),De=Z(Ie*Ue),He=(Fe=X.BASE.multiplyAndAddUnsafe(Ne,Me,De))==null?void 0:Fe.toAffine();return He?Z(He.x)===Ie:!1}return{CURVE:E,getPublicKey:me,getSharedSecret:oe,sign:ve,verify:Ee,ProjectivePoint:X,Signature:ie,utils:ye}}let HMAC$2=class extends Hash$3{constructor(E,U){super(),this.finished=!1,this.destroyed=!1,hash$1(E);const H=toBytes$3(U);if(this.iHash=E.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const K=this.blockLen,W=new Uint8Array(K);W.set(H.length>K?E.create().update(H).digest():H);for(let G=0;G<W.length;G++)W[G]^=54;this.iHash.update(W),this.oHash=E.create();for(let G=0;G<W.length;G++)W[G]^=106;this.oHash.update(W),W.fill(0)}update(E){return exists$1(this),this.iHash.update(E),this}digestInto(E){exists$1(this),bytes$2(E,this.outputLen),this.finished=!0,this.iHash.digestInto(E),this.oHash.update(E),this.oHash.digestInto(E),this.destroy()}digest(){const E=new Uint8Array(this.oHash.outputLen);return this.digestInto(E),E}_cloneInto(E){E||(E=Object.create(Object.getPrototypeOf(this),{}));const{oHash:U,iHash:H,finished:K,destroyed:W,blockLen:G,outputLen:Z}=this;return E=E,E.finished=K,E.destroyed=W,E.blockLen=G,E.outputLen=Z,E.oHash=U._cloneInto(E.oHash),E.iHash=H._cloneInto(E.iHash),E}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}};const hmac$2=(R,E,U)=>new HMAC$2(R,E).update(U).digest();hmac$2.create=(R,E)=>new HMAC$2(R,E);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function getHash$1(R){return{hash:R,hmac:(E,...U)=>hmac$2(R,E,concatBytes$4(...U)),randomBytes:randomBytes$2}}function createCurve$1(R,E){const U=H=>weierstrass$1({...R,...getHash$1(H)});return Object.freeze({...U(E),create:U})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const secp256k1P$1=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),secp256k1N$1=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),_1n$5=BigInt(1),_2n$3=BigInt(2),divNearest$1=(R,E)=>(R+E/_2n$3)/E;function sqrtMod$1(R){const E=secp256k1P$1,U=BigInt(3),H=BigInt(6),K=BigInt(11),W=BigInt(22),G=BigInt(23),Z=BigInt(44),Y=BigInt(88),X=R*R*R%E,Q=X*X*R%E,J=pow2$1(Q,U,E)*Q%E,ne=pow2$1(J,U,E)*Q%E,re=pow2$1(ne,_2n$3,E)*X%E,ae=pow2$1(re,K,E)*re%E,te=pow2$1(ae,W,E)*ae%E,se=pow2$1(te,Z,E)*te%E,ie=pow2$1(se,Y,E)*se%E,ye=pow2$1(ie,Z,E)*te%E,me=pow2$1(ye,U,E)*Q%E,_e=pow2$1(me,G,E)*ae%E,oe=pow2$1(_e,H,E)*X%E,ue=pow2$1(oe,_2n$3,E);if(!Fp.eql(Fp.sqr(ue),R))throw new Error("Cannot find square root");return ue}const Fp=Field$1(secp256k1P$1,void 0,void 0,{sqrt:sqrtMod$1}),secp256k1$1=createCurve$1({a:BigInt(0),b:BigInt(7),Fp,n:secp256k1N$1,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:R=>{const E=secp256k1N$1,U=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),H=-_1n$5*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),K=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),W=U,G=BigInt("0x100000000000000000000000000000000"),Z=divNearest$1(W*R,E),Y=divNearest$1(-H*R,E);let X=mod$1(R-Z*U-Y*K,E),Q=mod$1(-Z*H-Y*W,E);const J=X>G,ne=Q>G;if(J&&(X=E-X),ne&&(Q=E-Q),X>G||Q>G)throw new Error("splitScalar: Endomorphism failed, k="+R);return{k1neg:J,k1:X,k2neg:ne,k2:Q}}}},sha256$3),_0n$5=BigInt(0),fe=R=>typeof R=="bigint"&&_0n$5<R&&R<secp256k1P$1,ge=R=>typeof R=="bigint"&&_0n$5<R&&R<secp256k1N$1,TAGGED_HASH_PREFIXES$1={};function taggedHash$1(R,...E){let U=TAGGED_HASH_PREFIXES$1[R];if(U===void 0){const H=sha256$3(Uint8Array.from(R,K=>K.charCodeAt(0)));U=concatBytes$3(H,H),TAGGED_HASH_PREFIXES$1[R]=U}return sha256$3(concatBytes$3(U,...E))}const pointToBytes$1=R=>R.toRawBytes(!0).slice(1),numTo32b$1=R=>numberToBytesBE$1(R,32),modP$1=R=>mod$1(R,secp256k1P$1),modN$1=R=>mod$1(R,secp256k1N$1),Point$1=secp256k1$1.ProjectivePoint,GmulAdd$1=(R,E,U)=>Point$1.BASE.multiplyAndAddUnsafe(R,E,U);function schnorrGetExtPubKey$1(R){let E=secp256k1$1.utils.normPrivateKeyToScalar(R),U=Point$1.fromPrivateKey(E);return{scalar:U.hasEvenY()?E:modN$1(-E),bytes:pointToBytes$1(U)}}function lift_x$1(R){if(!fe(R))throw new Error("bad x: need 0 < x < p");const E=modP$1(R*R),U=modP$1(E*R+BigInt(7));let H=sqrtMod$1(U);H%_2n$3!==_0n$5&&(H=modP$1(-H));const K=new Point$1(R,H,_1n$5);return K.assertValidity(),K}function challenge$1(...R){return modN$1(bytesToNumberBE$1(taggedHash$1("BIP0340/challenge",...R)))}function schnorrGetPublicKey$1(R){return schnorrGetExtPubKey$1(R).bytes}function schnorrSign$1(R,E,U=randomBytes$2(32)){const H=ensureBytes$1("message",R),{bytes:K,scalar:W}=schnorrGetExtPubKey$1(E),G=ensureBytes$1("auxRand",U,32),Z=numTo32b$1(W^bytesToNumberBE$1(taggedHash$1("BIP0340/aux",G))),Y=taggedHash$1("BIP0340/nonce",Z,K,H),X=modN$1(bytesToNumberBE$1(Y));if(X===_0n$5)throw new Error("sign failed: k is zero");const{bytes:Q,scalar:J}=schnorrGetExtPubKey$1(X),ne=challenge$1(Q,K,H),re=new Uint8Array(64);if(re.set(Q,0),re.set(numTo32b$1(modN$1(J+ne*W)),32),!schnorrVerify$1(re,H,K))throw new Error("sign: Invalid signature produced");return re}function schnorrVerify$1(R,E,U){const H=ensureBytes$1("signature",R,64),K=ensureBytes$1("message",E),W=ensureBytes$1("publicKey",U,32);try{const G=lift_x$1(bytesToNumberBE$1(W)),Z=bytesToNumberBE$1(H.subarray(0,32));if(!fe(Z))return!1;const Y=bytesToNumberBE$1(H.subarray(32,64));if(!ge(Y))return!1;const X=challenge$1(numTo32b$1(Z),pointToBytes$1(G),K),Q=GmulAdd$1(G,Y,modN$1(-X));return!(!Q||!Q.hasEvenY()||Q.toAffine().x!==Z)}catch{return!1}}const schnorr$1={getPublicKey:schnorrGetPublicKey$1,sign:schnorrSign$1,verify:schnorrVerify$1,utils:{randomPrivateKey:secp256k1$1.utils.randomPrivateKey,lift_x:lift_x$1,pointToBytes:pointToBytes$1,numberToBytesBE:numberToBytesBE$1,bytesToNumberBE:bytesToNumberBE$1,taggedHash:taggedHash$1,mod:mod$1}},crypto$2=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */const u8a=R=>R instanceof Uint8Array,createView$2=R=>new DataView(R.buffer,R.byteOffset,R.byteLength),rotr$2=(R,E)=>R<<32-E|R>>>E,isLE$1=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!isLE$1)throw new Error("Non little-endian hardware is not supported");const hexes$2=Array.from({length:256},(R,E)=>E.toString(16).padStart(2,"0"));function bytesToHex$2(R){if(!u8a(R))throw new Error("Uint8Array expected");let E="";for(let U=0;U<R.length;U++)E+=hexes$2[R[U]];return E}function hexToBytes$2(R){if(typeof R!="string")throw new Error("hex string expected, got "+typeof R);const E=R.length;if(E%2)throw new Error("padded hex string expected, got unpadded hex of length "+E);const U=new Uint8Array(E/2);for(let H=0;H<U.length;H++){const K=H*2,W=R.slice(K,K+2),G=Number.parseInt(W,16);if(Number.isNaN(G)||G<0)throw new Error("Invalid byte sequence");U[H]=G}return U}function utf8ToBytes$3(R){if(typeof R!="string")throw new Error(`utf8ToBytes expected string, got ${typeof R}`);return new Uint8Array(new TextEncoder().encode(R))}function toBytes$2(R){if(typeof R=="string"&&(R=utf8ToBytes$3(R)),!u8a(R))throw new Error(`expected Uint8Array, got ${typeof R}`);return R}function concatBytes$2(...R){const E=new Uint8Array(R.reduce((H,K)=>H+K.length,0));let U=0;return R.forEach(H=>{if(!u8a(H))throw new Error("Uint8Array expected");E.set(H,U),U+=H.length}),E}let Hash$2=class{clone(){return this._cloneInto()}};function wrapConstructor$2(R){const E=H=>R().update(toBytes$2(H)).digest(),U=R();return E.outputLen=U.outputLen,E.blockLen=U.blockLen,E.create=()=>R(),E}function randomBytes$1(R=32){if(crypto$2&&typeof crypto$2.getRandomValues=="function")return crypto$2.getRandomValues(new Uint8Array(R));throw new Error("crypto.getRandomValues must be defined")}function number$1(R){if(!Number.isSafeInteger(R)||R<0)throw new Error(`Wrong positive integer: ${R}`)}function bool$1(R){if(typeof R!="boolean")throw new Error(`Expected boolean, not ${R}`)}function bytes$1(R,...E){if(!(R instanceof Uint8Array))throw new Error("Expected Uint8Array");if(E.length>0&&!E.includes(R.length))throw new Error(`Expected Uint8Array of length ${E}, not of length=${R.length}`)}function hash(R){if(typeof R!="function"||typeof R.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");number$1(R.outputLen),number$1(R.blockLen)}function exists(R,E=!0){if(R.destroyed)throw new Error("Hash instance has been destroyed");if(E&&R.finished)throw new Error("Hash#digest() has already been called")}function output(R,E){bytes$1(R);const U=E.outputLen;if(R.length<U)throw new Error(`digestInto() expects output buffer of length at least ${U}`)}const assert={number:number$1,bool:bool$1,bytes:bytes$1,hash,exists,output};function setBigUint64$2(R,E,U,H){if(typeof R.setBigUint64=="function")return R.setBigUint64(E,U,H);const K=BigInt(32),W=BigInt(4294967295),G=Number(U>>K&W),Z=Number(U&W),Y=H?4:0,X=H?0:4;R.setUint32(E+Y,G,H),R.setUint32(E+X,Z,H)}class SHA2 extends Hash$2{constructor(E,U,H,K){super(),this.blockLen=E,this.outputLen=U,this.padOffset=H,this.isLE=K,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(E),this.view=createView$2(this.buffer)}update(E){assert.exists(this);const{view:U,buffer:H,blockLen:K}=this;E=toBytes$2(E);const W=E.length;for(let G=0;G<W;){const Z=Math.min(K-this.pos,W-G);if(Z===K){const Y=createView$2(E);for(;K<=W-G;G+=K)this.process(Y,G);continue}H.set(E.subarray(G,G+Z),this.pos),this.pos+=Z,G+=Z,this.pos===K&&(this.process(U,0),this.pos=0)}return this.length+=E.length,this.roundClean(),this}digestInto(E){assert.exists(this),assert.output(E,this),this.finished=!0;const{buffer:U,view:H,blockLen:K,isLE:W}=this;let{pos:G}=this;U[G++]=128,this.buffer.subarray(G).fill(0),this.padOffset>K-G&&(this.process(H,0),G=0);for(let J=G;J<K;J++)U[J]=0;setBigUint64$2(H,K-8,BigInt(this.length*8),W),this.process(H,0);const Z=createView$2(E),Y=this.outputLen;if(Y%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const X=Y/4,Q=this.get();if(X>Q.length)throw new Error("_sha2: outputLen bigger than state");for(let J=0;J<X;J++)Z.setUint32(4*J,Q[J],W)}digest(){const{buffer:E,outputLen:U}=this;this.digestInto(E);const H=E.slice(0,U);return this.destroy(),H}_cloneInto(E){E||(E=new this.constructor),E.set(...this.get());const{blockLen:U,buffer:H,length:K,finished:W,destroyed:G,pos:Z}=this;return E.length=K,E.pos=Z,E.finished=W,E.destroyed=G,K%U&&E.buffer.set(H),E}}const Chi$2=(R,E,U)=>R&E^~R&U,Maj$2=(R,E,U)=>R&E^R&U^E&U,SHA256_K$2=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),IV=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),SHA256_W$2=new Uint32Array(64);let SHA256$2=class extends SHA2{constructor(){super(64,32,8,!1),this.A=IV[0]|0,this.B=IV[1]|0,this.C=IV[2]|0,this.D=IV[3]|0,this.E=IV[4]|0,this.F=IV[5]|0,this.G=IV[6]|0,this.H=IV[7]|0}get(){const{A:E,B:U,C:H,D:K,E:W,F:G,G:Z,H:Y}=this;return[E,U,H,K,W,G,Z,Y]}set(E,U,H,K,W,G,Z,Y){this.A=E|0,this.B=U|0,this.C=H|0,this.D=K|0,this.E=W|0,this.F=G|0,this.G=Z|0,this.H=Y|0}process(E,U){for(let J=0;J<16;J++,U+=4)SHA256_W$2[J]=E.getUint32(U,!1);for(let J=16;J<64;J++){const ne=SHA256_W$2[J-15],re=SHA256_W$2[J-2],ae=rotr$2(ne,7)^rotr$2(ne,18)^ne>>>3,te=rotr$2(re,17)^rotr$2(re,19)^re>>>10;SHA256_W$2[J]=te+SHA256_W$2[J-7]+ae+SHA256_W$2[J-16]|0}let{A:H,B:K,C:W,D:G,E:Z,F:Y,G:X,H:Q}=this;for(let J=0;J<64;J++){const ne=rotr$2(Z,6)^rotr$2(Z,11)^rotr$2(Z,25),re=Q+ne+Chi$2(Z,Y,X)+SHA256_K$2[J]+SHA256_W$2[J]|0,te=(rotr$2(H,2)^rotr$2(H,13)^rotr$2(H,22))+Maj$2(H,K,W)|0;Q=X,X=Y,Y=Z,Z=G+re|0,G=W,W=K,K=H,H=re+te|0}H=H+this.A|0,K=K+this.B|0,W=W+this.C|0,G=G+this.D|0,Z=Z+this.E|0,Y=Y+this.F|0,X=X+this.G|0,Q=Q+this.H|0,this.set(H,K,W,G,Z,Y,X,Q)}roundClean(){SHA256_W$2.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}};class SHA224 extends SHA256$2{constructor(){super(),this.A=-1056596264,this.B=914150663,this.C=812702999,this.D=-150054599,this.E=-4191439,this.F=1750603025,this.G=1694076839,this.H=-1090891868,this.outputLen=28}}const sha256$2=wrapConstructor$2(()=>new SHA256$2);wrapConstructor$2(()=>new SHA224);/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */function assertNumber(R){if(!Number.isSafeInteger(R))throw new Error(`Wrong integer: ${R}`)}function chain$1(...R){const E=(K,W)=>G=>K(W(G)),U=Array.from(R).reverse().reduce((K,W)=>K?E(K,W.encode):W.encode,void 0),H=R.reduce((K,W)=>K?E(K,W.decode):W.decode,void 0);return{encode:U,decode:H}}function alphabet$1(R){return{encode:E=>{if(!Array.isArray(E)||E.length&&typeof E[0]!="number")throw new Error("alphabet.encode input should be an array of numbers");return E.map(U=>{if(assertNumber(U),U<0||U>=R.length)throw new Error(`Digit index outside alphabet: ${U} (alphabet: ${R.length})`);return R[U]})},decode:E=>{if(!Array.isArray(E)||E.length&&typeof E[0]!="string")throw new Error("alphabet.decode input should be array of strings");return E.map(U=>{if(typeof U!="string")throw new Error(`alphabet.decode: not string element=${U}`);const H=R.indexOf(U);if(H===-1)throw new Error(`Unknown letter: "${U}". Allowed: ${R}`);return H})}}}function join$1(R=""){if(typeof R!="string")throw new Error("join separator should be string");return{encode:E=>{if(!Array.isArray(E)||E.length&&typeof E[0]!="string")throw new Error("join.encode input should be array of strings");for(let U of E)if(typeof U!="string")throw new Error(`join.encode: non-string input=${U}`);return E.join(R)},decode:E=>{if(typeof E!="string")throw new Error("join.decode input should be string");return E.split(R)}}}function padding(R,E="="){if(assertNumber(R),typeof E!="string")throw new Error("padding chr should be string");return{encode(U){if(!Array.isArray(U)||U.length&&typeof U[0]!="string")throw new Error("padding.encode input should be array of strings");for(let H of U)if(typeof H!="string")throw new Error(`padding.encode: non-string input=${H}`);for(;U.length*R%8;)U.push(E);return U},decode(U){if(!Array.isArray(U)||U.length&&typeof U[0]!="string")throw new Error("padding.encode input should be array of strings");for(let K of U)if(typeof K!="string")throw new Error(`padding.decode: non-string input=${K}`);let H=U.length;if(H*R%8)throw new Error("Invalid padding: string should have whole number of bytes");for(;H>0&&U[H-1]===E;H--)if(!((H-1)*R%8))throw new Error("Invalid padding: string has too much padding");return U.slice(0,H)}}}function normalize$1(R){if(typeof R!="function")throw new Error("normalize fn should be function");return{encode:E=>E,decode:E=>R(E)}}function convertRadix(R,E,U){if(E<2)throw new Error(`convertRadix: wrong from=${E}, base cannot be less than 2`);if(U<2)throw new Error(`convertRadix: wrong to=${U}, base cannot be less than 2`);if(!Array.isArray(R))throw new Error("convertRadix: data should be array");if(!R.length)return[];let H=0;const K=[],W=Array.from(R);for(W.forEach(G=>{if(assertNumber(G),G<0||G>=E)throw new Error(`Wrong integer: ${G}`)});;){let G=0,Z=!0;for(let Y=H;Y<W.length;Y++){const X=W[Y],Q=E*G+X;if(!Number.isSafeInteger(Q)||E*G/E!==G||Q-X!==E*G)throw new Error("convertRadix: carry overflow");if(G=Q%U,W[Y]=Math.floor(Q/U),!Number.isSafeInteger(W[Y])||W[Y]*U+G!==Q)throw new Error("convertRadix: carry overflow");if(Z)W[Y]?Z=!1:H=Y;else continue}if(K.push(G),Z)break}for(let G=0;G<R.length-1&&R[G]===0;G++)K.push(0);return K.reverse()}const gcd$1=(R,E)=>E?gcd$1(E,R%E):R,radix2carry$1=(R,E)=>R+(E-gcd$1(R,E));function convertRadix2$1(R,E,U,H){if(!Array.isArray(R))throw new Error("convertRadix2: data should be array");if(E<=0||E>32)throw new Error(`convertRadix2: wrong from=${E}`);if(U<=0||U>32)throw new Error(`convertRadix2: wrong to=${U}`);if(radix2carry$1(E,U)>32)throw new Error(`convertRadix2: carry overflow from=${E} to=${U} carryBits=${radix2carry$1(E,U)}`);let K=0,W=0;const G=2**U-1,Z=[];for(const Y of R){if(assertNumber(Y),Y>=2**E)throw new Error(`convertRadix2: invalid data word=${Y} from=${E}`);if(K=K<<E|Y,W+E>32)throw new Error(`convertRadix2: carry overflow pos=${W} from=${E}`);for(W+=E;W>=U;W-=U)Z.push((K>>W-U&G)>>>0);K&=2**W-1}if(K=K<<U-W&G,!H&&W>=E)throw new Error("Excess padding");if(!H&&K)throw new Error(`Non-zero padding: ${K}`);return H&&W>0&&Z.push(K>>>0),Z}function radix(R){return assertNumber(R),{encode:E=>{if(!(E instanceof Uint8Array))throw new Error("radix.encode input should be Uint8Array");return convertRadix(Array.from(E),2**8,R)},decode:E=>{if(!Array.isArray(E)||E.length&&typeof E[0]!="number")throw new Error("radix.decode input should be array of strings");return Uint8Array.from(convertRadix(E,R,2**8))}}}function radix2$1(R,E=!1){if(assertNumber(R),R<=0||R>32)throw new Error("radix2: bits should be in (0..32]");if(radix2carry$1(8,R)>32||radix2carry$1(R,8)>32)throw new Error("radix2: carry overflow");return{encode:U=>{if(!(U instanceof Uint8Array))throw new Error("radix2.encode input should be Uint8Array");return convertRadix2$1(Array.from(U),8,R,!E)},decode:U=>{if(!Array.isArray(U)||U.length&&typeof U[0]!="number")throw new Error("radix2.decode input should be array of strings");return Uint8Array.from(convertRadix2$1(U,R,8,E))}}}function unsafeWrapper$1(R){if(typeof R!="function")throw new Error("unsafeWrapper fn should be function");return function(...E){try{return R.apply(null,E)}catch{}}}const base16=chain$1(radix2$1(4),alphabet$1("0123456789ABCDEF"),join$1("")),base32=chain$1(radix2$1(5),alphabet$1("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"),padding(5),join$1(""));chain$1(radix2$1(5),alphabet$1("0123456789ABCDEFGHIJKLMNOPQRSTUV"),padding(5),join$1(""));chain$1(radix2$1(5),alphabet$1("0123456789ABCDEFGHJKMNPQRSTVWXYZ"),join$1(""),normalize$1(R=>R.toUpperCase().replace(/O/g,"0").replace(/[IL]/g,"1")));const base64=chain$1(radix2$1(6),alphabet$1("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"),padding(6),join$1("")),base64url=chain$1(radix2$1(6),alphabet$1("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"),padding(6),join$1("")),genBase58=R=>chain$1(radix(58),alphabet$1(R),join$1("")),base58=genBase58("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");genBase58("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ");genBase58("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");const XMR_BLOCK_LEN=[0,2,3,5,6,7,9,10,11],base58xmr={encode(R){let E="";for(let U=0;U<R.length;U+=8){const H=R.subarray(U,U+8);E+=base58.encode(H).padStart(XMR_BLOCK_LEN[H.length],"1")}return E},decode(R){let E=[];for(let U=0;U<R.length;U+=11){const H=R.slice(U,U+11),K=XMR_BLOCK_LEN.indexOf(H.length),W=base58.decode(H);for(let G=0;G<W.length-K;G++)if(W[G]!==0)throw new Error("base58xmr: wrong padding");E=E.concat(Array.from(W.slice(W.length-K)))}return Uint8Array.from(E)}},BECH_ALPHABET$1=chain$1(alphabet$1("qpzry9x8gf2tvdw0s3jn54khce6mua7l"),join$1("")),POLYMOD_GENERATORS$1=[996825010,642813549,513874426,1027748829,705979059];function bech32Polymod$1(R){const E=R>>25;let U=(R&33554431)<<5;for(let H=0;H<POLYMOD_GENERATORS$1.length;H++)(E>>H&1)===1&&(U^=POLYMOD_GENERATORS$1[H]);return U}function bechChecksum$1(R,E,U=1){const H=R.length;let K=1;for(let W=0;W<H;W++){const G=R.charCodeAt(W);if(G<33||G>126)throw new Error(`Invalid prefix (${R})`);K=bech32Polymod$1(K)^G>>5}K=bech32Polymod$1(K);for(let W=0;W<H;W++)K=bech32Polymod$1(K)^R.charCodeAt(W)&31;for(let W of E)K=bech32Polymod$1(K)^W;for(let W=0;W<6;W++)K=bech32Polymod$1(K);return K^=U,BECH_ALPHABET$1.encode(convertRadix2$1([K%2**30],30,5,!1))}function genBech32$1(R){const E=R==="bech32"?1:734539939,U=radix2$1(5),H=U.decode,K=U.encode,W=unsafeWrapper$1(H);function G(Q,J,ne=90){if(typeof Q!="string")throw new Error(`bech32.encode prefix should be string, not ${typeof Q}`);if(!Array.isArray(J)||J.length&&typeof J[0]!="number")throw new Error(`bech32.encode words should be array of numbers, not ${typeof J}`);const re=Q.length+7+J.length;if(ne!==!1&&re>ne)throw new TypeError(`Length ${re} exceeds limit ${ne}`);return Q=Q.toLowerCase(),`${Q}1${BECH_ALPHABET$1.encode(J)}${bechChecksum$1(Q,J,E)}`}function Z(Q,J=90){if(typeof Q!="string")throw new Error(`bech32.decode input should be string, not ${typeof Q}`);if(Q.length<8||J!==!1&&Q.length>J)throw new TypeError(`Wrong string length: ${Q.length} (${Q}). Expected (8..${J})`);const ne=Q.toLowerCase();if(Q!==ne&&Q!==Q.toUpperCase())throw new Error("String must be lowercase or uppercase");Q=ne;const re=Q.lastIndexOf("1");if(re===0||re===-1)throw new Error('Letter "1" must be present between prefix and data only');const ae=Q.slice(0,re),te=Q.slice(re+1);if(te.length<6)throw new Error("Data must be at least 6 characters long");const se=BECH_ALPHABET$1.decode(te).slice(0,-6),ie=bechChecksum$1(ae,se,E);if(!te.endsWith(ie))throw new Error(`Invalid checksum in ${Q}: expected "${ie}"`);return{prefix:ae,words:se}}const Y=unsafeWrapper$1(Z);function X(Q){const{prefix:J,words:ne}=Z(Q,!1);return{prefix:J,words:ne,bytes:H(ne)}}return{encode:G,decode:Z,decodeToBytes:X,decodeUnsafe:Y,fromWords:H,fromWordsUnsafe:W,toWords:K}}const bech32$1=genBech32$1("bech32");genBech32$1("bech32m");const utf8={encode:R=>new TextDecoder().decode(R),decode:R=>new TextEncoder().encode(R)},hex=chain$1(radix2$1(4),alphabet$1("0123456789abcdef"),join$1(""),normalize$1(R=>{if(typeof R!="string"||R.length%2)throw new TypeError(`hex.decode: expected string, got ${typeof R} with length ${R.length}`);return R.toLowerCase()})),CODERS={utf8,hex,base16,base32,base64,base64url,base58,base58xmr};`${Object.keys(CODERS).join(", ")}`;function number(R){if(!Number.isSafeInteger(R)||R<0)throw new Error(`positive integer expected, not ${R}`)}function bool(R){if(typeof R!="boolean")throw new Error(`boolean expected, not ${R}`)}function isBytes$4(R){return R instanceof Uint8Array||R!=null&&typeof R=="object"&&R.constructor.name==="Uint8Array"}function bytes(R,...E){if(!isBytes$4(R))throw new Error("Uint8Array expected");if(E.length>0&&!E.includes(R.length))throw new Error(`Uint8Array expected of length ${E}, not of length=${R.length}`)}/*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) */const u32=R=>new Uint32Array(R.buffer,R.byteOffset,Math.floor(R.byteLength/4)),isLE=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!isLE)throw new Error("Non little-endian hardware is not supported");function checkOpts(R,E){if(E==null||typeof E!="object")throw new Error("options must be defined");return Object.assign(R,E)}function equalBytes$1(R,E){if(R.length!==E.length)return!1;let U=0;for(let H=0;H<R.length;H++)U|=R[H]^E[H];return U===0}const wrapCipher=(R,E)=>(Object.assign(E,R),E),BLOCK_SIZE=16,POLY=283;function mul2(R){return R<<1^POLY&-(R>>7)}function mul(R,E){let U=0;for(;E>0;E>>=1)U^=R&-(E&1),R=mul2(R);return U}const sbox=(()=>{let R=new Uint8Array(256);for(let U=0,H=1;U<256;U++,H^=mul2(H))R[U]=H;const E=new Uint8Array(256);E[0]=99;for(let U=0;U<255;U++){let H=R[255-U];H|=H<<8,E[R[U]]=(H^H>>4^H>>5^H>>6^H>>7^99)&255}return E})(),invSbox=sbox.map((R,E)=>sbox.indexOf(E)),rotr32_8=R=>R<<24|R>>>8,rotl32_8=R=>R<<8|R>>>24;function genTtable(R,E){if(R.length!==256)throw new Error("Wrong sbox length");const U=new Uint32Array(256).map((X,Q)=>E(R[Q])),H=U.map(rotl32_8),K=H.map(rotl32_8),W=K.map(rotl32_8),G=new Uint32Array(256*256),Z=new Uint32Array(256*256),Y=new Uint16Array(256*256);for(let X=0;X<256;X++)for(let Q=0;Q<256;Q++){const J=X*256+Q;G[J]=U[X]^H[Q],Z[J]=K[X]^W[Q],Y[J]=R[X]<<8|R[Q]}return{sbox:R,sbox2:Y,T0:U,T1:H,T2:K,T3:W,T01:G,T23:Z}}const tableEncoding=genTtable(sbox,R=>mul(R,3)<<24|R<<16|R<<8|mul(R,2)),tableDecoding=genTtable(invSbox,R=>mul(R,11)<<24|mul(R,13)<<16|mul(R,9)<<8|mul(R,14)),xPowers=(()=>{const R=new Uint8Array(16);for(let E=0,U=1;E<16;E++,U=mul2(U))R[E]=U;return R})();function expandKeyLE(R){bytes(R);const E=R.length;if(![16,24,32].includes(E))throw new Error(`aes: wrong key size: should be 16, 24 or 32, got: ${E}`);const{sbox2:U}=tableEncoding,H=u32(R),K=H.length,W=Z=>applySbox(U,Z,Z,Z,Z),G=new Uint32Array(E+28);G.set(H);for(let Z=K;Z<G.length;Z++){let Y=G[Z-1];Z%K===0?Y=W(rotr32_8(Y))^xPowers[Z/K-1]:K>6&&Z%K===4&&(Y=W(Y)),G[Z]=G[Z-K]^Y}return G}function expandKeyDecLE(R){const E=expandKeyLE(R),U=E.slice(),H=E.length,{sbox2:K}=tableEncoding,{T0:W,T1:G,T2:Z,T3:Y}=tableDecoding;for(let X=0;X<H;X+=4)for(let Q=0;Q<4;Q++)U[X+Q]=E[H-X-4+Q];E.fill(0);for(let X=4;X<H-4;X++){const Q=U[X],J=applySbox(K,Q,Q,Q,Q);U[X]=W[J&255]^G[J>>>8&255]^Z[J>>>16&255]^Y[J>>>24]}return U}function apply0123(R,E,U,H,K,W){return R[U<<8&65280|H>>>8&255]^E[K>>>8&65280|W>>>24&255]}function applySbox(R,E,U,H,K){return R[E&255|U&65280]|R[H>>>16&255|K>>>16&65280]<<16}function encrypt$2(R,E,U,H,K){const{sbox2:W,T01:G,T23:Z}=tableEncoding;let Y=0;E^=R[Y++],U^=R[Y++],H^=R[Y++],K^=R[Y++];const X=R.length/4-2;for(let ae=0;ae<X;ae++){const te=R[Y++]^apply0123(G,Z,E,U,H,K),se=R[Y++]^apply0123(G,Z,U,H,K,E),ie=R[Y++]^apply0123(G,Z,H,K,E,U),ye=R[Y++]^apply0123(G,Z,K,E,U,H);E=te,U=se,H=ie,K=ye}const Q=R[Y++]^applySbox(W,E,U,H,K),J=R[Y++]^applySbox(W,U,H,K,E),ne=R[Y++]^applySbox(W,H,K,E,U),re=R[Y++]^applySbox(W,K,E,U,H);return{s0:Q,s1:J,s2:ne,s3:re}}function decrypt$2(R,E,U,H,K){const{sbox2:W,T01:G,T23:Z}=tableDecoding;let Y=0;E^=R[Y++],U^=R[Y++],H^=R[Y++],K^=R[Y++];const X=R.length/4-2;for(let ae=0;ae<X;ae++){const te=R[Y++]^apply0123(G,Z,E,K,H,U),se=R[Y++]^apply0123(G,Z,U,E,K,H),ie=R[Y++]^apply0123(G,Z,H,U,E,K),ye=R[Y++]^apply0123(G,Z,K,H,U,E);E=te,U=se,H=ie,K=ye}const Q=R[Y++]^applySbox(W,E,K,H,U),J=R[Y++]^applySbox(W,U,E,K,H),ne=R[Y++]^applySbox(W,H,U,E,K),re=R[Y++]^applySbox(W,K,H,U,E);return{s0:Q,s1:J,s2:ne,s3:re}}function getDst(R,E){if(!E)return new Uint8Array(R);if(bytes(E),E.length<R)throw new Error(`aes: wrong destination length, expected at least ${R}, got: ${E.length}`);return E}function validateBlockDecrypt(R){if(bytes(R),R.length%BLOCK_SIZE!==0)throw new Error(`aes/(cbc-ecb).decrypt ciphertext should consist of blocks with size ${BLOCK_SIZE}`)}function validateBlockEncrypt(R,E,U){let H=R.length;const K=H%BLOCK_SIZE;if(!E&&K!==0)throw new Error("aec/(cbc-ecb): unpadded plaintext with disabled padding");const W=u32(R);if(E){let Y=BLOCK_SIZE-K;Y||(Y=BLOCK_SIZE),H=H+Y}const G=getDst(H,U),Z=u32(G);return{b:W,o:Z,out:G}}function validatePCKS(R,E){if(!E)return R;const U=R.length;if(!U)throw new Error("aes/pcks5: empty ciphertext not allowed");const H=R[U-1];if(H<=0||H>16)throw new Error(`aes/pcks5: wrong padding byte: ${H}`);const K=R.subarray(0,-H);for(let W=0;W<H;W++)if(R[U-W-1]!==H)throw new Error("aes/pcks5: wrong padding");return K}function padPCKS(R){const E=new Uint8Array(16),U=u32(E);E.set(R);const H=BLOCK_SIZE-R.length;for(let K=BLOCK_SIZE-H;K<BLOCK_SIZE;K++)E[K]=H;return U}const cbc=wrapCipher({blockSize:16,nonceLength:16},function(E,U,H={}){bytes(E),bytes(U,16);const K=!H.disablePadding;return{encrypt:(W,G)=>{const Z=expandKeyLE(E),{b:Y,o:X,out:Q}=validateBlockEncrypt(W,K,G),J=u32(U);let ne=J[0],re=J[1],ae=J[2],te=J[3],se=0;for(;se+4<=Y.length;)ne^=Y[se+0],re^=Y[se+1],ae^=Y[se+2],te^=Y[se+3],{s0:ne,s1:re,s2:ae,s3:te}=encrypt$2(Z,ne,re,ae,te),X[se++]=ne,X[se++]=re,X[se++]=ae,X[se++]=te;if(K){const ie=padPCKS(W.subarray(se*4));ne^=ie[0],re^=ie[1],ae^=ie[2],te^=ie[3],{s0:ne,s1:re,s2:ae,s3:te}=encrypt$2(Z,ne,re,ae,te),X[se++]=ne,X[se++]=re,X[se++]=ae,X[se++]=te}return Z.fill(0),Q},decrypt:(W,G)=>{validateBlockDecrypt(W);const Z=expandKeyDecLE(E),Y=u32(U),X=getDst(W.length,G),Q=u32(W),J=u32(X);let ne=Y[0],re=Y[1],ae=Y[2],te=Y[3];for(let se=0;se+4<=Q.length;){const ie=ne,ye=re,me=ae,_e=te;ne=Q[se+0],re=Q[se+1],ae=Q[se+2],te=Q[se+3];const{s0:oe,s1:ue,s2:he,s3:we}=decrypt$2(Z,ne,re,ae,te);J[se++]=oe^ie,J[se++]=ue^ye,J[se++]=he^me,J[se++]=we^_e}return Z.fill(0),validatePCKS(X,K)}}}),_utf8ToBytes=R=>Uint8Array.from(R.split("").map(E=>E.charCodeAt(0))),sigma16=_utf8ToBytes("expand 16-byte k"),sigma32=_utf8ToBytes("expand 32-byte k"),sigma16_32=u32(sigma16),sigma32_32=u32(sigma32);sigma32_32.slice();function rotl(R,E){return R<<E|R>>>32-E}function isAligned32(R){return R.byteOffset%4===0}const BLOCK_LEN=64,BLOCK_LEN32=16,MAX_COUNTER=2**32-1,U32_EMPTY=new Uint32Array;function runCipher(R,E,U,H,K,W,G,Z){const Y=K.length,X=new Uint8Array(BLOCK_LEN),Q=u32(X),J=isAligned32(K)&&isAligned32(W),ne=J?u32(K):U32_EMPTY,re=J?u32(W):U32_EMPTY;for(let ae=0;ae<Y;G++){if(R(E,U,H,Q,G,Z),G>=MAX_COUNTER)throw new Error("arx: counter overflow");const te=Math.min(BLOCK_LEN,Y-ae);if(J&&te===BLOCK_LEN){const se=ae/4;if(ae%4!==0)throw new Error("arx: invalid block position");for(let ie=0,ye;ie<BLOCK_LEN32;ie++)ye=se+ie,re[ye]=ne[ye]^Q[ie];ae+=BLOCK_LEN;continue}for(let se=0,ie;se<te;se++)ie=ae+se,W[ie]=K[ie]^X[se];ae+=te}}function createCipher(R,E){const{allowShortKeys:U,extendNonceFn:H,counterLength:K,counterRight:W,rounds:G}=checkOpts({allowShortKeys:!1,counterLength:8,counterRight:!1,rounds:20},E);if(typeof R!="function")throw new Error("core must be a function");return number(K),number(G),bool(W),bool(U),(Z,Y,X,Q,J=0)=>{bytes(Z),bytes(Y),bytes(X);const ne=X.length;if(Q||(Q=new Uint8Array(ne)),bytes(Q),number(J),J<0||J>=MAX_COUNTER)throw new Error("arx: counter overflow");if(Q.length<ne)throw new Error(`arx: output (${Q.length}) is shorter than data (${ne})`);const re=[];let ae=Z.length,te,se;if(ae===32)te=Z.slice(),re.push(te),se=sigma32_32;else if(ae===16&&U)te=new Uint8Array(32),te.set(Z),te.set(Z,16),se=sigma16_32,re.push(te);else throw new Error(`arx: invalid 32-byte key, got length=${ae}`);isAligned32(Y)||(Y=Y.slice(),re.push(Y));const ie=u32(te);if(H){if(Y.length!==24)throw new Error("arx: extended nonce must be 24 bytes");H(se,ie,u32(Y.subarray(0,16)),ie),Y=Y.subarray(16)}const ye=16-K;if(ye!==Y.length)throw new Error(`arx: nonce must be ${ye} or 16 bytes`);if(ye!==12){const _e=new Uint8Array(12);_e.set(Y,W?0:12-Y.length),Y=_e,re.push(Y)}const me=u32(Y);for(runCipher(R,se,ie,me,X,Q,J,G);re.length>0;)re.pop().fill(0);return Q}}function chachaCore(R,E,U,H,K,W=20){let G=R[0],Z=R[1],Y=R[2],X=R[3],Q=E[0],J=E[1],ne=E[2],re=E[3],ae=E[4],te=E[5],se=E[6],ie=E[7],ye=K,me=U[0],_e=U[1],oe=U[2],ue=G,he=Z,we=Y,xe=X,ke=Q,ce=J,pe=ne,ve=re,Ee=ae,de=te,be=se,$e=ie,Ae=ye,Re=me,Ce=_e,Se=oe;for(let Ne=0;Ne<W;Ne+=2)ue=ue+ke|0,Ae=rotl(Ae^ue,16),Ee=Ee+Ae|0,ke=rotl(ke^Ee,12),ue=ue+ke|0,Ae=rotl(Ae^ue,8),Ee=Ee+Ae|0,ke=rotl(ke^Ee,7),he=he+ce|0,Re=rotl(Re^he,16),de=de+Re|0,ce=rotl(ce^de,12),he=he+ce|0,Re=rotl(Re^he,8),de=de+Re|0,ce=rotl(ce^de,7),we=we+pe|0,Ce=rotl(Ce^we,16),be=be+Ce|0,pe=rotl(pe^be,12),we=we+pe|0,Ce=rotl(Ce^we,8),be=be+Ce|0,pe=rotl(pe^be,7),xe=xe+ve|0,Se=rotl(Se^xe,16),$e=$e+Se|0,ve=rotl(ve^$e,12),xe=xe+ve|0,Se=rotl(Se^xe,8),$e=$e+Se|0,ve=rotl(ve^$e,7),ue=ue+ce|0,Se=rotl(Se^ue,16),be=be+Se|0,ce=rotl(ce^be,12),ue=ue+ce|0,Se=rotl(Se^ue,8),be=be+Se|0,ce=rotl(ce^be,7),he=he+pe|0,Ae=rotl(Ae^he,16),$e=$e+Ae|0,pe=rotl(pe^$e,12),he=he+pe|0,Ae=rotl(Ae^he,8),$e=$e+Ae|0,pe=rotl(pe^$e,7),we=we+ve|0,Re=rotl(Re^we,16),Ee=Ee+Re|0,ve=rotl(ve^Ee,12),we=we+ve|0,Re=rotl(Re^we,8),Ee=Ee+Re|0,ve=rotl(ve^Ee,7),xe=xe+ke|0,Ce=rotl(Ce^xe,16),de=de+Ce|0,ke=rotl(ke^de,12),xe=xe+ke|0,Ce=rotl(Ce^xe,8),de=de+Ce|0,ke=rotl(ke^de,7);let Te=0;H[Te++]=G+ue|0,H[Te++]=Z+he|0,H[Te++]=Y+we|0,H[Te++]=X+xe|0,H[Te++]=Q+ke|0,H[Te++]=J+ce|0,H[Te++]=ne+pe|0,H[Te++]=re+ve|0,H[Te++]=ae+Ee|0,H[Te++]=te+de|0,H[Te++]=se+be|0,H[Te++]=ie+$e|0,H[Te++]=ye+Ae|0,H[Te++]=me+Re|0,H[Te++]=_e+Ce|0,H[Te++]=oe+Se|0}const chacha20=createCipher(chachaCore,{counterRight:!1,counterLength:4,allowShortKeys:!1});let HMAC$1=class extends Hash$2{constructor(E,U){super(),this.finished=!1,this.destroyed=!1,assert.hash(E);const H=toBytes$2(U);if(this.iHash=E.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const K=this.blockLen,W=new Uint8Array(K);W.set(H.length>K?E.create().update(H).digest():H);for(let G=0;G<W.length;G++)W[G]^=54;this.iHash.update(W),this.oHash=E.create();for(let G=0;G<W.length;G++)W[G]^=106;this.oHash.update(W),W.fill(0)}update(E){return assert.exists(this),this.iHash.update(E),this}digestInto(E){assert.exists(this),assert.bytes(E,this.outputLen),this.finished=!0,this.iHash.digestInto(E),this.oHash.update(E),this.oHash.digestInto(E),this.destroy()}digest(){const E=new Uint8Array(this.oHash.outputLen);return this.digestInto(E),E}_cloneInto(E){E||(E=Object.create(Object.getPrototypeOf(this),{}));const{oHash:U,iHash:H,finished:K,destroyed:W,blockLen:G,outputLen:Z}=this;return E=E,E.finished=K,E.destroyed=W,E.blockLen=G,E.outputLen=Z,E.oHash=U._cloneInto(E.oHash),E.iHash=H._cloneInto(E.iHash),E}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}};const hmac$1=(R,E,U)=>new HMAC$1(R,E).update(U).digest();hmac$1.create=(R,E)=>new HMAC$1(R,E);function extract(R,E,U){return assert.hash(R),hmac$1(R,toBytes$2(U),toBytes$2(E))}const HKDF_COUNTER=new Uint8Array([0]),EMPTY_BUFFER=new Uint8Array;function expand(R,E,U,H=32){if(assert.hash(R),assert.number(H),H>255*R.outputLen)throw new Error("Length should be <= 255*HashLen");const K=Math.ceil(H/R.outputLen);U===void 0&&(U=EMPTY_BUFFER);const W=new Uint8Array(K*R.outputLen),G=hmac$1.create(R,E),Z=G._cloneInto(),Y=new Uint8Array(G.outputLen);for(let X=0;X<K;X++)HKDF_COUNTER[0]=X+1,Z.update(X===0?EMPTY_BUFFER:Y).update(U).update(HKDF_COUNTER).digestInto(Y),W.set(Y,R.outputLen*X),G._cloneInto(Z);return G.destroy(),Z.destroy(),Y.fill(0),HKDF_COUNTER.fill(0),W.slice(0,H)}var __defProp=Object.defineProperty,__export=(R,E)=>{for(var U in E)__defProp(R,U,{get:E[U],enumerable:!0})},verifiedSymbol=Symbol("verified"),isRecord=R=>R instanceof Object;function validateEvent(R){if(!isRecord(R)||typeof R.kind!="number"||typeof R.content!="string"||typeof R.created_at!="number"||typeof R.pubkey!="string"||!R.pubkey.match(/^[a-f0-9]{64}$/)||!Array.isArray(R.tags))return!1;for(let E=0;E<R.tags.length;E++){let U=R.tags[E];if(!Array.isArray(U))return!1;for(let H=0;H<U.length;H++)if(typeof U[H]=="object")return!1}return!0}var utils_exports={};__export(utils_exports,{Queue:()=>Queue$1,QueueNode:()=>QueueNode,binarySearch:()=>binarySearch,insertEventIntoAscendingList:()=>insertEventIntoAscendingList,insertEventIntoDescendingList:()=>insertEventIntoDescendingList,normalizeURL:()=>normalizeURL,utf8Decoder:()=>utf8Decoder,utf8Encoder:()=>utf8Encoder});var utf8Decoder=new TextDecoder("utf-8"),utf8Encoder=new TextEncoder;function normalizeURL(R){R.indexOf("://")===-1&&(R="wss://"+R);let E=new URL(R);return E.pathname=E.pathname.replace(/\/+/g,"/"),E.pathname.endsWith("/")&&(E.pathname=E.pathname.slice(0,-1)),(E.port==="80"&&E.protocol==="ws:"||E.port==="443"&&E.protocol==="wss:")&&(E.port=""),E.searchParams.sort(),E.hash="",E.toString()}function insertEventIntoDescendingList(R,E){const[U,H]=binarySearch(R,K=>E.id===K.id?0:E.created_at===K.created_at?-1:K.created_at-E.created_at);return H||R.splice(U,0,E),R}function insertEventIntoAscendingList(R,E){const[U,H]=binarySearch(R,K=>E.id===K.id?0:E.created_at===K.created_at?-1:E.created_at-K.created_at);return H||R.splice(U,0,E),R}function binarySearch(R,E){let U=0,H=R.length-1;for(;U<=H;){const K=Math.floor((U+H)/2),W=E(R[K]);if(W===0)return[K,!0];W<0?H=K-1:U=K+1}return[U,!1]}var QueueNode=class{constructor(R){le(this,"value");le(this,"next",null);le(this,"prev",null);this.value=R}},Queue$1=class{constructor(){le(this,"first");le(this,"last");this.first=null,this.last=null}enqueue(E){const U=new QueueNode(E);return this.last?this.last===this.first?(this.last=U,this.last.prev=this.first,this.first.next=U):(U.prev=this.last,this.last.next=U,this.last=U):(this.first=U,this.last=U),!0}dequeue(){if(!this.first)return null;if(this.first===this.last){const U=this.first;return this.first=null,this.last=null,U.value}const E=this.first;return this.first=E.next,E.value}},JS=class{generateSecretKey(){return schnorr$1.utils.randomPrivateKey()}getPublicKey(R){return bytesToHex$2(schnorr$1.getPublicKey(R))}finalizeEvent(R,E){const U=R;return U.pubkey=bytesToHex$2(schnorr$1.getPublicKey(E)),U.id=getEventHash$1(U),U.sig=bytesToHex$2(schnorr$1.sign(getEventHash$1(U),E)),U[verifiedSymbol]=!0,U}verifyEvent(R){if(typeof R[verifiedSymbol]=="boolean")return R[verifiedSymbol];const E=getEventHash$1(R);if(E!==R.id)return R[verifiedSymbol]=!1,!1;try{const U=schnorr$1.verify(R.sig,E,R.pubkey);return R[verifiedSymbol]=U,U}catch{return R[verifiedSymbol]=!1,!1}}};function serializeEvent(R){if(!validateEvent(R))throw new Error("can't serialize event with wrong or missing properties");return JSON.stringify([0,R.pubkey,R.created_at,R.kind,R.tags,R.content])}function getEventHash$1(R){let E=sha256$2(utf8Encoder.encode(serializeEvent(R)));return bytesToHex$2(E)}var i=new JS,generateSecretKey=i.generateSecretKey,getPublicKey=i.getPublicKey,finalizeEvent=i.finalizeEvent,verifyEvent=i.verifyEvent,kinds_exports={};__export(kinds_exports,{Application:()=>Application,BadgeAward:()=>BadgeAward,BadgeDefinition:()=>BadgeDefinition,BlockedRelaysList:()=>BlockedRelaysList,BookmarkList:()=>BookmarkList,Bookmarksets:()=>Bookmarksets,Calendar:()=>Calendar,CalendarEventRSVP:()=>CalendarEventRSVP,ChannelCreation:()=>ChannelCreation,ChannelHideMessage:()=>ChannelHideMessage,ChannelMessage:()=>ChannelMessage,ChannelMetadata:()=>ChannelMetadata,ChannelMuteUser:()=>ChannelMuteUser,ClassifiedListing:()=>ClassifiedListing,ClientAuth:()=>ClientAuth,CommunitiesList:()=>CommunitiesList,CommunityDefinition:()=>CommunityDefinition,CommunityPostApproval:()=>CommunityPostApproval,Contacts:()=>Contacts,CreateOrUpdateProduct:()=>CreateOrUpdateProduct,CreateOrUpdateStall:()=>CreateOrUpdateStall,Curationsets:()=>Curationsets,Date:()=>Date2,DirectMessageRelaysList:()=>DirectMessageRelaysList,DraftClassifiedListing:()=>DraftClassifiedListing,DraftLong:()=>DraftLong,Emojisets:()=>Emojisets,EncryptedDirectMessage:()=>EncryptedDirectMessage,EventDeletion:()=>EventDeletion,FileMetadata:()=>FileMetadata,FileServerPreference:()=>FileServerPreference,Followsets:()=>Followsets,GenericRepost:()=>GenericRepost,Genericlists:()=>Genericlists,GiftWrap:()=>GiftWrap,HTTPAuth:()=>HTTPAuth,Handlerinformation:()=>Handlerinformation,Handlerrecommendation:()=>Handlerrecommendation,Highlights:()=>Highlights,InterestsList:()=>InterestsList,Interestsets:()=>Interestsets,JobFeedback:()=>JobFeedback,JobRequest:()=>JobRequest,JobResult:()=>JobResult,Label:()=>Label,LightningPubRPC:()=>LightningPubRPC,LiveChatMessage:()=>LiveChatMessage,LiveEvent:()=>LiveEvent,LongFormArticle:()=>LongFormArticle,Metadata:()=>Metadata,Mutelist:()=>Mutelist,NWCWalletInfo:()=>NWCWalletInfo,NWCWalletRequest:()=>NWCWalletRequest,NWCWalletResponse:()=>NWCWalletResponse,NostrConnect:()=>NostrConnect,OpenTimestamps:()=>OpenTimestamps,Pinlist:()=>Pinlist,PrivateDirectMessage:()=>PrivateDirectMessage,ProblemTracker:()=>ProblemTracker,ProfileBadges:()=>ProfileBadges,PublicChatsList:()=>PublicChatsList,Reaction:()=>Reaction,RecommendRelay:()=>RecommendRelay,RelayList:()=>RelayList,Relaysets:()=>Relaysets,Report:()=>Report,Reporting:()=>Reporting,Repost:()=>Repost,Seal:()=>Seal,SearchRelaysList:()=>SearchRelaysList,ShortTextNote:()=>ShortTextNote,Time:()=>Time,UserEmojiList:()=>UserEmojiList,UserStatuses:()=>UserStatuses,Zap:()=>Zap,ZapGoal:()=>ZapGoal,ZapRequest:()=>ZapRequest,classifyKind:()=>classifyKind,isEphemeralKind:()=>isEphemeralKind,isKind:()=>isKind,isParameterizedReplaceableKind:()=>isParameterizedReplaceableKind,isRegularKind:()=>isRegularKind,isReplaceableKind:()=>isReplaceableKind});function isRegularKind(R){return 1e3<=R&&R<1e4||[1,2,4,5,6,7,8,16,40,41,42,43,44].includes(R)}function isReplaceableKind(R){return[0,3].includes(R)||1e4<=R&&R<2e4}function isEphemeralKind(R){return 2e4<=R&&R<3e4}function isParameterizedReplaceableKind(R){return 3e4<=R&&R<4e4}function classifyKind(R){return isRegularKind(R)?"regular":isReplaceableKind(R)?"replaceable":isEphemeralKind(R)?"ephemeral":isParameterizedReplaceableKind(R)?"parameterized":"unknown"}function isKind(R,E){const U=E instanceof Array?E:[E];return validateEvent(R)&&U.includes(R.kind)||!1}var Metadata=0,ShortTextNote=1,RecommendRelay=2,Contacts=3,EncryptedDirectMessage=4,EventDeletion=5,Repost=6,Reaction=7,BadgeAward=8,Seal=13,PrivateDirectMessage=14,GenericRepost=16,ChannelCreation=40,ChannelMetadata=41,ChannelMessage=42,ChannelHideMessage=43,ChannelMuteUser=44,OpenTimestamps=1040,GiftWrap=1059,FileMetadata=1063,LiveChatMessage=1311,ProblemTracker=1971,Report=1984,Reporting=1984,Label=1985,CommunityPostApproval=4550,JobRequest=5999,JobResult=6999,JobFeedback=7e3,ZapGoal=9041,ZapRequest=9734,Zap=9735,Highlights=9802,Mutelist=1e4,Pinlist=10001,RelayList=10002,BookmarkList=10003,CommunitiesList=10004,PublicChatsList=10005,BlockedRelaysList=10006,SearchRelaysList=10007,InterestsList=10015,UserEmojiList=10030,DirectMessageRelaysList=10050,FileServerPreference=10096,NWCWalletInfo=13194,LightningPubRPC=21e3,ClientAuth=22242,NWCWalletRequest=23194,NWCWalletResponse=23195,NostrConnect=24133,HTTPAuth=27235,Followsets=3e4,Genericlists=30001,Relaysets=30002,Bookmarksets=30003,Curationsets=30004,ProfileBadges=30008,BadgeDefinition=30009,Interestsets=30015,CreateOrUpdateStall=30017,CreateOrUpdateProduct=30018,LongFormArticle=30023,DraftLong=30024,Emojisets=30030,Application=30078,LiveEvent=30311,UserStatuses=30315,ClassifiedListing=30402,DraftClassifiedListing=30403,Date2=31922,Time=31923,Calendar=31924,CalendarEventRSVP=31925,Handlerrecommendation=31989,Handlerinformation=31990,CommunityDefinition=34550;function matchFilter(R,E){if(R.ids&&R.ids.indexOf(E.id)===-1||R.kinds&&R.kinds.indexOf(E.kind)===-1||R.authors&&R.authors.indexOf(E.pubkey)===-1)return!1;for(let U in R)if(U[0]==="#"){let H=U.slice(1),K=R[`#${H}`];if(K&&!E.tags.find(([W,G])=>W===U.slice(1)&&K.indexOf(G)!==-1))return!1}return!(R.since&&E.created_at<R.since||R.until&&E.created_at>R.until)}function matchFilters(R,E){for(let U=0;U<R.length;U++)if(matchFilter(R[U],E))return!0;return!1}var fakejson_exports={};__export(fakejson_exports,{getHex64:()=>getHex64,getInt:()=>getInt,getSubscriptionId:()=>getSubscriptionId,matchEventId:()=>matchEventId,matchEventKind:()=>matchEventKind,matchEventPubkey:()=>matchEventPubkey});function getHex64(R,E){let U=E.length+3,H=R.indexOf(`"${E}":`)+U,K=R.slice(H).indexOf('"')+H+1;return R.slice(K,K+64)}function getInt(R,E){let U=E.length,H=R.indexOf(`"${E}":`)+U+3,K=R.slice(H),W=Math.min(K.indexOf(","),K.indexOf("}"));return parseInt(K.slice(0,W),10)}function getSubscriptionId(R){let E=R.slice(0,22).indexOf('"EVENT"');if(E===-1)return null;let U=R.slice(E+7+1).indexOf('"');if(U===-1)return null;let H=E+7+1+U,K=R.slice(H+1,80).indexOf('"');if(K===-1)return null;let W=H+1+K;return R.slice(H+1,W)}function matchEventId(R,E){return E===getHex64(R,"id")}function matchEventPubkey(R,E){return E===getHex64(R,"pubkey")}function matchEventKind(R,E){return E===getInt(R,"kind")}var nip42_exports={};__export(nip42_exports,{makeAuthEvent:()=>makeAuthEvent});function makeAuthEvent(R,E){return{kind:ClientAuth,created_at:Math.floor(Date.now()/1e3),tags:[["relay",R],["challenge",E]],content:""}}var _WebSocket;try{_WebSocket=WebSocket}catch{}var _WebSocket2;try{_WebSocket2=WebSocket}catch{}var nip19_exports={};__export(nip19_exports,{BECH32_REGEX:()=>BECH32_REGEX$1,Bech32MaxSize:()=>Bech32MaxSize,NostrTypeGuard:()=>NostrTypeGuard,decode:()=>decode,encodeBytes:()=>encodeBytes,naddrEncode:()=>naddrEncode,neventEncode:()=>neventEncode,noteEncode:()=>noteEncode,nprofileEncode:()=>nprofileEncode,npubEncode:()=>npubEncode,nsecEncode:()=>nsecEncode});var NostrTypeGuard={isNProfile:R=>/^nprofile1[a-z\d]+$/.test(R||""),isNEvent:R=>/^nevent1[a-z\d]+$/.test(R||""),isNAddr:R=>/^naddr1[a-z\d]+$/.test(R||""),isNSec:R=>/^nsec1[a-z\d]{58}$/.test(R||""),isNPub:R=>/^npub1[a-z\d]{58}$/.test(R||""),isNote:R=>/^note1[a-z\d]+$/.test(R||""),isNcryptsec:R=>/^ncryptsec1[a-z\d]+$/.test(R||"")},Bech32MaxSize=5e3,BECH32_REGEX$1=/[\x21-\x7E]{1,83}1[023456789acdefghjklmnpqrstuvwxyz]{6,}/;function integerToUint8Array(R){const E=new Uint8Array(4);return E[0]=R>>24&255,E[1]=R>>16&255,E[2]=R>>8&255,E[3]=R&255,E}function decode(R){var K,W,G,Z,Y,X,Q;let{prefix:E,words:U}=bech32$1.decode(R,Bech32MaxSize),H=new Uint8Array(bech32$1.fromWords(U));switch(E){case"nprofile":{let J=parseTLV(H);if(!((K=J[0])!=null&&K[0]))throw new Error("missing TLV 0 for nprofile");if(J[0][0].length!==32)throw new Error("TLV 0 should be 32 bytes");return{type:"nprofile",data:{pubkey:bytesToHex$2(J[0][0]),relays:J[1]?J[1].map(ne=>utf8Decoder.decode(ne)):[]}}}case"nevent":{let J=parseTLV(H);if(!((W=J[0])!=null&&W[0]))throw new Error("missing TLV 0 for nevent");if(J[0][0].length!==32)throw new Error("TLV 0 should be 32 bytes");if(J[2]&&J[2][0].length!==32)throw new Error("TLV 2 should be 32 bytes");if(J[3]&&J[3][0].length!==4)throw new Error("TLV 3 should be 4 bytes");return{type:"nevent",data:{id:bytesToHex$2(J[0][0]),relays:J[1]?J[1].map(ne=>utf8Decoder.decode(ne)):[],author:(G=J[2])!=null&&G[0]?bytesToHex$2(J[2][0]):void 0,kind:(Z=J[3])!=null&&Z[0]?parseInt(bytesToHex$2(J[3][0]),16):void 0}}}case"naddr":{let J=parseTLV(H);if(!((Y=J[0])!=null&&Y[0]))throw new Error("missing TLV 0 for naddr");if(!((X=J[2])!=null&&X[0]))throw new Error("missing TLV 2 for naddr");if(J[2][0].length!==32)throw new Error("TLV 2 should be 32 bytes");if(!((Q=J[3])!=null&&Q[0]))throw new Error("missing TLV 3 for naddr");if(J[3][0].length!==4)throw new Error("TLV 3 should be 4 bytes");return{type:"naddr",data:{identifier:utf8Decoder.decode(J[0][0]),pubkey:bytesToHex$2(J[2][0]),kind:parseInt(bytesToHex$2(J[3][0]),16),relays:J[1]?J[1].map(ne=>utf8Decoder.decode(ne)):[]}}}case"nsec":return{type:E,data:H};case"npub":case"note":return{type:E,data:bytesToHex$2(H)};default:throw new Error(`unknown prefix ${E}`)}}function parseTLV(R){let E={},U=R;for(;U.length>0;){let H=U[0],K=U[1],W=U.slice(2,2+K);if(U=U.slice(2+K),W.length<K)throw new Error(`not enough data to read on TLV ${H}`);E[H]=E[H]||[],E[H].push(W)}return E}function nsecEncode(R){return encodeBytes("nsec",R)}function npubEncode(R){return encodeBytes("npub",hexToBytes$2(R))}function noteEncode(R){return encodeBytes("note",hexToBytes$2(R))}function encodeBech32(R,E){let U=bech32$1.toWords(E);return bech32$1.encode(R,U,Bech32MaxSize)}function encodeBytes(R,E){return encodeBech32(R,E)}function nprofileEncode(R){let E=encodeTLV({0:[hexToBytes$2(R.pubkey)],1:(R.relays||[]).map(U=>utf8Encoder.encode(U))});return encodeBech32("nprofile",E)}function neventEncode(R){let E;R.kind!==void 0&&(E=integerToUint8Array(R.kind));let U=encodeTLV({0:[hexToBytes$2(R.id)],1:(R.relays||[]).map(H=>utf8Encoder.encode(H)),2:R.author?[hexToBytes$2(R.author)]:[],3:E?[new Uint8Array(E)]:[]});return encodeBech32("nevent",U)}function naddrEncode(R){let E=new ArrayBuffer(4);new DataView(E).setUint32(0,R.kind,!1);let U=encodeTLV({0:[utf8Encoder.encode(R.identifier)],1:(R.relays||[]).map(H=>utf8Encoder.encode(H)),2:[hexToBytes$2(R.pubkey)],3:[new Uint8Array(E)]});return encodeBech32("naddr",U)}function encodeTLV(R){let E=[];return Object.entries(R).reverse().forEach(([U,H])=>{H.forEach(K=>{let W=new Uint8Array(K.length+2);W.set([parseInt(U)],0),W.set([K.length],1),W.set(K,2),E.push(W)})}),concatBytes$2(...E)}var nip04_exports={};__export(nip04_exports,{decrypt:()=>decrypt$1,encrypt:()=>encrypt$1});async function encrypt$1(R,E,U){const H=R instanceof Uint8Array?bytesToHex$2(R):R,K=secp256k1$1.getSharedSecret(H,"02"+E),W=getNormalizedX(K);let G=Uint8Array.from(randomBytes$1(16)),Z=utf8Encoder.encode(U),Y=cbc(W,G).encrypt(Z),X=base64.encode(new Uint8Array(Y)),Q=base64.encode(new Uint8Array(G.buffer));return`${X}?iv=${Q}`}async function decrypt$1(R,E,U){const H=R instanceof Uint8Array?bytesToHex$2(R):R;let[K,W]=U.split("?iv="),G=secp256k1$1.getSharedSecret(H,"02"+E),Z=getNormalizedX(G),Y=base64.decode(W),X=base64.decode(K),Q=cbc(Z,Y).decrypt(X);return utf8Decoder.decode(Q)}function getNormalizedX(R){return R.slice(1,33)}var nip05_exports={};__export(nip05_exports,{NIP05_REGEX:()=>NIP05_REGEX$1,isNip05:()=>isNip05,isValid:()=>isValid,queryProfile:()=>queryProfile,searchDomain:()=>searchDomain,useFetchImplementation:()=>useFetchImplementation});var NIP05_REGEX$1=/^(?:([\w.+-]+)@)?([\w_-]+(\.[\w_-]+)+)$/,isNip05=R=>NIP05_REGEX$1.test(R||""),_fetch;try{_fetch=fetch}catch{}function useFetchImplementation(R){_fetch=R}async function searchDomain(R,E=""){try{const U=`https://${R}/.well-known/nostr.json?name=${E}`,H=await _fetch(U,{redirect:"manual"});if(H.status!==200)throw Error("Wrong response code");return(await H.json()).names}catch{return{}}}async function queryProfile(R){var K;const E=R.match(NIP05_REGEX$1);if(!E)return null;const[,U="_",H]=E;try{const W=`https://${H}/.well-known/nostr.json?name=${U}`,G=await _fetch(W,{redirect:"manual"});if(G.status!==200)throw Error("Wrong response code");const Z=await G.json(),Y=Z.names[U];return Y?{pubkey:Y,relays:(K=Z.relays)==null?void 0:K[Y]}:null}catch{return null}}async function isValid(R,E){const U=await queryProfile(E);return U?U.pubkey===R:!1}var nip10_exports={};__export(nip10_exports,{parse:()=>parse});function parse(R){const E={reply:void 0,root:void 0,mentions:[],profiles:[],quotes:[]};let U,H;for(let K=R.tags.length-1;K>=0;K--){const W=R.tags[K];if(W[0]==="e"&&W[1]){const[G,Z,Y,X,Q]=W,J={id:Z,relays:Y?[Y]:[],author:Q};if(X==="root"){E.root=J;continue}if(X==="reply"){E.reply=J;continue}if(X==="mention"){E.mentions.push(J);continue}U?H=J:U=J,E.mentions.push(J);continue}if(W[0]==="q"&&W[1]){const[G,Z,Y]=W;E.quotes.push({id:Z,relays:Y?[Y]:[]})}if(W[0]==="p"&&W[1]){E.profiles.push({pubkey:W[1],relays:W[2]?[W[2]]:[]});continue}}return E.root||(E.root=H||U||E.reply),E.reply||(E.reply=U||E.root),[E.reply,E.root].forEach(K=>{if(!K)return;let W=E.mentions.indexOf(K);if(W!==-1&&E.mentions.splice(W,1),K.author){let G=E.profiles.find(Z=>Z.pubkey===K.author);G&&G.relays&&(K.relays||(K.relays=[]),G.relays.forEach(Z=>{var Y;((Y=K.relays)==null?void 0:Y.indexOf(Z))===-1&&K.relays.push(Z)}),G.relays=K.relays)}}),E.mentions.forEach(K=>{if(K.author){let W=E.profiles.find(G=>G.pubkey===K.author);W&&W.relays&&(K.relays||(K.relays=[]),W.relays.forEach(G=>{K.relays.indexOf(G)===-1&&K.relays.push(G)}),W.relays=K.relays)}}),E}var nip11_exports={};__export(nip11_exports,{fetchRelayInformation:()=>fetchRelayInformation,useFetchImplementation:()=>useFetchImplementation2});var _fetch2;try{_fetch2=fetch}catch{}function useFetchImplementation2(R){_fetch2=R}async function fetchRelayInformation(R){return await(await fetch(R.replace("ws://","http://").replace("wss://","https://"),{headers:{Accept:"application/nostr+json"}})).json()}var nip13_exports={};__export(nip13_exports,{fastEventHash:()=>fastEventHash,getPow:()=>getPow,minePow:()=>minePow});function getPow(R){let E=0;for(let U=0;U<64;U+=8){const H=parseInt(R.substring(U,U+8),16);if(H===0)E+=32;else{E+=Math.clz32(H);break}}return E}function minePow(R,E){let U=0;const H=R,K=["nonce",U.toString(),E.toString()];for(H.tags.push(K);;){const W=Math.floor(new Date().getTime()/1e3);if(W!==H.created_at&&(U=0,H.created_at=W),K[1]=(++U).toString(),H.id=fastEventHash(H),getPow(H.id)>=E)break}return H}function fastEventHash(R){return bytesToHex$2(sha256$2(utf8Encoder.encode(JSON.stringify([0,R.pubkey,R.created_at,R.kind,R.tags,R.content]))))}var nip18_exports={};__export(nip18_exports,{finishRepostEvent:()=>finishRepostEvent,getRepostedEvent:()=>getRepostedEvent,getRepostedEventPointer:()=>getRepostedEventPointer});function finishRepostEvent(R,E,U,H){return finalizeEvent({kind:Repost,tags:[...R.tags??[],["e",E.id,U],["p",E.pubkey]],content:R.content===""?"":JSON.stringify(E),created_at:R.created_at},H)}function getRepostedEventPointer(R){if(R.kind!==Repost)return;let E,U;for(let H=R.tags.length-1;H>=0&&(E===void 0||U===void 0);H--){const K=R.tags[H];K.length>=2&&(K[0]==="e"&&E===void 0?E=K:K[0]==="p"&&U===void 0&&(U=K))}if(E!==void 0)return{id:E[1],relays:[E[2],U==null?void 0:U[2]].filter(H=>typeof H=="string"),author:U==null?void 0:U[1]}}function getRepostedEvent(R,{skipVerification:E}={}){const U=getRepostedEventPointer(R);if(U===void 0||R.content==="")return;let H;try{H=JSON.parse(R.content)}catch{return}if(H.id===U.id&&!(!E&&!verifyEvent(H)))return H}var nip21_exports={};__export(nip21_exports,{NOSTR_URI_REGEX:()=>NOSTR_URI_REGEX,parse:()=>parse2,test:()=>test});var NOSTR_URI_REGEX=new RegExp(`nostr:(${BECH32_REGEX$1.source})`);function test(R){return typeof R=="string"&&new RegExp(`^${NOSTR_URI_REGEX.source}$`).test(R)}function parse2(R){const E=R.match(new RegExp(`^${NOSTR_URI_REGEX.source}$`));if(!E)throw new Error(`Invalid Nostr URI: ${R}`);return{uri:E[0],value:E[1],decoded:decode(E[1])}}var nip25_exports={};__export(nip25_exports,{finishReactionEvent:()=>finishReactionEvent,getReactedEventPointer:()=>getReactedEventPointer});function finishReactionEvent(R,E,U){const H=E.tags.filter(K=>K.length>=2&&(K[0]==="e"||K[0]==="p"));return finalizeEvent({...R,kind:Reaction,tags:[...R.tags??[],...H,["e",E.id],["p",E.pubkey]],content:R.content??"+"},U)}function getReactedEventPointer(R){if(R.kind!==Reaction)return;let E,U;for(let H=R.tags.length-1;H>=0&&(E===void 0||U===void 0);H--){const K=R.tags[H];K.length>=2&&(K[0]==="e"&&E===void 0?E=K:K[0]==="p"&&U===void 0&&(U=K))}if(!(E===void 0||U===void 0))return{id:E[1],relays:[E[2],U[2]].filter(H=>H!==void 0),author:U[1]}}var nip27_exports={};__export(nip27_exports,{matchAll:()=>matchAll,regex:()=>regex,replaceAll:()=>replaceAll});var regex=()=>new RegExp(`\\b${NOSTR_URI_REGEX.source}\\b`,"g");function*matchAll(R){const E=R.matchAll(regex());for(const U of E)try{const[H,K]=U;yield{uri:H,value:K,decoded:decode(K),start:U.index,end:U.index+H.length}}catch{}}function replaceAll(R,E){return R.replaceAll(regex(),(U,H)=>E({uri:U,value:H,decoded:decode(H)}))}var nip28_exports={};__export(nip28_exports,{channelCreateEvent:()=>channelCreateEvent,channelHideMessageEvent:()=>channelHideMessageEvent,channelMessageEvent:()=>channelMessageEvent,channelMetadataEvent:()=>channelMetadataEvent,channelMuteUserEvent:()=>channelMuteUserEvent});var channelCreateEvent=(R,E)=>{let U;if(typeof R.content=="object")U=JSON.stringify(R.content);else if(typeof R.content=="string")U=R.content;else return;return finalizeEvent({kind:ChannelCreation,tags:[...R.tags??[]],content:U,created_at:R.created_at},E)},channelMetadataEvent=(R,E)=>{let U;if(typeof R.content=="object")U=JSON.stringify(R.content);else if(typeof R.content=="string")U=R.content;else return;return finalizeEvent({kind:ChannelMetadata,tags:[["e",R.channel_create_event_id],...R.tags??[]],content:U,created_at:R.created_at},E)},channelMessageEvent=(R,E)=>{const U=[["e",R.channel_create_event_id,R.relay_url,"root"]];return R.reply_to_channel_message_event_id&&U.push(["e",R.reply_to_channel_message_event_id,R.relay_url,"reply"]),finalizeEvent({kind:ChannelMessage,tags:[...U,...R.tags??[]],content:R.content,created_at:R.created_at},E)},channelHideMessageEvent=(R,E)=>{let U;if(typeof R.content=="object")U=JSON.stringify(R.content);else if(typeof R.content=="string")U=R.content;else return;return finalizeEvent({kind:ChannelHideMessage,tags:[["e",R.channel_message_event_id],...R.tags??[]],content:U,created_at:R.created_at},E)},channelMuteUserEvent=(R,E)=>{let U;if(typeof R.content=="object")U=JSON.stringify(R.content);else if(typeof R.content=="string")U=R.content;else return;return finalizeEvent({kind:ChannelMuteUser,tags:[["p",R.pubkey_to_mute],...R.tags??[]],content:U,created_at:R.created_at},E)},nip30_exports={};__export(nip30_exports,{EMOJI_SHORTCODE_REGEX:()=>EMOJI_SHORTCODE_REGEX,matchAll:()=>matchAll2,regex:()=>regex2,replaceAll:()=>replaceAll2});var EMOJI_SHORTCODE_REGEX=/:(\w+):/,regex2=()=>new RegExp(`\\B${EMOJI_SHORTCODE_REGEX.source}\\B`,"g");function*matchAll2(R){const E=R.matchAll(regex2());for(const U of E)try{const[H,K]=U;yield{shortcode:H,name:K,start:U.index,end:U.index+H.length}}catch{}}function replaceAll2(R,E){return R.replaceAll(regex2(),(U,H)=>E({shortcode:U,name:H}))}var nip39_exports={};__export(nip39_exports,{useFetchImplementation:()=>useFetchImplementation3,validateGithub:()=>validateGithub});var _fetch3;try{_fetch3=fetch}catch{}function useFetchImplementation3(R){_fetch3=R}async function validateGithub(R,E,U){try{return await(await _fetch3(`https://gist.github.com/${E}/${U}/raw`)).text()===`Verifying that I control the following Nostr public key: ${R}`}catch{return!1}}var nip44_exports={};__export(nip44_exports,{decrypt:()=>decrypt2,encrypt:()=>encrypt2,getConversationKey:()=>getConversationKey,v2:()=>v2});var minPlaintextSize=1,maxPlaintextSize=65535;function getConversationKey(R,E){const U=secp256k1$1.getSharedSecret(R,"02"+E).subarray(1,33);return extract(sha256$2,U,"nip44-v2")}function getMessageKeys(R,E){const U=expand(sha256$2,R,E,76);return{chacha_key:U.subarray(0,32),chacha_nonce:U.subarray(32,44),hmac_key:U.subarray(44,76)}}function calcPaddedLen(R){if(!Number.isSafeInteger(R)||R<1)throw new Error("expected positive integer");if(R<=32)return 32;const E=1<<Math.floor(Math.log2(R-1))+1,U=E<=256?32:E/8;return U*(Math.floor((R-1)/U)+1)}function writeU16BE(R){if(!Number.isSafeInteger(R)||R<minPlaintextSize||R>maxPlaintextSize)throw new Error("invalid plaintext size: must be between 1 and 65535 bytes");const E=new Uint8Array(2);return new DataView(E.buffer).setUint16(0,R,!1),E}function pad(R){const E=utf8Encoder.encode(R),U=E.length,H=writeU16BE(U),K=new Uint8Array(calcPaddedLen(U)-U);return concatBytes$2(H,E,K)}function unpad(R){const E=new DataView(R.buffer).getUint16(0),U=R.subarray(2,2+E);if(E<minPlaintextSize||E>maxPlaintextSize||U.length!==E||R.length!==2+calcPaddedLen(E))throw new Error("invalid padding");return utf8Decoder.decode(U)}function hmacAad(R,E,U){if(U.length!==32)throw new Error("AAD associated data must be 32 bytes");const H=concatBytes$2(U,E);return hmac$1(sha256$2,R,H)}function decodePayload(R){if(typeof R!="string")throw new Error("payload must be a valid string");const E=R.length;if(E<132||E>87472)throw new Error("invalid payload length: "+E);if(R[0]==="#")throw new Error("unknown encryption version");let U;try{U=base64.decode(R)}catch(W){throw new Error("invalid base64: "+W.message)}const H=U.length;if(H<99||H>65603)throw new Error("invalid data length: "+H);const K=U[0];if(K!==2)throw new Error("unknown encryption version "+K);return{nonce:U.subarray(1,33),ciphertext:U.subarray(33,-32),mac:U.subarray(-32)}}function encrypt2(R,E,U=randomBytes$1(32)){const{chacha_key:H,chacha_nonce:K,hmac_key:W}=getMessageKeys(E,U),G=pad(R),Z=chacha20(H,K,G),Y=hmacAad(W,Z,U);return base64.encode(concatBytes$2(new Uint8Array([2]),U,Z,Y))}function decrypt2(R,E){const{nonce:U,ciphertext:H,mac:K}=decodePayload(R),{chacha_key:W,chacha_nonce:G,hmac_key:Z}=getMessageKeys(E,U),Y=hmacAad(Z,H,U);if(!equalBytes$1(Y,K))throw new Error("invalid MAC");const X=chacha20(W,G,H);return unpad(X)}var v2={utils:{getConversationKey,calcPaddedLen},encrypt:encrypt2,decrypt:decrypt2},nip47_exports={};__export(nip47_exports,{makeNwcRequestEvent:()=>makeNwcRequestEvent,parseConnectionString:()=>parseConnectionString});function parseConnectionString(R){const{pathname:E,searchParams:U}=new URL(R),H=E,K=U.get("relay"),W=U.get("secret");if(!H||!K||!W)throw new Error("invalid connection string");return{pubkey:H,relay:K,secret:W}}async function makeNwcRequestEvent(R,E,U){const K=await encrypt$1(E,R,JSON.stringify({method:"pay_invoice",params:{invoice:U}})),W={kind:NWCWalletRequest,created_at:Math.round(Date.now()/1e3),content:K,tags:[["p",R]]};return finalizeEvent(W,E)}var nip57_exports={};__export(nip57_exports,{getZapEndpoint:()=>getZapEndpoint,makeZapReceipt:()=>makeZapReceipt,makeZapRequest:()=>makeZapRequest,useFetchImplementation:()=>useFetchImplementation4,validateZapRequest:()=>validateZapRequest});var _fetch4;try{_fetch4=fetch}catch{}function useFetchImplementation4(R){_fetch4=R}async function getZapEndpoint(R){try{let E="",{lud06:U,lud16:H}=JSON.parse(R.content);if(U){let{words:G}=bech32$1.decode(U,1e3),Z=bech32$1.fromWords(G);E=utf8Decoder.decode(Z)}else if(H){let[G,Z]=H.split("@");E=new URL(`/.well-known/lnurlp/${G}`,`https://${Z}`).toString()}else return null;let W=await(await _fetch4(E)).json();if(W.allowsNostr&&W.nostrPubkey)return W.callback}catch{}return null}function makeZapRequest({profile:R,event:E,amount:U,relays:H,comment:K=""}){if(!U)throw new Error("amount not given");if(!R)throw new Error("profile not given");let W={kind:9734,created_at:Math.round(Date.now()/1e3),content:K,tags:[["p",R],["amount",U.toString()],["relays",...H]]};return E&&W.tags.push(["e",E]),W}function validateZapRequest(R){let E;try{E=JSON.parse(R)}catch{return"Invalid zap request JSON."}if(!validateEvent(E))return"Zap request is not a valid Nostr event.";if(!verifyEvent(E))return"Invalid signature on zap request.";let U=E.tags.find(([W,G])=>W==="p"&&G);if(!U)return"Zap request doesn't have a 'p' tag.";if(!U[1].match(/^[a-f0-9]{64}$/))return"Zap request 'p' tag is not valid hex.";let H=E.tags.find(([W,G])=>W==="e"&&G);return H&&!H[1].match(/^[a-f0-9]{64}$/)?"Zap request 'e' tag is not valid hex.":E.tags.find(([W,G])=>W==="relays"&&G)?null:"Zap request doesn't have a 'relays' tag."}function makeZapReceipt({zapRequest:R,preimage:E,bolt11:U,paidAt:H}){let K=JSON.parse(R),W=K.tags.filter(([Z])=>Z==="e"||Z==="p"||Z==="a"),G={kind:9735,created_at:Math.round(H.getTime()/1e3),content:"",tags:[...W,["P",K.pubkey],["bolt11",U],["description",R]]};return E&&G.tags.push(["preimage",E]),G}var nip59_exports={};__export(nip59_exports,{createRumor:()=>createRumor,createSeal:()=>createSeal,createWrap:()=>createWrap,unwrapEvent:()=>unwrapEvent,unwrapManyEvents:()=>unwrapManyEvents,wrapEvent:()=>wrapEvent,wrapManyEvents:()=>wrapManyEvents});var TWO_DAYS=2*24*60*60,now=()=>Math.round(Date.now()/1e3),randomNow=()=>Math.round(now()-Math.random()*TWO_DAYS),nip44ConversationKey=(R,E)=>getConversationKey(R,E),nip44Encrypt=(R,E,U)=>encrypt2(JSON.stringify(R),nip44ConversationKey(E,U)),nip44Decrypt=(R,E)=>JSON.parse(decrypt2(R.content,nip44ConversationKey(E,R.pubkey)));function createRumor(R,E){const U={created_at:now(),content:"",tags:[],...R,pubkey:getPublicKey(E)};return U.id=getEventHash$1(U),U}function createSeal(R,E,U){return finalizeEvent({kind:Seal,content:nip44Encrypt(R,E,U),created_at:randomNow(),tags:[]},E)}function createWrap(R,E){const U=generateSecretKey();return finalizeEvent({kind:GiftWrap,content:nip44Encrypt(R,U,E),created_at:randomNow(),tags:[["p",E]]},U)}function wrapEvent(R,E,U){const H=createRumor(R,E),K=createSeal(H,E,U);return createWrap(K,U)}function wrapManyEvents(R,E,U){if(!U||U.length===0)throw new Error("At least one recipient is required.");const H=getPublicKey(E),K=[wrapEvent(R,E,H)];return U.forEach(W=>{K.push(wrapEvent(R,E,W))}),K}function unwrapEvent(R,E){const U=nip44Decrypt(R,E);return nip44Decrypt(U,E)}function unwrapManyEvents(R,E){let U=[];return R.forEach(H=>{U.push(unwrapEvent(H,E))}),U.sort((H,K)=>H.created_at-K.created_at),U}var nip98_exports={};__export(nip98_exports,{getToken:()=>getToken,hashPayload:()=>hashPayload,unpackEventFromToken:()=>unpackEventFromToken,validateEvent:()=>validateEvent2,validateEventKind:()=>validateEventKind,validateEventMethodTag:()=>validateEventMethodTag,validateEventPayloadTag:()=>validateEventPayloadTag,validateEventTimestamp:()=>validateEventTimestamp,validateEventUrlTag:()=>validateEventUrlTag,validateToken:()=>validateToken});var _authorizationScheme="Nostr ";async function getToken(R,E,U,H=!1,K){const W={kind:HTTPAuth,tags:[["u",R],["method",E]],created_at:Math.round(new Date().getTime()/1e3),content:""};K&&W.tags.push(["payload",hashPayload(K)]);const G=await U(W);return(H?_authorizationScheme:"")+base64.encode(utf8Encoder.encode(JSON.stringify(G)))}async function validateToken(R,E,U){const H=await unpackEventFromToken(R).catch(W=>{throw W});return await validateEvent2(H,E,U).catch(W=>{throw W})}async function unpackEventFromToken(R){if(!R)throw new Error("Missing token");R=R.replace(_authorizationScheme,"");const E=utf8Decoder.decode(base64.decode(R));if(!E||E.length===0||!E.startsWith("{"))throw new Error("Invalid token");return JSON.parse(E)}function validateEventTimestamp(R){return R.created_at?Math.round(new Date().getTime()/1e3)-R.created_at<60:!1}function validateEventKind(R){return R.kind===HTTPAuth}function validateEventUrlTag(R,E){const U=R.tags.find(H=>H[0]==="u");return U?U.length>0&&U[1]===E:!1}function validateEventMethodTag(R,E){const U=R.tags.find(H=>H[0]==="method");return U?U.length>0&&U[1].toLowerCase()===E.toLowerCase():!1}function hashPayload(R){const E=sha256$2(utf8Encoder.encode(JSON.stringify(R)));return bytesToHex$2(E)}function validateEventPayloadTag(R,E){const U=R.tags.find(K=>K[0]==="payload");if(!U)return!1;const H=hashPayload(E);return U.length>0&&U[1]===H}async function validateEvent2(R,E,U,H){if(!verifyEvent(R))throw new Error("Invalid nostr event, signature invalid");if(!validateEventKind(R))throw new Error("Invalid nostr event, kind invalid");if(!validateEventTimestamp(R))throw new Error("Invalid nostr event, created_at timestamp invalid");if(!validateEventUrlTag(R,E))throw new Error("Invalid nostr event, url tag invalid");if(!validateEventMethodTag(R,U))throw new Error("Invalid nostr event, method tag invalid");if(H&&typeof H=="object"&&Object.keys(H).length>0&&!validateEventPayloadTag(R,H))throw new Error("Invalid nostr event, payload tag does not match request body hash");return!0}function getDefaultExportFromCjs(R){return R&&R.__esModule&&Object.prototype.hasOwnProperty.call(R,"default")?R.default:R}var lib$1={},types={},hasRequiredTypes;function requireTypes(){return hasRequiredTypes||(hasRequiredTypes=1,Object.defineProperty(types,"__esModule",{value:!0})),types}var ee={},taskCollection$1={},taskCollection={},utils$1={},hasRequiredUtils$1;function requireUtils$1(){if(hasRequiredUtils$1)return utils$1;hasRequiredUtils$1=1,Object.defineProperty(utils$1,"__esModule",{value:!0}),utils$1._fast_remove_single=void 0;function R(E,U){U!==-1&&(U===0?E.shift():U===E.length-1?E.length=E.length-1:E.splice(U,1))}return utils$1._fast_remove_single=R,utils$1}var bakeCollection={},hasRequiredBakeCollection;function requireBakeCollection(){return hasRequiredBakeCollection||(hasRequiredBakeCollection=1,function(exports){Object.defineProperty(exports,"__esModule",{value:!0}),exports.bakeCollectionVariadic=exports.bakeCollectionAwait=exports.bakeCollection=exports.BAKED_EMPTY_FUNC=void 0,exports.BAKED_EMPTY_FUNC=function(){};var FORLOOP_FALLBACK=1500;function generateArgsDefCode(R){var E="";if(R===0)return E;for(var U=0;U<R-1;++U)E+="arg"+String(U)+", ";return E+="arg"+String(R-1),E}function generateBodyPartsCode(R,E){for(var U="",H="",K=0;K<E;++K)U+="var f".concat(K," = collection[").concat(K,`];
`),H+="f".concat(K,"(").concat(R,`)
`);return{funcDefCode:U,funcCallCode:H}}function generateBodyPartsVariadicCode(R){for(var E="",U="",H=0;H<R;++H)E+="var f".concat(H," = collection[").concat(H,`];
`),U+="f".concat(H,`.apply(undefined, arguments)
`);return{funcDefCode:E,funcCallCode:U}}function bakeCollection(collection,fixedArgsNum){if(collection.length===0)return exports.BAKED_EMPTY_FUNC;if(collection.length===1)return collection[0];var funcFactoryCode;if(collection.length<FORLOOP_FALLBACK){var argsDefCode=generateArgsDefCode(fixedArgsNum),_a=generateBodyPartsCode(argsDefCode,collection.length),funcDefCode=_a.funcDefCode,funcCallCode=_a.funcCallCode;funcFactoryCode=`(function(collection) {
            `.concat(funcDefCode,`
            collection = undefined;
            return (function(`).concat(argsDefCode,`) {
                `).concat(funcCallCode,`
            });
        })`)}else{var argsDefCode=generateArgsDefCode(fixedArgsNum);collection.length%10===0?funcFactoryCode=`(function(collection) {
                return (function(`.concat(argsDefCode,`) {
                    for (var i = 0; i < collection.length; i += 10) {
                        collection[i](`).concat(argsDefCode,`);
                        collection[i+1](`).concat(argsDefCode,`);
                        collection[i+2](`).concat(argsDefCode,`);
                        collection[i+3](`).concat(argsDefCode,`);
                        collection[i+4](`).concat(argsDefCode,`);
                        collection[i+5](`).concat(argsDefCode,`);
                        collection[i+6](`).concat(argsDefCode,`);
                        collection[i+7](`).concat(argsDefCode,`);
                        collection[i+8](`).concat(argsDefCode,`);
                        collection[i+9](`).concat(argsDefCode,`);
                    }
                });
            })`):collection.length%4===0?funcFactoryCode=`(function(collection) {
                return (function(`.concat(argsDefCode,`) {
                    for (var i = 0; i < collection.length; i += 4) {
                        collection[i](`).concat(argsDefCode,`);
                        collection[i+1](`).concat(argsDefCode,`);
                        collection[i+2](`).concat(argsDefCode,`);
                        collection[i+3](`).concat(argsDefCode,`);
                    }
                });
            })`):collection.length%3===0?funcFactoryCode=`(function(collection) {
                return (function(`.concat(argsDefCode,`) {
                    for (var i = 0; i < collection.length; i += 3) {
                        collection[i](`).concat(argsDefCode,`);
                        collection[i+1](`).concat(argsDefCode,`);
                        collection[i+2](`).concat(argsDefCode,`);
                    }
                });
            })`):funcFactoryCode=`(function(collection) {
                return (function(`.concat(argsDefCode,`) {
                    for (var i = 0; i < collection.length; ++i) {
                        collection[i](`).concat(argsDefCode,`);
                    }
                });
            })`)}{var funcFactory=eval(funcFactoryCode);return funcFactory(collection)}}exports.bakeCollection=bakeCollection;function bakeCollectionAwait(collection,fixedArgsNum){if(collection.length===0)return exports.BAKED_EMPTY_FUNC;if(collection.length===1)return collection[0];var funcFactoryCode;if(collection.length<FORLOOP_FALLBACK){var argsDefCode=generateArgsDefCode(fixedArgsNum),_a=generateBodyPartsCode(argsDefCode,collection.length),funcDefCode=_a.funcDefCode,funcCallCode=_a.funcCallCode;funcFactoryCode=`(function(collection) {
            `.concat(funcDefCode,`
            collection = undefined;
            return (function(`).concat(argsDefCode,`) {
                return Promise.all([ `).concat(funcCallCode,` ]);
            });
        })`)}else{var argsDefCode=generateArgsDefCode(fixedArgsNum);funcFactoryCode=`(function(collection) {
            return (function(`.concat(argsDefCode,`) {
                var promises = Array(collection.length);
                for (var i = 0; i < collection.length; ++i) {
                    promises[i] = collection[i](`).concat(argsDefCode,`);
                }
                return Promise.all(promises);
            });
        })`)}{var funcFactory=eval(funcFactoryCode);return funcFactory(collection)}}exports.bakeCollectionAwait=bakeCollectionAwait;function bakeCollectionVariadic(collection){if(collection.length===0)return exports.BAKED_EMPTY_FUNC;if(collection.length===1)return collection[0];var funcFactoryCode;if(collection.length<FORLOOP_FALLBACK){var _a=generateBodyPartsVariadicCode(collection.length),funcDefCode=_a.funcDefCode,funcCallCode=_a.funcCallCode;funcFactoryCode=`(function(collection) {
            `.concat(funcDefCode,`
            collection = undefined;
            return (function() {
                `).concat(funcCallCode,`
            });
        })`)}else funcFactoryCode=`(function(collection) {
            return (function() {
                for (var i = 0; i < collection.length; ++i) {
                    collection[i].apply(undefined, arguments);
                }
            });
        })`;{var funcFactory=eval(funcFactoryCode);return funcFactory(collection)}}exports.bakeCollectionVariadic=bakeCollectionVariadic}(bakeCollection)),bakeCollection}var hasRequiredTaskCollection$1;function requireTaskCollection$1(){if(hasRequiredTaskCollection$1)return taskCollection;hasRequiredTaskCollection$1=1;var R=taskCollection&&taskCollection.__spreadArray||function(me,_e,oe){if(oe||arguments.length===2)for(var ue=0,he=_e.length,we;ue<he;ue++)(we||!(ue in _e))&&(we||(we=Array.prototype.slice.call(_e,0,ue)),we[ue]=_e[ue]);return me.concat(we||Array.prototype.slice.call(_e))};Object.defineProperty(taskCollection,"__esModule",{value:!0}),taskCollection.TaskCollection=void 0;var E=requireUtils$1(),U=requireBakeCollection();function H(me,_e){var oe=this.length;if(oe>1)if(_e){var ue;(ue=this._tasks).push.apply(ue,arguments),this.length+=arguments.length}else this._tasks.push(me),this.length++;else if(_e){if(oe===1){var he=Array(1+arguments.length);he.push(he),he.push.apply(he,arguments),this._tasks=he}else{var he=Array(arguments.length);he.push.apply(he,arguments),this._tasks=he}this.length+=arguments.length}else oe===1?this._tasks=[this._tasks,me]:this._tasks=me,this.length++}function K(me,_e){var oe=this.length;if(oe>1)if(_e){var ue;(ue=this._tasks).push.apply(ue,arguments),this.length+=arguments.length}else this._tasks.push(me),this.length++;else if(_e){if(oe===1){var he=Array(1+arguments.length);he.push(he),he.push.apply(he,arguments),this._tasks=he}else{var he=Array(arguments.length);he.push.apply(he,arguments),this._tasks=he}this.length+=arguments.length}else oe===1?this._tasks=[this._tasks,me]:this._tasks=me,this.length++;this.firstEmitBuildStrategy?this.call=J:this.rebuild()}function W(me){this.length!==0&&(this.length===1?this._tasks===me&&(this.length=0):((0,E._fast_remove_single)(this._tasks,this._tasks.lastIndexOf(me)),this._tasks.length===1?(this._tasks=this._tasks[0],this.length=1):this.length=this._tasks.length))}function G(me){if(this.length!==0){if(this.length===1)if(this._tasks===me&&(this.length=0),this.firstEmitBuildStrategy){this.call=U.BAKED_EMPTY_FUNC;return}else{this.rebuild();return}else(0,E._fast_remove_single)(this._tasks,this._tasks.lastIndexOf(me)),this._tasks.length===1?(this._tasks=this._tasks[0],this.length=1):this.length=this._tasks.length;this.firstEmitBuildStrategy?this.call=J:this.rebuild()}}function Z(me){for(var _e,oe=[],ue=1;ue<arguments.length;ue++)oe[ue-1]=arguments[ue];this.length===0?(this._tasks=oe,this.length=1):this.length===1?(oe.unshift(this._tasks),this._tasks=oe,this.length=this._tasks.length):((_e=this._tasks).splice.apply(_e,R([me,0],oe,!1)),this.length=this._tasks.length)}function Y(me){for(var _e,oe=[],ue=1;ue<arguments.length;ue++)oe[ue-1]=arguments[ue];this.length===0?(this._tasks=oe,this.length=1):this.length===1?(oe.unshift(this._tasks),this._tasks=oe,this.length=this._tasks.length):((_e=this._tasks).splice.apply(_e,R([me,0],oe,!1)),this.length=this._tasks.length),this.firstEmitBuildStrategy?this.call=J:this.rebuild()}function X(){this.length===0?this.call=U.BAKED_EMPTY_FUNC:this.length===1?this.call=this._tasks:this.call=(0,U.bakeCollection)(this._tasks,this.argsNum)}function Q(){this.length===0?this.call=U.BAKED_EMPTY_FUNC:this.length===1?this.call=this._tasks:this.call=(0,U.bakeCollectionAwait)(this._tasks,this.argsNum)}function J(){this.rebuild(),this.call.apply(void 0,arguments)}var ne=function(){function me(_e,oe,ue,he){oe===void 0&&(oe=!0),ue===void 0&&(ue=null),he===void 0&&(he=!1),this.awaitTasks=he,this.call=U.BAKED_EMPTY_FUNC,this.argsNum=_e,this.firstEmitBuildStrategy=!0,he?this.rebuild=Q.bind(this):this.rebuild=X.bind(this),this.setAutoRebuild(oe),ue?typeof ue=="function"?(this._tasks=ue,this.length=1):(this._tasks=ue,this.length=ue.length):(this._tasks=null,this.length=0),oe&&this.rebuild()}return me}();taskCollection.TaskCollection=ne;function re(){this._tasks=null,this.length=0,this.call=U.BAKED_EMPTY_FUNC}function ae(){this._tasks=null,this.length=0,this.call=U.BAKED_EMPTY_FUNC}function te(me){this.argsNum<me&&(this.argsNum=me,this.firstEmitBuildStrategy?this.call=J:this.rebuild())}function se(me){me?(this.push=K.bind(this),this.insert=Y.bind(this),this.removeLast=G.bind(this)):(this.push=H.bind(this),this.insert=Z.bind(this),this.removeLast=W.bind(this))}function ie(){return this.length===0?[]:this.length===1?[this._tasks]:this._tasks}function ye(me){me.length===0?(this.length=0,this.call=U.BAKED_EMPTY_FUNC):me.length===1?(this.length=1,this.call=me[0],this._tasks=me[0]):(this.length=me.length,this._tasks=me,this.firstEmitBuildStrategy?this.call=J:this.rebuild())}return ne.prototype.fastClear=re,ne.prototype.clear=ae,ne.prototype.growArgsNum=te,ne.prototype.setAutoRebuild=se,ne.prototype.tasksAsArray=ie,ne.prototype.setTasks=ye,taskCollection}var hasRequiredTaskCollection;function requireTaskCollection(){return hasRequiredTaskCollection||(hasRequiredTaskCollection=1,function(R){var E=taskCollection$1&&taskCollection$1.__createBinding||(Object.create?function(H,K,W,G){G===void 0&&(G=W);var Z=Object.getOwnPropertyDescriptor(K,W);(!Z||("get"in Z?!K.__esModule:Z.writable||Z.configurable))&&(Z={enumerable:!0,get:function(){return K[W]}}),Object.defineProperty(H,G,Z)}:function(H,K,W,G){G===void 0&&(G=W),H[G]=K[W]}),U=taskCollection$1&&taskCollection$1.__exportStar||function(H,K){for(var W in H)W!=="default"&&!Object.prototype.hasOwnProperty.call(K,W)&&E(K,H,W)};Object.defineProperty(R,"__esModule",{value:!0}),U(requireTaskCollection$1(),R)}(taskCollection$1)),taskCollection$1}var utils={},hasRequiredUtils;function requireUtils(){if(hasRequiredUtils)return utils;hasRequiredUtils=1,Object.defineProperty(utils,"__esModule",{value:!0}),utils.nullObj=void 0;function R(){var E={};return E.__proto__=null,E}return utils.nullObj=R,utils}var hasRequiredEe;function requireEe(){if(hasRequiredEe)return ee;hasRequiredEe=1;var R=ee&&ee.__spreadArray||function(oe,ue,he){if(he||arguments.length===2)for(var we=0,xe=ue.length,ke;we<xe;we++)(ke||!(we in ue))&&(ke||(ke=Array.prototype.slice.call(ue,0,we)),ke[we]=ue[we]);return oe.concat(ke||Array.prototype.slice.call(ue))};Object.defineProperty(ee,"__esModule",{value:!0}),ee.EventEmitter=void 0;var E=requireTaskCollection(),U=requireUtils$1(),H=requireUtils();function K(oe,ue,he,we,xe,ke){var ce=this.events[oe];if(ce){if(ce.length===0)return!1;if(ce.argsNum<6)ce.call(ue,he,we,xe,ke);else{for(var pe=new Array(ce.argsNum),ve=0,Ee=pe.length;ve<Ee;++ve)pe[ve]=arguments[ve+1];ce.call.apply(void 0,pe)}return!0}return!1}function W(oe,ue,he,we,xe,ke){var ce=this.events[oe],pe;if(ce!==void 0){if(ce.length===0)return!1;if(ce.argsNum<6)ce.call(ue,he,we,xe,ke);else{pe=new Array(ce.argsNum);for(var ve=0,Ee=pe.length;ve<Ee;++ve)pe[ve]=arguments[ve+1];ce.call.apply(void 0,pe)}}var de=this.onceEvents[oe];if(de){if(typeof de=="function")if(this.onceEvents[oe]=void 0,arguments.length<6)de(ue,he,we,xe,ke);else{if(pe===void 0){pe=new Array(arguments.length-1);for(var ve=0,Ee=pe.length;ve<Ee;++ve)pe[ve]=arguments[ve+1]}de.apply(void 0,pe)}else{var be=de;if(this.onceEvents[oe]=void 0,arguments.length<6)for(var ve=0;ve<be.length;++ve)be[ve](ue,he,we,xe,ke);else{if(pe===void 0){pe=new Array(arguments.length-1);for(var ve=0,Ee=pe.length;ve<Ee;++ve)pe[ve]=arguments[ve+1]}for(var ve=0;ve<be.length;++ve)be[ve].apply(void 0,pe)}}return!0}return ce!==void 0}var G=function(){function oe(){this.events=(0,H.nullObj)(),this.onceEvents=(0,H.nullObj)(),this._symbolKeys=new Set,this.maxListeners=1/0}return Object.defineProperty(oe.prototype,"_eventsCount",{get:function(){return this.eventNames().length},enumerable:!1,configurable:!0}),oe}();ee.EventEmitter=G;function Z(oe,ue){switch(this.emit===K&&(this.emit=W),typeof this.onceEvents[oe]){case"undefined":this.onceEvents[oe]=ue,typeof oe=="symbol"&&this._symbolKeys.add(oe);break;case"function":this.onceEvents[oe]=[this.onceEvents[oe],ue];break;case"object":this.onceEvents[oe].push(ue)}return this}function Y(oe,ue,he){if(he===void 0&&(he=ue.length),typeof ue!="function")throw new TypeError("The listener must be a function");var we=this.events[oe];return we?(we.push(ue),we.growArgsNum(he),this.maxListeners!==1/0&&this.maxListeners<=we.length&&console.warn('Maximum event listeners for "'.concat(String(oe),'" event!'))):(this.events[oe]=new E.TaskCollection(he,!0,ue,!1),typeof oe=="symbol"&&this._symbolKeys.add(oe)),this}function X(oe,ue){var he=this.events[oe];he&&he.removeLast(ue);var we=this.onceEvents[oe];return we&&(typeof we=="function"?this.onceEvents[oe]=void 0:typeof we=="object"&&(we.length===1&&we[0]===ue?this.onceEvents[oe]=void 0:(0,U._fast_remove_single)(we,we.lastIndexOf(ue)))),this}function Q(oe,ue,he,we){he===void 0&&(he=this),we===void 0&&(we=ue.length),this.boundFuncs||(this.boundFuncs=new Map);var xe=ue.bind(he);return this.boundFuncs.set(ue,xe),this.addListener(oe,xe,we)}function J(oe,ue){var he,we,xe=(he=this.boundFuncs)===null||he===void 0?void 0:he.get(ue);return(we=this.boundFuncs)===null||we===void 0||we.delete(ue),this.removeListener(oe,xe)}function ne(oe){return this.events[oe]&&!!this.events[oe].length}function re(oe,ue,he){if(he===void 0&&(he=ue.length),typeof ue!="function")throw new TypeError("The listener must be a function");var we=this.events[oe];return!we||!(we instanceof E.TaskCollection)?(we=this.events[oe]=new E.TaskCollection(he,!0,ue,!1),typeof oe=="symbol"&&this._symbolKeys.add(oe)):(we.insert(0,ue),we.growArgsNum(he),this.maxListeners!==1/0&&this.maxListeners<=we.length&&console.warn('Maximum event listeners for "'.concat(String(oe),'" event!'))),this}function ae(oe,ue){this.emit===K&&(this.emit=W);var he=this.onceEvents[oe];return he?typeof he!="object"?(this.onceEvents[oe]=[ue,he],typeof oe=="symbol"&&this._symbolKeys.add(oe)):(he.unshift(ue),this.maxListeners!==1/0&&this.maxListeners<=he.length&&console.warn('Maximum event listeners for "'.concat(String(oe),'" once event!'))):(this.onceEvents[oe]=[ue],typeof oe=="symbol"&&this._symbolKeys.add(oe)),this}function te(oe){return oe===void 0?(this.events=(0,H.nullObj)(),this.onceEvents=(0,H.nullObj)(),this._symbolKeys=new Set):(this.events[oe]=void 0,this.onceEvents[oe]=void 0,typeof oe=="symbol"&&this._symbolKeys.delete(oe)),this}function se(oe){return this.maxListeners=oe,this}function ie(){return this.maxListeners}function ye(oe){return this.emit===K?this.events[oe]?this.events[oe].tasksAsArray().slice():[]:this.events[oe]&&this.onceEvents[oe]?R(R([],this.events[oe].tasksAsArray(),!0),typeof this.onceEvents[oe]=="function"?[this.onceEvents[oe]]:this.onceEvents[oe],!0):this.events[oe]?this.events[oe].tasksAsArray():this.onceEvents[oe]?typeof this.onceEvents[oe]=="function"?[this.onceEvents[oe]]:this.onceEvents[oe]:[]}function me(){var oe=this;if(this.emit===K){var ue=Object.keys(this.events);return R(R([],ue,!0),Array.from(this._symbolKeys),!0).filter(function(we){return we in oe.events&&oe.events[we]&&oe.events[we].length})}else{var ue=Object.keys(this.events).filter(function(xe){return oe.events[xe]&&oe.events[xe].length}),he=Object.keys(this.onceEvents).filter(function(xe){return oe.onceEvents[xe]&&oe.onceEvents[xe].length});return R(R(R([],ue,!0),he,!0),Array.from(this._symbolKeys).filter(function(xe){return xe in oe.events&&oe.events[xe]&&oe.events[xe].length||xe in oe.onceEvents&&oe.onceEvents[xe]&&oe.onceEvents[xe].length}),!0)}}function _e(oe){return this.emit===K?this.events[oe]&&this.events[oe].length||0:(this.events[oe]&&this.events[oe].length||0)+(this.onceEvents[oe]&&this.onceEvents[oe].length||0)}return G.prototype.emit=K,G.prototype.on=Y,G.prototype.once=Z,G.prototype.addListener=Y,G.prototype.removeListener=X,G.prototype.addListenerBound=Q,G.prototype.removeListenerBound=J,G.prototype.hasListeners=ne,G.prototype.prependListener=re,G.prototype.prependOnceListener=ae,G.prototype.off=X,G.prototype.removeAllListeners=te,G.prototype.setMaxListeners=se,G.prototype.getMaxListeners=ie,G.prototype.listeners=ye,G.prototype.eventNames=me,G.prototype.listenerCount=_e,ee}var hasRequiredLib$1;function requireLib$1(){return hasRequiredLib$1||(hasRequiredLib$1=1,function(R){var E=lib$1&&lib$1.__createBinding||(Object.create?function(H,K,W,G){G===void 0&&(G=W);var Z=Object.getOwnPropertyDescriptor(K,W);(!Z||("get"in Z?!K.__esModule:Z.writable||Z.configurable))&&(Z={enumerable:!0,get:function(){return K[W]}}),Object.defineProperty(H,G,Z)}:function(H,K,W,G){G===void 0&&(G=W),H[G]=K[W]}),U=lib$1&&lib$1.__exportStar||function(H,K){for(var W in H)W!=="default"&&!Object.prototype.hasOwnProperty.call(K,W)&&E(K,H,W)};Object.defineProperty(R,"__esModule",{value:!0}),U(requireTypes(),R),U(requireEe(),R)}(lib$1)),lib$1}var libExports=requireLib$1(),browser={exports:{}},ms,hasRequiredMs;function requireMs(){if(hasRequiredMs)return ms;hasRequiredMs=1;var R=1e3,E=R*60,U=E*60,H=U*24,K=H*7,W=H*365.25;ms=function(Q,J){J=J||{};var ne=typeof Q;if(ne==="string"&&Q.length>0)return G(Q);if(ne==="number"&&isFinite(Q))return J.long?Y(Q):Z(Q);throw new Error("val is not a non-empty string or a valid number. val="+JSON.stringify(Q))};function G(Q){if(Q=String(Q),!(Q.length>100)){var J=/^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(Q);if(J){var ne=parseFloat(J[1]),re=(J[2]||"ms").toLowerCase();switch(re){case"years":case"year":case"yrs":case"yr":case"y":return ne*W;case"weeks":case"week":case"w":return ne*K;case"days":case"day":case"d":return ne*H;case"hours":case"hour":case"hrs":case"hr":case"h":return ne*U;case"minutes":case"minute":case"mins":case"min":case"m":return ne*E;case"seconds":case"second":case"secs":case"sec":case"s":return ne*R;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return ne;default:return}}}}function Z(Q){var J=Math.abs(Q);return J>=H?Math.round(Q/H)+"d":J>=U?Math.round(Q/U)+"h":J>=E?Math.round(Q/E)+"m":J>=R?Math.round(Q/R)+"s":Q+"ms"}function Y(Q){var J=Math.abs(Q);return J>=H?X(Q,J,H,"day"):J>=U?X(Q,J,U,"hour"):J>=E?X(Q,J,E,"minute"):J>=R?X(Q,J,R,"second"):Q+" ms"}function X(Q,J,ne,re){var ae=J>=ne*1.5;return Math.round(Q/ne)+" "+re+(ae?"s":"")}return ms}var common,hasRequiredCommon;function requireCommon(){if(hasRequiredCommon)return common;hasRequiredCommon=1;function R(E){H.debug=H,H.default=H,H.coerce=X,H.disable=Z,H.enable=W,H.enabled=Y,H.humanize=requireMs(),H.destroy=Q,Object.keys(E).forEach(J=>{H[J]=E[J]}),H.names=[],H.skips=[],H.formatters={};function U(J){let ne=0;for(let re=0;re<J.length;re++)ne=(ne<<5)-ne+J.charCodeAt(re),ne|=0;return H.colors[Math.abs(ne)%H.colors.length]}H.selectColor=U;function H(J){let ne,re=null,ae,te;function se(...ie){if(!se.enabled)return;const ye=se,me=Number(new Date),_e=me-(ne||me);ye.diff=_e,ye.prev=ne,ye.curr=me,ne=me,ie[0]=H.coerce(ie[0]),typeof ie[0]!="string"&&ie.unshift("%O");let oe=0;ie[0]=ie[0].replace(/%([a-zA-Z%])/g,(he,we)=>{if(he==="%%")return"%";oe++;const xe=H.formatters[we];if(typeof xe=="function"){const ke=ie[oe];he=xe.call(ye,ke),ie.splice(oe,1),oe--}return he}),H.formatArgs.call(ye,ie),(ye.log||H.log).apply(ye,ie)}return se.namespace=J,se.useColors=H.useColors(),se.color=H.selectColor(J),se.extend=K,se.destroy=H.destroy,Object.defineProperty(se,"enabled",{enumerable:!0,configurable:!1,get:()=>re!==null?re:(ae!==H.namespaces&&(ae=H.namespaces,te=H.enabled(J)),te),set:ie=>{re=ie}}),typeof H.init=="function"&&H.init(se),se}function K(J,ne){const re=H(this.namespace+(typeof ne>"u"?":":ne)+J);return re.log=this.log,re}function W(J){H.save(J),H.namespaces=J,H.names=[],H.skips=[];const ne=(typeof J=="string"?J:"").trim().replace(" ",",").split(",").filter(Boolean);for(const re of ne)re[0]==="-"?H.skips.push(re.slice(1)):H.names.push(re)}function G(J,ne){let re=0,ae=0,te=-1,se=0;for(;re<J.length;)if(ae<ne.length&&(ne[ae]===J[re]||ne[ae]==="*"))ne[ae]==="*"?(te=ae,se=re,ae++):(re++,ae++);else if(te!==-1)ae=te+1,se++,re=se;else return!1;for(;ae<ne.length&&ne[ae]==="*";)ae++;return ae===ne.length}function Z(){const J=[...H.names,...H.skips.map(ne=>"-"+ne)].join(",");return H.enable(""),J}function Y(J){for(const ne of H.skips)if(G(J,ne))return!1;for(const ne of H.names)if(G(J,ne))return!0;return!1}function X(J){return J instanceof Error?J.stack||J.message:J}function Q(){console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.")}return H.enable(H.load()),H}return common=R,common}var hasRequiredBrowser;function requireBrowser(){return hasRequiredBrowser||(hasRequiredBrowser=1,function(R,E){var U={};E.formatArgs=K,E.save=W,E.load=G,E.useColors=H,E.storage=Z(),E.destroy=(()=>{let X=!1;return()=>{X||(X=!0,console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."))}})(),E.colors=["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"];function H(){if(typeof window<"u"&&window.process&&(window.process.type==="renderer"||window.process.__nwjs))return!0;if(typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))return!1;let X;return typeof document<"u"&&document.documentElement&&document.documentElement.style&&document.documentElement.style.WebkitAppearance||typeof window<"u"&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||typeof navigator<"u"&&navigator.userAgent&&(X=navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/))&&parseInt(X[1],10)>=31||typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/)}function K(X){if(X[0]=(this.useColors?"%c":"")+this.namespace+(this.useColors?" %c":" ")+X[0]+(this.useColors?"%c ":" ")+"+"+R.exports.humanize(this.diff),!this.useColors)return;const Q="color: "+this.color;X.splice(1,0,Q,"color: inherit");let J=0,ne=0;X[0].replace(/%[a-zA-Z%]/g,re=>{re!=="%%"&&(J++,re==="%c"&&(ne=J))}),X.splice(ne,0,Q)}E.log=console.debug||console.log||(()=>{});function W(X){try{X?E.storage.setItem("debug",X):E.storage.removeItem("debug")}catch{}}function G(){let X;try{X=E.storage.getItem("debug")}catch{}return!X&&typeof process<"u"&&"env"in process&&(X=U.DEBUG),X}function Z(){try{return localStorage}catch{}}R.exports=requireCommon()(E);const{formatters:Y}=R.exports;Y.j=function(X){try{return JSON.stringify(X)}catch(Q){return"[UnexpectedJSONParseError]: "+Q.message}}}(browser,browser.exports)),browser.exports}var browserExports=requireBrowser();const debug7=getDefaultExportFromCjs(browserExports);function isBytes$3(R){return R instanceof Uint8Array||ArrayBuffer.isView(R)&&R.constructor.name==="Uint8Array"}function abytes$2(R,...E){if(!isBytes$3(R))throw new Error("Uint8Array expected");if(E.length>0&&!E.includes(R.length))throw new Error("Uint8Array expected of length "+E+", got length="+R.length)}function aexists$1(R,E=!0){if(R.destroyed)throw new Error("Hash instance has been destroyed");if(E&&R.finished)throw new Error("Hash#digest() has already been called")}function aoutput$1(R,E){abytes$2(R);const U=E.outputLen;if(R.length<U)throw new Error("digestInto() expects output buffer of length at least "+U)}/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */const createView$1=R=>new DataView(R.buffer,R.byteOffset,R.byteLength),rotr$1=(R,E)=>R<<32-E|R>>>E,hexes$1=Array.from({length:256},(R,E)=>E.toString(16).padStart(2,"0"));function bytesToHex$1(R){abytes$2(R);let E="";for(let U=0;U<R.length;U++)E+=hexes$1[R[U]];return E}const asciis$1={_0:48,_9:57,A:65,F:70,a:97,f:102};function asciiToBase16$1(R){if(R>=asciis$1._0&&R<=asciis$1._9)return R-asciis$1._0;if(R>=asciis$1.A&&R<=asciis$1.F)return R-(asciis$1.A-10);if(R>=asciis$1.a&&R<=asciis$1.f)return R-(asciis$1.a-10)}function hexToBytes$1(R){if(typeof R!="string")throw new Error("hex string expected, got "+typeof R);const E=R.length,U=E/2;if(E%2)throw new Error("hex string expected, got unpadded hex of length "+E);const H=new Uint8Array(U);for(let K=0,W=0;K<U;K++,W+=2){const G=asciiToBase16$1(R.charCodeAt(W)),Z=asciiToBase16$1(R.charCodeAt(W+1));if(G===void 0||Z===void 0){const Y=R[W]+R[W+1];throw new Error('hex string expected, got non-hex character "'+Y+'" at index '+W)}H[K]=G*16+Z}return H}function utf8ToBytes$2(R){if(typeof R!="string")throw new Error("utf8ToBytes expected string, got "+typeof R);return new Uint8Array(new TextEncoder().encode(R))}function toBytes$1(R){return typeof R=="string"&&(R=utf8ToBytes$2(R)),abytes$2(R),R}let Hash$1=class{clone(){return this._cloneInto()}};function wrapConstructor$1(R){const E=H=>R().update(toBytes$1(H)).digest(),U=R();return E.outputLen=U.outputLen,E.blockLen=U.blockLen,E.create=()=>R(),E}function setBigUint64$1(R,E,U,H){if(typeof R.setBigUint64=="function")return R.setBigUint64(E,U,H);const K=BigInt(32),W=BigInt(4294967295),G=Number(U>>K&W),Z=Number(U&W),Y=H?4:0,X=H?0:4;R.setUint32(E+Y,G,H),R.setUint32(E+X,Z,H)}const Chi$1=(R,E,U)=>R&E^~R&U,Maj$1=(R,E,U)=>R&E^R&U^E&U;let HashMD$1=class extends Hash$1{constructor(E,U,H,K){super(),this.blockLen=E,this.outputLen=U,this.padOffset=H,this.isLE=K,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(E),this.view=createView$1(this.buffer)}update(E){aexists$1(this);const{view:U,buffer:H,blockLen:K}=this;E=toBytes$1(E);const W=E.length;for(let G=0;G<W;){const Z=Math.min(K-this.pos,W-G);if(Z===K){const Y=createView$1(E);for(;K<=W-G;G+=K)this.process(Y,G);continue}H.set(E.subarray(G,G+Z),this.pos),this.pos+=Z,G+=Z,this.pos===K&&(this.process(U,0),this.pos=0)}return this.length+=E.length,this.roundClean(),this}digestInto(E){aexists$1(this),aoutput$1(E,this),this.finished=!0;const{buffer:U,view:H,blockLen:K,isLE:W}=this;let{pos:G}=this;U[G++]=128,this.buffer.subarray(G).fill(0),this.padOffset>K-G&&(this.process(H,0),G=0);for(let J=G;J<K;J++)U[J]=0;setBigUint64$1(H,K-8,BigInt(this.length*8),W),this.process(H,0);const Z=createView$1(E),Y=this.outputLen;if(Y%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const X=Y/4,Q=this.get();if(X>Q.length)throw new Error("_sha2: outputLen bigger than state");for(let J=0;J<X;J++)Z.setUint32(4*J,Q[J],W)}digest(){const{buffer:E,outputLen:U}=this;this.digestInto(E);const H=E.slice(0,U);return this.destroy(),H}_cloneInto(E){E||(E=new this.constructor),E.set(...this.get());const{blockLen:U,buffer:H,length:K,finished:W,destroyed:G,pos:Z}=this;return E.length=K,E.pos=Z,E.finished=W,E.destroyed=G,K%U&&E.buffer.set(H),E}};const SHA256_K$1=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),SHA256_IV$1=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),SHA256_W$1=new Uint32Array(64);let SHA256$1=class extends HashMD$1{constructor(){super(64,32,8,!1),this.A=SHA256_IV$1[0]|0,this.B=SHA256_IV$1[1]|0,this.C=SHA256_IV$1[2]|0,this.D=SHA256_IV$1[3]|0,this.E=SHA256_IV$1[4]|0,this.F=SHA256_IV$1[5]|0,this.G=SHA256_IV$1[6]|0,this.H=SHA256_IV$1[7]|0}get(){const{A:E,B:U,C:H,D:K,E:W,F:G,G:Z,H:Y}=this;return[E,U,H,K,W,G,Z,Y]}set(E,U,H,K,W,G,Z,Y){this.A=E|0,this.B=U|0,this.C=H|0,this.D=K|0,this.E=W|0,this.F=G|0,this.G=Z|0,this.H=Y|0}process(E,U){for(let J=0;J<16;J++,U+=4)SHA256_W$1[J]=E.getUint32(U,!1);for(let J=16;J<64;J++){const ne=SHA256_W$1[J-15],re=SHA256_W$1[J-2],ae=rotr$1(ne,7)^rotr$1(ne,18)^ne>>>3,te=rotr$1(re,17)^rotr$1(re,19)^re>>>10;SHA256_W$1[J]=te+SHA256_W$1[J-7]+ae+SHA256_W$1[J-16]|0}let{A:H,B:K,C:W,D:G,E:Z,F:Y,G:X,H:Q}=this;for(let J=0;J<64;J++){const ne=rotr$1(Z,6)^rotr$1(Z,11)^rotr$1(Z,25),re=Q+ne+Chi$1(Z,Y,X)+SHA256_K$1[J]+SHA256_W$1[J]|0,te=(rotr$1(H,2)^rotr$1(H,13)^rotr$1(H,22))+Maj$1(H,K,W)|0;Q=X,X=Y,Y=Z,Z=G+re|0,G=W,W=K,K=H,H=re+te|0}H=H+this.A|0,K=K+this.B|0,W=W+this.C|0,G=G+this.D|0,Z=Z+this.E|0,Y=Y+this.F|0,X=X+this.G|0,Q=Q+this.H|0,this.set(H,K,W,G,Z,Y,X,Q)}roundClean(){SHA256_W$1.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}};const sha256$1=wrapConstructor$1(()=>new SHA256$1);function anumber$1(R){if(!Number.isSafeInteger(R)||R<0)throw new Error("positive integer expected, got "+R)}function isBytes$2(R){return R instanceof Uint8Array||ArrayBuffer.isView(R)&&R.constructor.name==="Uint8Array"}function abytes$1(R,...E){if(!isBytes$2(R))throw new Error("Uint8Array expected");if(E.length>0&&!E.includes(R.length))throw new Error("Uint8Array expected of length "+E+", got length="+R.length)}function ahash(R){if(typeof R!="function"||typeof R.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");anumber$1(R.outputLen),anumber$1(R.blockLen)}function aexists(R,E=!0){if(R.destroyed)throw new Error("Hash instance has been destroyed");if(E&&R.finished)throw new Error("Hash#digest() has already been called")}function aoutput(R,E){abytes$1(R);const U=E.outputLen;if(R.length<U)throw new Error("digestInto() expects output buffer of length at least "+U)}const crypto$1=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */const createView=R=>new DataView(R.buffer,R.byteOffset,R.byteLength),rotr=(R,E)=>R<<32-E|R>>>E;function utf8ToBytes$1(R){if(typeof R!="string")throw new Error("utf8ToBytes expected string, got "+typeof R);return new Uint8Array(new TextEncoder().encode(R))}function toBytes(R){return typeof R=="string"&&(R=utf8ToBytes$1(R)),abytes$1(R),R}function concatBytes$1(...R){let E=0;for(let H=0;H<R.length;H++){const K=R[H];abytes$1(K),E+=K.length}const U=new Uint8Array(E);for(let H=0,K=0;H<R.length;H++){const W=R[H];U.set(W,K),K+=W.length}return U}class Hash{clone(){return this._cloneInto()}}function wrapConstructor(R){const E=H=>R().update(toBytes(H)).digest(),U=R();return E.outputLen=U.outputLen,E.blockLen=U.blockLen,E.create=()=>R(),E}function randomBytes(R=32){if(crypto$1&&typeof crypto$1.getRandomValues=="function")return crypto$1.getRandomValues(new Uint8Array(R));if(crypto$1&&typeof crypto$1.randomBytes=="function")return crypto$1.randomBytes(R);throw new Error("crypto.getRandomValues must be defined")}function setBigUint64(R,E,U,H){if(typeof R.setBigUint64=="function")return R.setBigUint64(E,U,H);const K=BigInt(32),W=BigInt(4294967295),G=Number(U>>K&W),Z=Number(U&W),Y=H?4:0,X=H?0:4;R.setUint32(E+Y,G,H),R.setUint32(E+X,Z,H)}const Chi=(R,E,U)=>R&E^~R&U,Maj=(R,E,U)=>R&E^R&U^E&U;class HashMD extends Hash{constructor(E,U,H,K){super(),this.blockLen=E,this.outputLen=U,this.padOffset=H,this.isLE=K,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(E),this.view=createView(this.buffer)}update(E){aexists(this);const{view:U,buffer:H,blockLen:K}=this;E=toBytes(E);const W=E.length;for(let G=0;G<W;){const Z=Math.min(K-this.pos,W-G);if(Z===K){const Y=createView(E);for(;K<=W-G;G+=K)this.process(Y,G);continue}H.set(E.subarray(G,G+Z),this.pos),this.pos+=Z,G+=Z,this.pos===K&&(this.process(U,0),this.pos=0)}return this.length+=E.length,this.roundClean(),this}digestInto(E){aexists(this),aoutput(E,this),this.finished=!0;const{buffer:U,view:H,blockLen:K,isLE:W}=this;let{pos:G}=this;U[G++]=128,this.buffer.subarray(G).fill(0),this.padOffset>K-G&&(this.process(H,0),G=0);for(let J=G;J<K;J++)U[J]=0;setBigUint64(H,K-8,BigInt(this.length*8),W),this.process(H,0);const Z=createView(E),Y=this.outputLen;if(Y%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const X=Y/4,Q=this.get();if(X>Q.length)throw new Error("_sha2: outputLen bigger than state");for(let J=0;J<X;J++)Z.setUint32(4*J,Q[J],W)}digest(){const{buffer:E,outputLen:U}=this;this.digestInto(E);const H=E.slice(0,U);return this.destroy(),H}_cloneInto(E){E||(E=new this.constructor),E.set(...this.get());const{blockLen:U,buffer:H,length:K,finished:W,destroyed:G,pos:Z}=this;return E.length=K,E.pos=Z,E.finished=W,E.destroyed=G,K%U&&E.buffer.set(H),E}}const SHA256_K=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),SHA256_IV=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),SHA256_W=new Uint32Array(64);class SHA256 extends HashMD{constructor(){super(64,32,8,!1),this.A=SHA256_IV[0]|0,this.B=SHA256_IV[1]|0,this.C=SHA256_IV[2]|0,this.D=SHA256_IV[3]|0,this.E=SHA256_IV[4]|0,this.F=SHA256_IV[5]|0,this.G=SHA256_IV[6]|0,this.H=SHA256_IV[7]|0}get(){const{A:E,B:U,C:H,D:K,E:W,F:G,G:Z,H:Y}=this;return[E,U,H,K,W,G,Z,Y]}set(E,U,H,K,W,G,Z,Y){this.A=E|0,this.B=U|0,this.C=H|0,this.D=K|0,this.E=W|0,this.F=G|0,this.G=Z|0,this.H=Y|0}process(E,U){for(let J=0;J<16;J++,U+=4)SHA256_W[J]=E.getUint32(U,!1);for(let J=16;J<64;J++){const ne=SHA256_W[J-15],re=SHA256_W[J-2],ae=rotr(ne,7)^rotr(ne,18)^ne>>>3,te=rotr(re,17)^rotr(re,19)^re>>>10;SHA256_W[J]=te+SHA256_W[J-7]+ae+SHA256_W[J-16]|0}let{A:H,B:K,C:W,D:G,E:Z,F:Y,G:X,H:Q}=this;for(let J=0;J<64;J++){const ne=rotr(Z,6)^rotr(Z,11)^rotr(Z,25),re=Q+ne+Chi(Z,Y,X)+SHA256_K[J]+SHA256_W[J]|0,te=(rotr(H,2)^rotr(H,13)^rotr(H,22))+Maj(H,K,W)|0;Q=X,X=Y,Y=Z,Z=G+re|0,G=W,W=K,K=H,H=re+te|0}H=H+this.A|0,K=K+this.B|0,W=W+this.C|0,G=G+this.D|0,Z=Z+this.E|0,Y=Y+this.F|0,X=X+this.G|0,Q=Q+this.H|0,this.set(H,K,W,G,Z,Y,X,Q)}roundClean(){SHA256_W.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}const sha256=wrapConstructor(()=>new SHA256);class HMAC extends Hash{constructor(E,U){super(),this.finished=!1,this.destroyed=!1,ahash(E);const H=toBytes(U);if(this.iHash=E.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const K=this.blockLen,W=new Uint8Array(K);W.set(H.length>K?E.create().update(H).digest():H);for(let G=0;G<W.length;G++)W[G]^=54;this.iHash.update(W),this.oHash=E.create();for(let G=0;G<W.length;G++)W[G]^=106;this.oHash.update(W),W.fill(0)}update(E){return aexists(this),this.iHash.update(E),this}digestInto(E){aexists(this),abytes$1(E,this.outputLen),this.finished=!0,this.iHash.digestInto(E),this.oHash.update(E),this.oHash.digestInto(E),this.destroy()}digest(){const E=new Uint8Array(this.oHash.outputLen);return this.digestInto(E),E}_cloneInto(E){E||(E=Object.create(Object.getPrototypeOf(this),{}));const{oHash:U,iHash:H,finished:K,destroyed:W,blockLen:G,outputLen:Z}=this;return E=E,E.finished=K,E.destroyed=W,E.blockLen=G,E.outputLen=Z,E.oHash=U._cloneInto(E.oHash),E.iHash=H._cloneInto(E.iHash),E}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const hmac=(R,E,U)=>new HMAC(R,E).update(U).digest();hmac.create=(R,E)=>new HMAC(R,E);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const _0n$4=BigInt(0),_1n$4=BigInt(1),_2n$2=BigInt(2);function isBytes$1(R){return R instanceof Uint8Array||ArrayBuffer.isView(R)&&R.constructor.name==="Uint8Array"}function abytes(R){if(!isBytes$1(R))throw new Error("Uint8Array expected")}function abool(R,E){if(typeof E!="boolean")throw new Error(R+" boolean expected, got "+E)}const hexes=Array.from({length:256},(R,E)=>E.toString(16).padStart(2,"0"));function bytesToHex(R){abytes(R);let E="";for(let U=0;U<R.length;U++)E+=hexes[R[U]];return E}function numberToHexUnpadded(R){const E=R.toString(16);return E.length&1?"0"+E:E}function hexToNumber(R){if(typeof R!="string")throw new Error("hex string expected, got "+typeof R);return R===""?_0n$4:BigInt("0x"+R)}const asciis={_0:48,_9:57,A:65,F:70,a:97,f:102};function asciiToBase16(R){if(R>=asciis._0&&R<=asciis._9)return R-asciis._0;if(R>=asciis.A&&R<=asciis.F)return R-(asciis.A-10);if(R>=asciis.a&&R<=asciis.f)return R-(asciis.a-10)}function hexToBytes(R){if(typeof R!="string")throw new Error("hex string expected, got "+typeof R);const E=R.length,U=E/2;if(E%2)throw new Error("hex string expected, got unpadded hex of length "+E);const H=new Uint8Array(U);for(let K=0,W=0;K<U;K++,W+=2){const G=asciiToBase16(R.charCodeAt(W)),Z=asciiToBase16(R.charCodeAt(W+1));if(G===void 0||Z===void 0){const Y=R[W]+R[W+1];throw new Error('hex string expected, got non-hex character "'+Y+'" at index '+W)}H[K]=G*16+Z}return H}function bytesToNumberBE(R){return hexToNumber(bytesToHex(R))}function bytesToNumberLE(R){return abytes(R),hexToNumber(bytesToHex(Uint8Array.from(R).reverse()))}function numberToBytesBE(R,E){return hexToBytes(R.toString(16).padStart(E*2,"0"))}function numberToBytesLE(R,E){return numberToBytesBE(R,E).reverse()}function numberToVarBytesBE(R){return hexToBytes(numberToHexUnpadded(R))}function ensureBytes(R,E,U){let H;if(typeof E=="string")try{H=hexToBytes(E)}catch(W){throw new Error(R+" must be hex string or Uint8Array, cause: "+W)}else if(isBytes$1(E))H=Uint8Array.from(E);else throw new Error(R+" must be hex string or Uint8Array");const K=H.length;if(typeof U=="number"&&K!==U)throw new Error(R+" of length "+U+" expected, got "+K);return H}function concatBytes(...R){let E=0;for(let H=0;H<R.length;H++){const K=R[H];abytes(K),E+=K.length}const U=new Uint8Array(E);for(let H=0,K=0;H<R.length;H++){const W=R[H];U.set(W,K),K+=W.length}return U}function equalBytes(R,E){if(R.length!==E.length)return!1;let U=0;for(let H=0;H<R.length;H++)U|=R[H]^E[H];return U===0}function utf8ToBytes(R){if(typeof R!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(R))}const isPosBig=R=>typeof R=="bigint"&&_0n$4<=R;function inRange(R,E,U){return isPosBig(R)&&isPosBig(E)&&isPosBig(U)&&E<=R&&R<U}function aInRange(R,E,U,H){if(!inRange(E,U,H))throw new Error("expected valid "+R+": "+U+" <= n < "+H+", got "+E)}function bitLen(R){let E;for(E=0;R>_0n$4;R>>=_1n$4,E+=1);return E}function bitGet(R,E){return R>>BigInt(E)&_1n$4}function bitSet(R,E,U){return R|(U?_1n$4:_0n$4)<<BigInt(E)}const bitMask=R=>(_2n$2<<BigInt(R-1))-_1n$4,u8n=R=>new Uint8Array(R),u8fr=R=>Uint8Array.from(R);function createHmacDrbg(R,E,U){if(typeof R!="number"||R<2)throw new Error("hashLen must be a number");if(typeof E!="number"||E<2)throw new Error("qByteLen must be a number");if(typeof U!="function")throw new Error("hmacFn must be a function");let H=u8n(R),K=u8n(R),W=0;const G=()=>{H.fill(1),K.fill(0),W=0},Z=(...J)=>U(K,H,...J),Y=(J=u8n())=>{K=Z(u8fr([0]),J),H=Z(),J.length!==0&&(K=Z(u8fr([1]),J),H=Z())},X=()=>{if(W++>=1e3)throw new Error("drbg: tried 1000 values");let J=0;const ne=[];for(;J<E;){H=Z();const re=H.slice();ne.push(re),J+=H.length}return concatBytes(...ne)};return(J,ne)=>{G(),Y(J);let re;for(;!(re=ne(X()));)Y();return G(),re}}const validatorFns={bigint:R=>typeof R=="bigint",function:R=>typeof R=="function",boolean:R=>typeof R=="boolean",string:R=>typeof R=="string",stringOrUint8Array:R=>typeof R=="string"||isBytes$1(R),isSafeInteger:R=>Number.isSafeInteger(R),array:R=>Array.isArray(R),field:(R,E)=>E.Fp.isValid(R),hash:R=>typeof R=="function"&&Number.isSafeInteger(R.outputLen)};function validateObject(R,E,U={}){const H=(K,W,G)=>{const Z=validatorFns[W];if(typeof Z!="function")throw new Error("invalid validator function");const Y=R[K];if(!(G&&Y===void 0)&&!Z(Y,R))throw new Error("param "+String(K)+" is invalid. Expected "+W+", got "+Y)};for(const[K,W]of Object.entries(E))H(K,W,!1);for(const[K,W]of Object.entries(U))H(K,W,!0);return R}const notImplemented=()=>{throw new Error("not implemented")};function memoized(R){const E=new WeakMap;return(U,...H)=>{const K=E.get(U);if(K!==void 0)return K;const W=R(U,...H);return E.set(U,W),W}}const ut=Object.freeze(Object.defineProperty({__proto__:null,aInRange,abool,abytes,bitGet,bitLen,bitMask,bitSet,bytesToHex,bytesToNumberBE,bytesToNumberLE,concatBytes,createHmacDrbg,ensureBytes,equalBytes,hexToBytes,hexToNumber,inRange,isBytes:isBytes$1,memoized,notImplemented,numberToBytesBE,numberToBytesLE,numberToHexUnpadded,numberToVarBytesBE,utf8ToBytes,validateObject},Symbol.toStringTag,{value:"Module"}));/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const _0n$3=BigInt(0),_1n$3=BigInt(1),_2n$1=BigInt(2),_3n$1=BigInt(3),_4n=BigInt(4),_5n=BigInt(5),_8n=BigInt(8);function mod(R,E){const U=R%E;return U>=_0n$3?U:E+U}function pow(R,E,U){if(E<_0n$3)throw new Error("invalid exponent, negatives unsupported");if(U<=_0n$3)throw new Error("invalid modulus");if(U===_1n$3)return _0n$3;let H=_1n$3;for(;E>_0n$3;)E&_1n$3&&(H=H*R%U),R=R*R%U,E>>=_1n$3;return H}function pow2(R,E,U){let H=R;for(;E-- >_0n$3;)H*=H,H%=U;return H}function invert(R,E){if(R===_0n$3)throw new Error("invert: expected non-zero number");if(E<=_0n$3)throw new Error("invert: expected positive modulus, got "+E);let U=mod(R,E),H=E,K=_0n$3,W=_1n$3;for(;U!==_0n$3;){const Z=H/U,Y=H%U,X=K-W*Z;H=U,U=Y,K=W,W=X}if(H!==_1n$3)throw new Error("invert: does not exist");return mod(K,E)}function tonelliShanks(R){const E=(R-_1n$3)/_2n$1;let U,H,K;for(U=R-_1n$3,H=0;U%_2n$1===_0n$3;U/=_2n$1,H++);for(K=_2n$1;K<R&&pow(K,E,R)!==R-_1n$3;K++)if(K>1e3)throw new Error("Cannot find square root: likely non-prime P");if(H===1){const G=(R+_1n$3)/_4n;return function(Y,X){const Q=Y.pow(X,G);if(!Y.eql(Y.sqr(Q),X))throw new Error("Cannot find square root");return Q}}const W=(U+_1n$3)/_2n$1;return function(Z,Y){if(Z.pow(Y,E)===Z.neg(Z.ONE))throw new Error("Cannot find square root");let X=H,Q=Z.pow(Z.mul(Z.ONE,K),U),J=Z.pow(Y,W),ne=Z.pow(Y,U);for(;!Z.eql(ne,Z.ONE);){if(Z.eql(ne,Z.ZERO))return Z.ZERO;let re=1;for(let te=Z.sqr(ne);re<X&&!Z.eql(te,Z.ONE);re++)te=Z.sqr(te);const ae=Z.pow(Q,_1n$3<<BigInt(X-re-1));Q=Z.sqr(ae),J=Z.mul(J,ae),ne=Z.mul(ne,Q),X=re}return J}}function FpSqrt(R){if(R%_4n===_3n$1){const E=(R+_1n$3)/_4n;return function(H,K){const W=H.pow(K,E);if(!H.eql(H.sqr(W),K))throw new Error("Cannot find square root");return W}}if(R%_8n===_5n){const E=(R-_5n)/_8n;return function(H,K){const W=H.mul(K,_2n$1),G=H.pow(W,E),Z=H.mul(K,G),Y=H.mul(H.mul(Z,_2n$1),G),X=H.mul(Z,H.sub(Y,H.ONE));if(!H.eql(H.sqr(X),K))throw new Error("Cannot find square root");return X}}return tonelliShanks(R)}const FIELD_FIELDS=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function validateField(R){const E={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},U=FIELD_FIELDS.reduce((H,K)=>(H[K]="function",H),E);return validateObject(R,U)}function FpPow(R,E,U){if(U<_0n$3)throw new Error("invalid exponent, negatives unsupported");if(U===_0n$3)return R.ONE;if(U===_1n$3)return E;let H=R.ONE,K=E;for(;U>_0n$3;)U&_1n$3&&(H=R.mul(H,K)),K=R.sqr(K),U>>=_1n$3;return H}function FpInvertBatch(R,E){const U=new Array(E.length),H=E.reduce((W,G,Z)=>R.is0(G)?W:(U[Z]=W,R.mul(W,G)),R.ONE),K=R.inv(H);return E.reduceRight((W,G,Z)=>R.is0(G)?W:(U[Z]=R.mul(W,U[Z]),R.mul(W,G)),K),U}function nLength(R,E){const U=E!==void 0?E:R.toString(2).length,H=Math.ceil(U/8);return{nBitLength:U,nByteLength:H}}function Field(R,E,U=!1,H={}){if(R<=_0n$3)throw new Error("invalid field: expected ORDER > 0, got "+R);const{nBitLength:K,nByteLength:W}=nLength(R,E);if(W>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let G;const Z=Object.freeze({ORDER:R,BITS:K,BYTES:W,MASK:bitMask(K),ZERO:_0n$3,ONE:_1n$3,create:Y=>mod(Y,R),isValid:Y=>{if(typeof Y!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof Y);return _0n$3<=Y&&Y<R},is0:Y=>Y===_0n$3,isOdd:Y=>(Y&_1n$3)===_1n$3,neg:Y=>mod(-Y,R),eql:(Y,X)=>Y===X,sqr:Y=>mod(Y*Y,R),add:(Y,X)=>mod(Y+X,R),sub:(Y,X)=>mod(Y-X,R),mul:(Y,X)=>mod(Y*X,R),pow:(Y,X)=>FpPow(Z,Y,X),div:(Y,X)=>mod(Y*invert(X,R),R),sqrN:Y=>Y*Y,addN:(Y,X)=>Y+X,subN:(Y,X)=>Y-X,mulN:(Y,X)=>Y*X,inv:Y=>invert(Y,R),sqrt:H.sqrt||(Y=>(G||(G=FpSqrt(R)),G(Z,Y))),invertBatch:Y=>FpInvertBatch(Z,Y),cmov:(Y,X,Q)=>Q?X:Y,toBytes:Y=>U?numberToBytesLE(Y,W):numberToBytesBE(Y,W),fromBytes:Y=>{if(Y.length!==W)throw new Error("Field.fromBytes: expected "+W+" bytes, got "+Y.length);return U?bytesToNumberLE(Y):bytesToNumberBE(Y)}});return Object.freeze(Z)}function getFieldBytesLength(R){if(typeof R!="bigint")throw new Error("field order must be bigint");const E=R.toString(2).length;return Math.ceil(E/8)}function getMinHashLength(R){const E=getFieldBytesLength(R);return E+Math.ceil(E/2)}function mapHashToField(R,E,U=!1){const H=R.length,K=getFieldBytesLength(E),W=getMinHashLength(E);if(H<16||H<W||H>1024)throw new Error("expected "+W+"-1024 bytes of input, got "+H);const G=U?bytesToNumberBE(R):bytesToNumberLE(R),Z=mod(G,E-_1n$3)+_1n$3;return U?numberToBytesLE(Z,K):numberToBytesBE(Z,K)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const _0n$2=BigInt(0),_1n$2=BigInt(1);function constTimeNegate(R,E){const U=E.negate();return R?U:E}function validateW(R,E){if(!Number.isSafeInteger(R)||R<=0||R>E)throw new Error("invalid window size, expected [1.."+E+"], got W="+R)}function calcWOpts(R,E){validateW(R,E);const U=Math.ceil(E/R)+1,H=2**(R-1);return{windows:U,windowSize:H}}function validateMSMPoints(R,E){if(!Array.isArray(R))throw new Error("array expected");R.forEach((U,H)=>{if(!(U instanceof E))throw new Error("invalid point at index "+H)})}function validateMSMScalars(R,E){if(!Array.isArray(R))throw new Error("array of scalars expected");R.forEach((U,H)=>{if(!E.isValid(U))throw new Error("invalid scalar at index "+H)})}const pointPrecomputes=new WeakMap,pointWindowSizes=new WeakMap;function getW(R){return pointWindowSizes.get(R)||1}function wNAF(R,E){return{constTimeNegate,hasPrecomputes(U){return getW(U)!==1},unsafeLadder(U,H,K=R.ZERO){let W=U;for(;H>_0n$2;)H&_1n$2&&(K=K.add(W)),W=W.double(),H>>=_1n$2;return K},precomputeWindow(U,H){const{windows:K,windowSize:W}=calcWOpts(H,E),G=[];let Z=U,Y=Z;for(let X=0;X<K;X++){Y=Z,G.push(Y);for(let Q=1;Q<W;Q++)Y=Y.add(Z),G.push(Y);Z=Y.double()}return G},wNAF(U,H,K){const{windows:W,windowSize:G}=calcWOpts(U,E);let Z=R.ZERO,Y=R.BASE;const X=BigInt(2**U-1),Q=2**U,J=BigInt(U);for(let ne=0;ne<W;ne++){const re=ne*G;let ae=Number(K&X);K>>=J,ae>G&&(ae-=Q,K+=_1n$2);const te=re,se=re+Math.abs(ae)-1,ie=ne%2!==0,ye=ae<0;ae===0?Y=Y.add(constTimeNegate(ie,H[te])):Z=Z.add(constTimeNegate(ye,H[se]))}return{p:Z,f:Y}},wNAFUnsafe(U,H,K,W=R.ZERO){const{windows:G,windowSize:Z}=calcWOpts(U,E),Y=BigInt(2**U-1),X=2**U,Q=BigInt(U);for(let J=0;J<G;J++){const ne=J*Z;if(K===_0n$2)break;let re=Number(K&Y);if(K>>=Q,re>Z&&(re-=X,K+=_1n$2),re===0)continue;let ae=H[ne+Math.abs(re)-1];re<0&&(ae=ae.negate()),W=W.add(ae)}return W},getPrecomputes(U,H,K){let W=pointPrecomputes.get(H);return W||(W=this.precomputeWindow(H,U),U!==1&&pointPrecomputes.set(H,K(W))),W},wNAFCached(U,H,K){const W=getW(U);return this.wNAF(W,this.getPrecomputes(W,U,K),H)},wNAFCachedUnsafe(U,H,K,W){const G=getW(U);return G===1?this.unsafeLadder(U,H,W):this.wNAFUnsafe(G,this.getPrecomputes(G,U,K),H,W)},setWindowSize(U,H){validateW(H,E),pointWindowSizes.set(U,H),pointPrecomputes.delete(U)}}}function pippenger(R,E,U,H){if(validateMSMPoints(U,R),validateMSMScalars(H,E),U.length!==H.length)throw new Error("arrays of points and scalars must have equal length");const K=R.ZERO,W=bitLen(BigInt(U.length)),G=W>12?W-3:W>4?W-2:W?2:1,Z=(1<<G)-1,Y=new Array(Z+1).fill(K),X=Math.floor((E.BITS-1)/G)*G;let Q=K;for(let J=X;J>=0;J-=G){Y.fill(K);for(let re=0;re<H.length;re++){const ae=H[re],te=Number(ae>>BigInt(J)&BigInt(Z));Y[te]=Y[te].add(U[re])}let ne=K;for(let re=Y.length-1,ae=K;re>0;re--)ae=ae.add(Y[re]),ne=ne.add(ae);if(Q=Q.add(ne),J!==0)for(let re=0;re<G;re++)Q=Q.double()}return Q}function validateBasic(R){return validateField(R.Fp),validateObject(R,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...nLength(R.n,R.nBitLength),...R,p:R.Fp.ORDER})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function validateSigVerOpts(R){R.lowS!==void 0&&abool("lowS",R.lowS),R.prehash!==void 0&&abool("prehash",R.prehash)}function validatePointOpts(R){const E=validateBasic(R);validateObject(E,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:U,Fp:H,a:K}=E;if(U){if(!H.eql(K,H.ZERO))throw new Error("invalid endomorphism, can only be defined for Koblitz curves that have a=0");if(typeof U!="object"||typeof U.beta!="bigint"||typeof U.splitScalar!="function")throw new Error("invalid endomorphism, expected beta: bigint and splitScalar: function")}return Object.freeze({...E})}const{bytesToNumberBE:b2n,hexToBytes:h2b}=ut,DER={Err:class extends Error{constructor(E=""){super(E)}},_tlv:{encode:(R,E)=>{const{Err:U}=DER;if(R<0||R>256)throw new U("tlv.encode: wrong tag");if(E.length&1)throw new U("tlv.encode: unpadded data");const H=E.length/2,K=numberToHexUnpadded(H);if(K.length/2&128)throw new U("tlv.encode: long form length too big");const W=H>127?numberToHexUnpadded(K.length/2|128):"";return numberToHexUnpadded(R)+W+K+E},decode(R,E){const{Err:U}=DER;let H=0;if(R<0||R>256)throw new U("tlv.encode: wrong tag");if(E.length<2||E[H++]!==R)throw new U("tlv.decode: wrong tlv");const K=E[H++],W=!!(K&128);let G=0;if(!W)G=K;else{const Y=K&127;if(!Y)throw new U("tlv.decode(long): indefinite length not supported");if(Y>4)throw new U("tlv.decode(long): byte length is too big");const X=E.subarray(H,H+Y);if(X.length!==Y)throw new U("tlv.decode: length bytes not complete");if(X[0]===0)throw new U("tlv.decode(long): zero leftmost byte");for(const Q of X)G=G<<8|Q;if(H+=Y,G<128)throw new U("tlv.decode(long): not minimal encoding")}const Z=E.subarray(H,H+G);if(Z.length!==G)throw new U("tlv.decode: wrong value length");return{v:Z,l:E.subarray(H+G)}}},_int:{encode(R){const{Err:E}=DER;if(R<_0n$1)throw new E("integer: negative integers are not allowed");let U=numberToHexUnpadded(R);if(Number.parseInt(U[0],16)&8&&(U="00"+U),U.length&1)throw new E("unexpected DER parsing assertion: unpadded hex");return U},decode(R){const{Err:E}=DER;if(R[0]&128)throw new E("invalid signature integer: negative");if(R[0]===0&&!(R[1]&128))throw new E("invalid signature integer: unnecessary leading zero");return b2n(R)}},toSig(R){const{Err:E,_int:U,_tlv:H}=DER,K=typeof R=="string"?h2b(R):R;abytes(K);const{v:W,l:G}=H.decode(48,K);if(G.length)throw new E("invalid signature: left bytes after parsing");const{v:Z,l:Y}=H.decode(2,W),{v:X,l:Q}=H.decode(2,Y);if(Q.length)throw new E("invalid signature: left bytes after parsing");return{r:U.decode(Z),s:U.decode(X)}},hexFromSig(R){const{_tlv:E,_int:U}=DER,H=E.encode(2,U.encode(R.r)),K=E.encode(2,U.encode(R.s)),W=H+K;return E.encode(48,W)}},_0n$1=BigInt(0),_1n$1=BigInt(1);BigInt(2);const _3n=BigInt(3);BigInt(4);function weierstrassPoints(R){const E=validatePointOpts(R),{Fp:U}=E,H=Field(E.n,E.nBitLength),K=E.toBytes||((te,se,ie)=>{const ye=se.toAffine();return concatBytes(Uint8Array.from([4]),U.toBytes(ye.x),U.toBytes(ye.y))}),W=E.fromBytes||(te=>{const se=te.subarray(1),ie=U.fromBytes(se.subarray(0,U.BYTES)),ye=U.fromBytes(se.subarray(U.BYTES,2*U.BYTES));return{x:ie,y:ye}});function G(te){const{a:se,b:ie}=E,ye=U.sqr(te),me=U.mul(ye,te);return U.add(U.add(me,U.mul(te,se)),ie)}if(!U.eql(U.sqr(E.Gy),G(E.Gx)))throw new Error("bad generator point: equation left != right");function Z(te){return inRange(te,_1n$1,E.n)}function Y(te){const{allowedPrivateKeyLengths:se,nByteLength:ie,wrapPrivateKey:ye,n:me}=E;if(se&&typeof te!="bigint"){if(isBytes$1(te)&&(te=bytesToHex(te)),typeof te!="string"||!se.includes(te.length))throw new Error("invalid private key");te=te.padStart(ie*2,"0")}let _e;try{_e=typeof te=="bigint"?te:bytesToNumberBE(ensureBytes("private key",te,ie))}catch{throw new Error("invalid private key, expected hex or "+ie+" bytes, got "+typeof te)}return ye&&(_e=mod(_e,me)),aInRange("private key",_e,_1n$1,me),_e}function X(te){if(!(te instanceof ne))throw new Error("ProjectivePoint expected")}const Q=memoized((te,se)=>{const{px:ie,py:ye,pz:me}=te;if(U.eql(me,U.ONE))return{x:ie,y:ye};const _e=te.is0();se==null&&(se=_e?U.ONE:U.inv(me));const oe=U.mul(ie,se),ue=U.mul(ye,se),he=U.mul(me,se);if(_e)return{x:U.ZERO,y:U.ZERO};if(!U.eql(he,U.ONE))throw new Error("invZ was invalid");return{x:oe,y:ue}}),J=memoized(te=>{if(te.is0()){if(E.allowInfinityPoint&&!U.is0(te.py))return;throw new Error("bad point: ZERO")}const{x:se,y:ie}=te.toAffine();if(!U.isValid(se)||!U.isValid(ie))throw new Error("bad point: x or y not FE");const ye=U.sqr(ie),me=G(se);if(!U.eql(ye,me))throw new Error("bad point: equation left != right");if(!te.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class ne{constructor(se,ie,ye){if(this.px=se,this.py=ie,this.pz=ye,se==null||!U.isValid(se))throw new Error("x required");if(ie==null||!U.isValid(ie))throw new Error("y required");if(ye==null||!U.isValid(ye))throw new Error("z required");Object.freeze(this)}static fromAffine(se){const{x:ie,y:ye}=se||{};if(!se||!U.isValid(ie)||!U.isValid(ye))throw new Error("invalid affine point");if(se instanceof ne)throw new Error("projective point not allowed");const me=_e=>U.eql(_e,U.ZERO);return me(ie)&&me(ye)?ne.ZERO:new ne(ie,ye,U.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(se){const ie=U.invertBatch(se.map(ye=>ye.pz));return se.map((ye,me)=>ye.toAffine(ie[me])).map(ne.fromAffine)}static fromHex(se){const ie=ne.fromAffine(W(ensureBytes("pointHex",se)));return ie.assertValidity(),ie}static fromPrivateKey(se){return ne.BASE.multiply(Y(se))}static msm(se,ie){return pippenger(ne,H,se,ie)}_setWindowSize(se){ae.setWindowSize(this,se)}assertValidity(){J(this)}hasEvenY(){const{y:se}=this.toAffine();if(U.isOdd)return!U.isOdd(se);throw new Error("Field doesn't support isOdd")}equals(se){X(se);const{px:ie,py:ye,pz:me}=this,{px:_e,py:oe,pz:ue}=se,he=U.eql(U.mul(ie,ue),U.mul(_e,me)),we=U.eql(U.mul(ye,ue),U.mul(oe,me));return he&&we}negate(){return new ne(this.px,U.neg(this.py),this.pz)}double(){const{a:se,b:ie}=E,ye=U.mul(ie,_3n),{px:me,py:_e,pz:oe}=this;let ue=U.ZERO,he=U.ZERO,we=U.ZERO,xe=U.mul(me,me),ke=U.mul(_e,_e),ce=U.mul(oe,oe),pe=U.mul(me,_e);return pe=U.add(pe,pe),we=U.mul(me,oe),we=U.add(we,we),ue=U.mul(se,we),he=U.mul(ye,ce),he=U.add(ue,he),ue=U.sub(ke,he),he=U.add(ke,he),he=U.mul(ue,he),ue=U.mul(pe,ue),we=U.mul(ye,we),ce=U.mul(se,ce),pe=U.sub(xe,ce),pe=U.mul(se,pe),pe=U.add(pe,we),we=U.add(xe,xe),xe=U.add(we,xe),xe=U.add(xe,ce),xe=U.mul(xe,pe),he=U.add(he,xe),ce=U.mul(_e,oe),ce=U.add(ce,ce),xe=U.mul(ce,pe),ue=U.sub(ue,xe),we=U.mul(ce,ke),we=U.add(we,we),we=U.add(we,we),new ne(ue,he,we)}add(se){X(se);const{px:ie,py:ye,pz:me}=this,{px:_e,py:oe,pz:ue}=se;let he=U.ZERO,we=U.ZERO,xe=U.ZERO;const ke=E.a,ce=U.mul(E.b,_3n);let pe=U.mul(ie,_e),ve=U.mul(ye,oe),Ee=U.mul(me,ue),de=U.add(ie,ye),be=U.add(_e,oe);de=U.mul(de,be),be=U.add(pe,ve),de=U.sub(de,be),be=U.add(ie,me);let $e=U.add(_e,ue);return be=U.mul(be,$e),$e=U.add(pe,Ee),be=U.sub(be,$e),$e=U.add(ye,me),he=U.add(oe,ue),$e=U.mul($e,he),he=U.add(ve,Ee),$e=U.sub($e,he),xe=U.mul(ke,be),he=U.mul(ce,Ee),xe=U.add(he,xe),he=U.sub(ve,xe),xe=U.add(ve,xe),we=U.mul(he,xe),ve=U.add(pe,pe),ve=U.add(ve,pe),Ee=U.mul(ke,Ee),be=U.mul(ce,be),ve=U.add(ve,Ee),Ee=U.sub(pe,Ee),Ee=U.mul(ke,Ee),be=U.add(be,Ee),pe=U.mul(ve,be),we=U.add(we,pe),pe=U.mul($e,be),he=U.mul(de,he),he=U.sub(he,pe),pe=U.mul(de,ve),xe=U.mul($e,xe),xe=U.add(xe,pe),new ne(he,we,xe)}subtract(se){return this.add(se.negate())}is0(){return this.equals(ne.ZERO)}wNAF(se){return ae.wNAFCached(this,se,ne.normalizeZ)}multiplyUnsafe(se){const{endo:ie,n:ye}=E;aInRange("scalar",se,_0n$1,ye);const me=ne.ZERO;if(se===_0n$1)return me;if(this.is0()||se===_1n$1)return this;if(!ie||ae.hasPrecomputes(this))return ae.wNAFCachedUnsafe(this,se,ne.normalizeZ);let{k1neg:_e,k1:oe,k2neg:ue,k2:he}=ie.splitScalar(se),we=me,xe=me,ke=this;for(;oe>_0n$1||he>_0n$1;)oe&_1n$1&&(we=we.add(ke)),he&_1n$1&&(xe=xe.add(ke)),ke=ke.double(),oe>>=_1n$1,he>>=_1n$1;return _e&&(we=we.negate()),ue&&(xe=xe.negate()),xe=new ne(U.mul(xe.px,ie.beta),xe.py,xe.pz),we.add(xe)}multiply(se){const{endo:ie,n:ye}=E;aInRange("scalar",se,_1n$1,ye);let me,_e;if(ie){const{k1neg:oe,k1:ue,k2neg:he,k2:we}=ie.splitScalar(se);let{p:xe,f:ke}=this.wNAF(ue),{p:ce,f:pe}=this.wNAF(we);xe=ae.constTimeNegate(oe,xe),ce=ae.constTimeNegate(he,ce),ce=new ne(U.mul(ce.px,ie.beta),ce.py,ce.pz),me=xe.add(ce),_e=ke.add(pe)}else{const{p:oe,f:ue}=this.wNAF(se);me=oe,_e=ue}return ne.normalizeZ([me,_e])[0]}multiplyAndAddUnsafe(se,ie,ye){const me=ne.BASE,_e=(ue,he)=>he===_0n$1||he===_1n$1||!ue.equals(me)?ue.multiplyUnsafe(he):ue.multiply(he),oe=_e(this,ie).add(_e(se,ye));return oe.is0()?void 0:oe}toAffine(se){return Q(this,se)}isTorsionFree(){const{h:se,isTorsionFree:ie}=E;if(se===_1n$1)return!0;if(ie)return ie(ne,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:se,clearCofactor:ie}=E;return se===_1n$1?this:ie?ie(ne,this):this.multiplyUnsafe(E.h)}toRawBytes(se=!0){return abool("isCompressed",se),this.assertValidity(),K(ne,this,se)}toHex(se=!0){return abool("isCompressed",se),bytesToHex(this.toRawBytes(se))}}ne.BASE=new ne(E.Gx,E.Gy,U.ONE),ne.ZERO=new ne(U.ZERO,U.ONE,U.ZERO);const re=E.nBitLength,ae=wNAF(ne,E.endo?Math.ceil(re/2):re);return{CURVE:E,ProjectivePoint:ne,normPrivateKeyToScalar:Y,weierstrassEquation:G,isWithinCurveOrder:Z}}function validateOpts(R){const E=validateBasic(R);return validateObject(E,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...E})}function weierstrass(R){const E=validateOpts(R),{Fp:U,n:H}=E,K=U.BYTES+1,W=2*U.BYTES+1;function G(Ee){return mod(Ee,H)}function Z(Ee){return invert(Ee,H)}const{ProjectivePoint:Y,normPrivateKeyToScalar:X,weierstrassEquation:Q,isWithinCurveOrder:J}=weierstrassPoints({...E,toBytes(Ee,de,be){const $e=de.toAffine(),Ae=U.toBytes($e.x),Re=concatBytes;return abool("isCompressed",be),be?Re(Uint8Array.from([de.hasEvenY()?2:3]),Ae):Re(Uint8Array.from([4]),Ae,U.toBytes($e.y))},fromBytes(Ee){const de=Ee.length,be=Ee[0],$e=Ee.subarray(1);if(de===K&&(be===2||be===3)){const Ae=bytesToNumberBE($e);if(!inRange(Ae,_1n$1,U.ORDER))throw new Error("Point is not on curve");const Re=Q(Ae);let Ce;try{Ce=U.sqrt(Re)}catch(Ne){const Ie=Ne instanceof Error?": "+Ne.message:"";throw new Error("Point is not on curve"+Ie)}const Se=(Ce&_1n$1)===_1n$1;return(be&1)===1!==Se&&(Ce=U.neg(Ce)),{x:Ae,y:Ce}}else if(de===W&&be===4){const Ae=U.fromBytes($e.subarray(0,U.BYTES)),Re=U.fromBytes($e.subarray(U.BYTES,2*U.BYTES));return{x:Ae,y:Re}}else{const Ae=K,Re=W;throw new Error("invalid Point, expected length of "+Ae+", or uncompressed "+Re+", got "+de)}}}),ne=Ee=>bytesToHex(numberToBytesBE(Ee,E.nByteLength));function re(Ee){const de=H>>_1n$1;return Ee>de}function ae(Ee){return re(Ee)?G(-Ee):Ee}const te=(Ee,de,be)=>bytesToNumberBE(Ee.slice(de,be));class se{constructor(de,be,$e){this.r=de,this.s=be,this.recovery=$e,this.assertValidity()}static fromCompact(de){const be=E.nByteLength;return de=ensureBytes("compactSignature",de,be*2),new se(te(de,0,be),te(de,be,2*be))}static fromDER(de){const{r:be,s:$e}=DER.toSig(ensureBytes("DER",de));return new se(be,$e)}assertValidity(){aInRange("r",this.r,_1n$1,H),aInRange("s",this.s,_1n$1,H)}addRecoveryBit(de){return new se(this.r,this.s,de)}recoverPublicKey(de){const{r:be,s:$e,recovery:Ae}=this,Re=ue(ensureBytes("msgHash",de));if(Ae==null||![0,1,2,3].includes(Ae))throw new Error("recovery id invalid");const Ce=Ae===2||Ae===3?be+E.n:be;if(Ce>=U.ORDER)throw new Error("recovery id 2 or 3 invalid");const Se=Ae&1?"03":"02",Te=Y.fromHex(Se+ne(Ce)),Ne=Z(Ce),Ie=G(-Re*Ne),Be=G($e*Ne),Le=Y.BASE.multiplyAndAddUnsafe(Te,Ie,Be);if(!Le)throw new Error("point at infinify");return Le.assertValidity(),Le}hasHighS(){return re(this.s)}normalizeS(){return this.hasHighS()?new se(this.r,G(-this.s),this.recovery):this}toDERRawBytes(){return hexToBytes(this.toDERHex())}toDERHex(){return DER.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return hexToBytes(this.toCompactHex())}toCompactHex(){return ne(this.r)+ne(this.s)}}const ie={isValidPrivateKey(Ee){try{return X(Ee),!0}catch{return!1}},normPrivateKeyToScalar:X,randomPrivateKey:()=>{const Ee=getMinHashLength(E.n);return mapHashToField(E.randomBytes(Ee),E.n)},precompute(Ee=8,de=Y.BASE){return de._setWindowSize(Ee),de.multiply(BigInt(3)),de}};function ye(Ee,de=!0){return Y.fromPrivateKey(Ee).toRawBytes(de)}function me(Ee){const de=isBytes$1(Ee),be=typeof Ee=="string",$e=(de||be)&&Ee.length;return de?$e===K||$e===W:be?$e===2*K||$e===2*W:Ee instanceof Y}function _e(Ee,de,be=!0){if(me(Ee))throw new Error("first arg must be private key");if(!me(de))throw new Error("second arg must be public key");return Y.fromHex(de).multiply(X(Ee)).toRawBytes(be)}const oe=E.bits2int||function(Ee){if(Ee.length>8192)throw new Error("input is too large");const de=bytesToNumberBE(Ee),be=Ee.length*8-E.nBitLength;return be>0?de>>BigInt(be):de},ue=E.bits2int_modN||function(Ee){return G(oe(Ee))},he=bitMask(E.nBitLength);function we(Ee){return aInRange("num < 2^"+E.nBitLength,Ee,_0n$1,he),numberToBytesBE(Ee,E.nByteLength)}function xe(Ee,de,be=ke){if(["recovered","canonical"].some(Me=>Me in be))throw new Error("sign() legacy options not supported");const{hash:$e,randomBytes:Ae}=E;let{lowS:Re,prehash:Ce,extraEntropy:Se}=be;Re==null&&(Re=!0),Ee=ensureBytes("msgHash",Ee),validateSigVerOpts(be),Ce&&(Ee=ensureBytes("prehashed msgHash",$e(Ee)));const Te=ue(Ee),Ne=X(de),Ie=[we(Ne),we(Te)];if(Se!=null&&Se!==!1){const Me=Se===!0?Ae(U.BYTES):Se;Ie.push(ensureBytes("extraEntropy",Me))}const Be=concatBytes(...Ie),Le=Te;function Ue(Me){const De=oe(Me);if(!J(De))return;const He=Z(De),qe=Y.BASE.multiply(De).toAffine(),Fe=G(qe.x);if(Fe===_0n$1)return;const Pe=G(He*G(Le+Fe*Ne));if(Pe===_0n$1)return;let Oe=(qe.x===Fe?0:2)|Number(qe.y&_1n$1),Ke=Pe;return Re&&re(Pe)&&(Ke=ae(Pe),Oe^=1),new se(Fe,Ke,Oe)}return{seed:Be,k2sig:Ue}}const ke={lowS:E.lowS,prehash:!1},ce={lowS:E.lowS,prehash:!1};function pe(Ee,de,be=ke){const{seed:$e,k2sig:Ae}=xe(Ee,de,be),Re=E;return createHmacDrbg(Re.hash.outputLen,Re.nByteLength,Re.hmac)($e,Ae)}Y.BASE._setWindowSize(8);function ve(Ee,de,be,$e=ce){var Oe;const Ae=Ee;de=ensureBytes("msgHash",de),be=ensureBytes("publicKey",be);const{lowS:Re,prehash:Ce,format:Se}=$e;if(validateSigVerOpts($e),"strict"in $e)throw new Error("options.strict was renamed to lowS");if(Se!==void 0&&Se!=="compact"&&Se!=="der")throw new Error("format must be compact or der");const Te=typeof Ae=="string"||isBytes$1(Ae),Ne=!Te&&!Se&&typeof Ae=="object"&&Ae!==null&&typeof Ae.r=="bigint"&&typeof Ae.s=="bigint";if(!Te&&!Ne)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let Ie,Be;try{if(Ne&&(Ie=new se(Ae.r,Ae.s)),Te){try{Se!=="compact"&&(Ie=se.fromDER(Ae))}catch(Ke){if(!(Ke instanceof DER.Err))throw Ke}!Ie&&Se!=="der"&&(Ie=se.fromCompact(Ae))}Be=Y.fromHex(be)}catch{return!1}if(!Ie||Re&&Ie.hasHighS())return!1;Ce&&(de=E.hash(de));const{r:Le,s:Ue}=Ie,Me=ue(de),De=Z(Ue),He=G(Me*De),qe=G(Le*De),Fe=(Oe=Y.BASE.multiplyAndAddUnsafe(Be,He,qe))==null?void 0:Oe.toAffine();return Fe?G(Fe.x)===Le:!1}return{CURVE:E,getPublicKey:ye,getSharedSecret:_e,sign:pe,verify:ve,ProjectivePoint:Y,Signature:se,utils:ie}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function getHash(R){return{hash:R,hmac:(E,...U)=>hmac(R,E,concatBytes$1(...U)),randomBytes}}function createCurve(R,E){const U=H=>weierstrass({...R,...getHash(H)});return Object.freeze({...U(E),create:U})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const secp256k1P=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),secp256k1N=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),_1n=BigInt(1),_2n=BigInt(2),divNearest=(R,E)=>(R+E/_2n)/E;function sqrtMod(R){const E=secp256k1P,U=BigInt(3),H=BigInt(6),K=BigInt(11),W=BigInt(22),G=BigInt(23),Z=BigInt(44),Y=BigInt(88),X=R*R*R%E,Q=X*X*R%E,J=pow2(Q,U,E)*Q%E,ne=pow2(J,U,E)*Q%E,re=pow2(ne,_2n,E)*X%E,ae=pow2(re,K,E)*re%E,te=pow2(ae,W,E)*ae%E,se=pow2(te,Z,E)*te%E,ie=pow2(se,Y,E)*se%E,ye=pow2(ie,Z,E)*te%E,me=pow2(ye,U,E)*Q%E,_e=pow2(me,G,E)*ae%E,oe=pow2(_e,H,E)*X%E,ue=pow2(oe,_2n,E);if(!Fpk1.eql(Fpk1.sqr(ue),R))throw new Error("Cannot find square root");return ue}const Fpk1=Field(secp256k1P,void 0,void 0,{sqrt:sqrtMod}),secp256k1=createCurve({a:BigInt(0),b:BigInt(7),Fp:Fpk1,n:secp256k1N,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:R=>{const E=secp256k1N,U=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),H=-_1n*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),K=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),W=U,G=BigInt("0x100000000000000000000000000000000"),Z=divNearest(W*R,E),Y=divNearest(-H*R,E);let X=mod(R-Z*U-Y*K,E),Q=mod(-Z*H-Y*W,E);const J=X>G,ne=Q>G;if(J&&(X=E-X),ne&&(Q=E-Q),X>G||Q>G)throw new Error("splitScalar: Endomorphism failed, k="+R);return{k1neg:J,k1:X,k2neg:ne,k2:Q}}}},sha256),_0n=BigInt(0),TAGGED_HASH_PREFIXES={};function taggedHash(R,...E){let U=TAGGED_HASH_PREFIXES[R];if(U===void 0){const H=sha256(Uint8Array.from(R,K=>K.charCodeAt(0)));U=concatBytes(H,H),TAGGED_HASH_PREFIXES[R]=U}return sha256(concatBytes(U,...E))}const pointToBytes=R=>R.toRawBytes(!0).slice(1),numTo32b=R=>numberToBytesBE(R,32),modP=R=>mod(R,secp256k1P),modN=R=>mod(R,secp256k1N),Point=secp256k1.ProjectivePoint,GmulAdd=(R,E,U)=>Point.BASE.multiplyAndAddUnsafe(R,E,U);function schnorrGetExtPubKey(R){let E=secp256k1.utils.normPrivateKeyToScalar(R),U=Point.fromPrivateKey(E);return{scalar:U.hasEvenY()?E:modN(-E),bytes:pointToBytes(U)}}function lift_x(R){aInRange("x",R,_1n,secp256k1P);const E=modP(R*R),U=modP(E*R+BigInt(7));let H=sqrtMod(U);H%_2n!==_0n&&(H=modP(-H));const K=new Point(R,H,_1n);return K.assertValidity(),K}const num=bytesToNumberBE;function challenge(...R){return modN(num(taggedHash("BIP0340/challenge",...R)))}function schnorrGetPublicKey(R){return schnorrGetExtPubKey(R).bytes}function schnorrSign(R,E,U=randomBytes(32)){const H=ensureBytes("message",R),{bytes:K,scalar:W}=schnorrGetExtPubKey(E),G=ensureBytes("auxRand",U,32),Z=numTo32b(W^num(taggedHash("BIP0340/aux",G))),Y=taggedHash("BIP0340/nonce",Z,K,H),X=modN(num(Y));if(X===_0n)throw new Error("sign failed: k is zero");const{bytes:Q,scalar:J}=schnorrGetExtPubKey(X),ne=challenge(Q,K,H),re=new Uint8Array(64);if(re.set(Q,0),re.set(numTo32b(modN(J+ne*W)),32),!schnorrVerify(re,H,K))throw new Error("sign: Invalid signature produced");return re}function schnorrVerify(R,E,U){const H=ensureBytes("signature",R,64),K=ensureBytes("message",E),W=ensureBytes("publicKey",U,32);try{const G=lift_x(num(W)),Z=num(H.subarray(0,32));if(!inRange(Z,_1n,secp256k1P))return!1;const Y=num(H.subarray(32,64));if(!inRange(Y,_1n,secp256k1N))return!1;const X=challenge(numTo32b(Z),pointToBytes(G),K),Q=GmulAdd(G,Y,modN(-X));return!(!Q||!Q.hasEvenY()||Q.toAffine().x!==Z)}catch{return!1}}const schnorr={getPublicKey:schnorrGetPublicKey,sign:schnorrSign,verify:schnorrVerify,utils:{randomPrivateKey:secp256k1.utils.randomPrivateKey,lift_x,pointToBytes,numberToBytesBE,bytesToNumberBE,taggedHash,mod}};var dist={},LRUCache={},LRUCacheNode={},hasRequiredLRUCacheNode;function requireLRUCacheNode(){if(hasRequiredLRUCacheNode)return LRUCacheNode;hasRequiredLRUCacheNode=1,Object.defineProperty(LRUCacheNode,"__esModule",{value:!0}),LRUCacheNode.LRUCacheNode=void 0;let R=class{constructor(U,H,K){const{entryExpirationTimeInMS:W=null,next:G=null,prev:Z=null,onEntryEvicted:Y,onEntryMarkedAsMostRecentlyUsed:X,clone:Q,cloneFn:J}=K??{};if(typeof W=="number"&&(W<=0||Number.isNaN(W)))throw new Error("entryExpirationTimeInMS must either be null (no expiry) or greater than 0");this.clone=Q??!1,this.cloneFn=J??this.defaultClone,this.key=U,this.internalValue=this.clone?this.cloneFn(H):H,this.created=Date.now(),this.entryExpirationTimeInMS=W,this.next=G,this.prev=Z,this.onEntryEvicted=Y,this.onEntryMarkedAsMostRecentlyUsed=X}get value(){return this.clone?this.cloneFn(this.internalValue):this.internalValue}get isExpired(){return typeof this.entryExpirationTimeInMS=="number"&&Date.now()-this.created>this.entryExpirationTimeInMS}invokeOnEvicted(){if(this.onEntryEvicted){const{key:U,value:H,isExpired:K}=this;this.onEntryEvicted({key:U,value:H,isExpired:K})}}invokeOnEntryMarkedAsMostRecentlyUsed(){if(this.onEntryMarkedAsMostRecentlyUsed){const{key:U,value:H}=this;this.onEntryMarkedAsMostRecentlyUsed({key:U,value:H})}}defaultClone(U){return typeof U=="boolean"||typeof U=="string"||typeof U=="number"?U:JSON.parse(JSON.stringify(U))}};return LRUCacheNode.LRUCacheNode=R,LRUCacheNode}var hasRequiredLRUCache;function requireLRUCache(){if(hasRequiredLRUCache)return LRUCache;hasRequiredLRUCache=1,Object.defineProperty(LRUCache,"__esModule",{value:!0}),LRUCache.LRUCache=void 0;const R=requireLRUCacheNode();let E=class{constructor(H){this.lookupTable=new Map,this.head=null,this.tail=null;const{maxSize:K=25,entryExpirationTimeInMS:W=null,onEntryEvicted:G,onEntryMarkedAsMostRecentlyUsed:Z,cloneFn:Y,clone:X}=H??{};if(Number.isNaN(K)||K<=0)throw new Error("maxSize must be greater than 0.");if(typeof W=="number"&&(W<=0||Number.isNaN(W)))throw new Error("entryExpirationTimeInMS must either be null (no expiry) or greater than 0");this.maxSizeInternal=K,this.entryExpirationTimeInMS=W,this.onEntryEvicted=G,this.onEntryMarkedAsMostRecentlyUsed=Z,this.clone=X,this.cloneFn=Y}get size(){return this.cleanCache(),this.lookupTable.size}get remainingSize(){return this.maxSizeInternal-this.size}get newest(){return this.head?this.head.isExpired?(this.removeNodeFromListAndLookupTable(this.head),this.newest):this.mapNodeToEntry(this.head):null}get oldest(){return this.tail?this.tail.isExpired?(this.removeNodeFromListAndLookupTable(this.tail),this.oldest):this.mapNodeToEntry(this.tail):null}get maxSize(){return this.maxSizeInternal}set maxSize(H){if(Number.isNaN(H)||H<=0)throw new Error("maxSize must be greater than 0.");this.maxSizeInternal=H,this.enforceSizeLimit()}set(H,K,W){const G=this.lookupTable.get(H);G&&this.removeNodeFromListAndLookupTable(G);const Z=new R.LRUCacheNode(H,K,{entryExpirationTimeInMS:this.entryExpirationTimeInMS,onEntryEvicted:this.onEntryEvicted,onEntryMarkedAsMostRecentlyUsed:this.onEntryMarkedAsMostRecentlyUsed,clone:this.clone,cloneFn:this.cloneFn,...W});return this.setNodeAsHead(Z),this.lookupTable.set(H,Z),this.enforceSizeLimit(),this}get(H){const K=this.lookupTable.get(H);return K?K.isExpired?(this.removeNodeFromListAndLookupTable(K),null):(this.setNodeAsHead(K),K.value):null}peek(H){const K=this.lookupTable.get(H);return K?K.isExpired?(this.removeNodeFromListAndLookupTable(K),null):K.value:null}delete(H){const K=this.lookupTable.get(H);return K?this.removeNodeFromListAndLookupTable(K):!1}has(H){const K=this.lookupTable.get(H);return K?K.isExpired?(this.removeNodeFromListAndLookupTable(K),!1):!0:!1}clear(){this.head=null,this.tail=null,this.lookupTable.clear()}find(H){let K=this.head;for(;K;){if(K.isExpired){const G=K.next;this.removeNodeFromListAndLookupTable(K),K=G;continue}const W=this.mapNodeToEntry(K);if(H(W))return this.setNodeAsHead(K),W;K=K.next}return null}forEach(H){let K=this.head,W=0;for(;K;){if(K.isExpired){const G=K.next;this.removeNodeFromListAndLookupTable(K),K=G;continue}H(K.value,K.key,W),K=K.next,W++}}*values(){let H=this.head;for(;H;){if(H.isExpired){const K=H.next;this.removeNodeFromListAndLookupTable(H),H=K;continue}yield H.value,H=H.next}}*keys(){let H=this.head;for(;H;){if(H.isExpired){const K=H.next;this.removeNodeFromListAndLookupTable(H),H=K;continue}yield H.key,H=H.next}}*entries(){let H=this.head;for(;H;){if(H.isExpired){const K=H.next;this.removeNodeFromListAndLookupTable(H),H=K;continue}yield this.mapNodeToEntry(H),H=H.next}}*[Symbol.iterator](){let H=this.head;for(;H;){if(H.isExpired){const K=H.next;this.removeNodeFromListAndLookupTable(H),H=K;continue}yield this.mapNodeToEntry(H),H=H.next}}enforceSizeLimit(){let H=this.tail;for(;H!==null&&this.size>this.maxSizeInternal;){const K=H.prev;this.removeNodeFromListAndLookupTable(H),H=K}}mapNodeToEntry({key:H,value:K}){return{key:H,value:K}}setNodeAsHead(H){this.removeNodeFromList(H),this.head?(H.next=this.head,this.head.prev=H,this.head=H):(this.head=H,this.tail=H),H.invokeOnEntryMarkedAsMostRecentlyUsed()}removeNodeFromList(H){H.prev!==null&&(H.prev.next=H.next),H.next!==null&&(H.next.prev=H.prev),this.head===H&&(this.head=H.next),this.tail===H&&(this.tail=H.prev),H.next=null,H.prev=null}removeNodeFromListAndLookupTable(H){return H.invokeOnEvicted(),this.removeNodeFromList(H),this.lookupTable.delete(H.key)}cleanCache(){if(!this.entryExpirationTimeInMS)return;const H=[];for(const K of this.lookupTable.values())K.isExpired&&H.push(K);H.forEach(K=>this.removeNodeFromListAndLookupTable(K))}};return LRUCache.LRUCache=E,LRUCache}var hasRequiredDist;function requireDist(){return hasRequiredDist||(hasRequiredDist=1,function(R){var E=dist&&dist.__createBinding||(Object.create?function(H,K,W,G){G===void 0&&(G=W);var Z=Object.getOwnPropertyDescriptor(K,W);(!Z||("get"in Z?!K.__esModule:Z.writable||Z.configurable))&&(Z={enumerable:!0,get:function(){return K[W]}}),Object.defineProperty(H,G,Z)}:function(H,K,W,G){G===void 0&&(G=W),H[G]=K[W]}),U=dist&&dist.__exportStar||function(H,K){for(var W in H)W!=="default"&&!Object.prototype.hasOwnProperty.call(K,W)&&E(K,H,W)};Object.defineProperty(R,"__esModule",{value:!0}),U(requireLRUCache(),R)}(dist)),dist}var distExports=requireDist();/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */function isBytes(R){return R instanceof Uint8Array||ArrayBuffer.isView(R)&&R.constructor.name==="Uint8Array"}function isArrayOf(R,E){return Array.isArray(E)?E.length===0?!0:R?E.every(U=>typeof U=="string"):E.every(U=>Number.isSafeInteger(U)):!1}function afn(R){if(typeof R!="function")throw new Error("function expected");return!0}function astr(R,E){if(typeof E!="string")throw new Error(`${R}: string expected`);return!0}function anumber(R){if(!Number.isSafeInteger(R))throw new Error(`invalid integer: ${R}`)}function aArr(R){if(!Array.isArray(R))throw new Error("array expected")}function astrArr(R,E){if(!isArrayOf(!0,E))throw new Error(`${R}: array of strings expected`)}function anumArr(R,E){if(!isArrayOf(!1,E))throw new Error(`${R}: array of numbers expected`)}function chain(...R){const E=W=>W,U=(W,G)=>Z=>W(G(Z)),H=R.map(W=>W.encode).reduceRight(U,E),K=R.map(W=>W.decode).reduce(U,E);return{encode:H,decode:K}}function alphabet(R){const E=typeof R=="string"?R.split(""):R,U=E.length;astrArr("alphabet",E);const H=new Map(E.map((K,W)=>[K,W]));return{encode:K=>(aArr(K),K.map(W=>{if(!Number.isSafeInteger(W)||W<0||W>=U)throw new Error(`alphabet.encode: digit index outside alphabet "${W}". Allowed: ${R}`);return E[W]})),decode:K=>(aArr(K),K.map(W=>{astr("alphabet.decode",W);const G=H.get(W);if(G===void 0)throw new Error(`Unknown letter: "${W}". Allowed: ${R}`);return G}))}}function join(R=""){return astr("join",R),{encode:E=>(astrArr("join.decode",E),E.join(R)),decode:E=>(astr("join.decode",E),E.split(R))}}const gcd=(R,E)=>E===0?R:gcd(E,R%E),radix2carry=(R,E)=>R+(E-gcd(R,E)),powers=(()=>{let R=[];for(let E=0;E<40;E++)R.push(2**E);return R})();function convertRadix2(R,E,U,H){if(aArr(R),E<=0||E>32)throw new Error(`convertRadix2: wrong from=${E}`);if(U<=0||U>32)throw new Error(`convertRadix2: wrong to=${U}`);if(radix2carry(E,U)>32)throw new Error(`convertRadix2: carry overflow from=${E} to=${U} carryBits=${radix2carry(E,U)}`);let K=0,W=0;const G=powers[E],Z=powers[U]-1,Y=[];for(const X of R){if(anumber(X),X>=G)throw new Error(`convertRadix2: invalid data word=${X} from=${E}`);if(K=K<<E|X,W+E>32)throw new Error(`convertRadix2: carry overflow pos=${W} from=${E}`);for(W+=E;W>=U;W-=U)Y.push((K>>W-U&Z)>>>0);const Q=powers[W];if(Q===void 0)throw new Error("invalid carry");K&=Q-1}if(K=K<<U-W&Z,!H&&W>=E)throw new Error("Excess padding");if(!H&&K>0)throw new Error(`Non-zero padding: ${K}`);return H&&W>0&&Y.push(K>>>0),Y}function radix2(R,E=!1){if(anumber(R),R<=0||R>32)throw new Error("radix2: bits should be in (0..32]");if(radix2carry(8,R)>32||radix2carry(R,8)>32)throw new Error("radix2: carry overflow");return{encode:U=>{if(!isBytes(U))throw new Error("radix2.encode input should be Uint8Array");return convertRadix2(Array.from(U),8,R,!E)},decode:U=>(anumArr("radix2.decode",U),Uint8Array.from(convertRadix2(U,R,8,E)))}}function unsafeWrapper(R){return afn(R),function(...E){try{return R.apply(null,E)}catch{}}}const BECH_ALPHABET=chain(alphabet("qpzry9x8gf2tvdw0s3jn54khce6mua7l"),join("")),POLYMOD_GENERATORS=[996825010,642813549,513874426,1027748829,705979059];function bech32Polymod(R){const E=R>>25;let U=(R&33554431)<<5;for(let H=0;H<POLYMOD_GENERATORS.length;H++)(E>>H&1)===1&&(U^=POLYMOD_GENERATORS[H]);return U}function bechChecksum(R,E,U=1){const H=R.length;let K=1;for(let W=0;W<H;W++){const G=R.charCodeAt(W);if(G<33||G>126)throw new Error(`Invalid prefix (${R})`);K=bech32Polymod(K)^G>>5}K=bech32Polymod(K);for(let W=0;W<H;W++)K=bech32Polymod(K)^R.charCodeAt(W)&31;for(let W of E)K=bech32Polymod(K)^W;for(let W=0;W<6;W++)K=bech32Polymod(K);return K^=U,BECH_ALPHABET.encode(convertRadix2([K%powers[30]],30,5,!1))}function genBech32(R){const E=R==="bech32"?1:734539939,U=radix2(5),H=U.decode,K=U.encode,W=unsafeWrapper(H);function G(J,ne,re=90){astr("bech32.encode prefix",J),isBytes(ne)&&(ne=Array.from(ne)),anumArr("bech32.encode",ne);const ae=J.length;if(ae===0)throw new TypeError(`Invalid prefix length ${ae}`);const te=ae+7+ne.length;if(re!==!1&&te>re)throw new TypeError(`Length ${te} exceeds limit ${re}`);const se=J.toLowerCase(),ie=bechChecksum(se,ne,E);return`${se}1${BECH_ALPHABET.encode(ne)}${ie}`}function Z(J,ne=90){astr("bech32.decode input",J);const re=J.length;if(re<8||ne!==!1&&re>ne)throw new TypeError(`invalid string length: ${re} (${J}). Expected (8..${ne})`);const ae=J.toLowerCase();if(J!==ae&&J!==J.toUpperCase())throw new Error("String must be lowercase or uppercase");const te=ae.lastIndexOf("1");if(te===0||te===-1)throw new Error('Letter "1" must be present between prefix and data only');const se=ae.slice(0,te),ie=ae.slice(te+1);if(ie.length<6)throw new Error("Data must be at least 6 characters long");const ye=BECH_ALPHABET.decode(ie).slice(0,-6),me=bechChecksum(se,ye,E);if(!ie.endsWith(me))throw new Error(`Invalid checksum in ${J}: expected "${me}"`);return{prefix:se,words:ye}}const Y=unsafeWrapper(Z);function X(J){const{prefix:ne,words:re}=Z(J,!1);return{prefix:ne,words:re,bytes:H(re)}}function Q(J,ne){return G(J,K(ne))}return{encode:G,decode:Z,encodeFromBytes:Q,decodeToBytes:X,decodeUnsafe:Y,fromWords:H,fromWordsUnsafe:W,toWords:K}}const bech32=genBech32("bech32");var lib={},hasRequiredLib;function requireLib(){return hasRequiredLib||(hasRequiredLib=1,function(R){/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */Object.defineProperty(R,"__esModule",{value:!0}),R.bytes=R.stringToBytes=R.str=R.bytesToString=R.hex=R.utf8=R.bech32m=R.bech32=R.base58check=R.base58xmr=R.base58xrp=R.base58flickr=R.base58=R.base64url=R.base64=R.base32crockford=R.base32hex=R.base32=R.base16=R.utils=R.assertNumber=void 0;function E(ce){if(!Number.isSafeInteger(ce))throw new Error(`Wrong integer: ${ce}`)}R.assertNumber=E;function U(...ce){const pe=(de,be)=>$e=>de(be($e)),ve=Array.from(ce).reverse().reduce((de,be)=>de?pe(de,be.encode):be.encode,void 0),Ee=ce.reduce((de,be)=>de?pe(de,be.decode):be.decode,void 0);return{encode:ve,decode:Ee}}function H(ce){return{encode:pe=>{if(!Array.isArray(pe)||pe.length&&typeof pe[0]!="number")throw new Error("alphabet.encode input should be an array of numbers");return pe.map(ve=>{if(E(ve),ve<0||ve>=ce.length)throw new Error(`Digit index outside alphabet: ${ve} (alphabet: ${ce.length})`);return ce[ve]})},decode:pe=>{if(!Array.isArray(pe)||pe.length&&typeof pe[0]!="string")throw new Error("alphabet.decode input should be array of strings");return pe.map(ve=>{if(typeof ve!="string")throw new Error(`alphabet.decode: not string element=${ve}`);const Ee=ce.indexOf(ve);if(Ee===-1)throw new Error(`Unknown letter: "${ve}". Allowed: ${ce}`);return Ee})}}}function K(ce=""){if(typeof ce!="string")throw new Error("join separator should be string");return{encode:pe=>{if(!Array.isArray(pe)||pe.length&&typeof pe[0]!="string")throw new Error("join.encode input should be array of strings");for(let ve of pe)if(typeof ve!="string")throw new Error(`join.encode: non-string input=${ve}`);return pe.join(ce)},decode:pe=>{if(typeof pe!="string")throw new Error("join.decode input should be string");return pe.split(ce)}}}function W(ce,pe="="){if(E(ce),typeof pe!="string")throw new Error("padding chr should be string");return{encode(ve){if(!Array.isArray(ve)||ve.length&&typeof ve[0]!="string")throw new Error("padding.encode input should be array of strings");for(let Ee of ve)if(typeof Ee!="string")throw new Error(`padding.encode: non-string input=${Ee}`);for(;ve.length*ce%8;)ve.push(pe);return ve},decode(ve){if(!Array.isArray(ve)||ve.length&&typeof ve[0]!="string")throw new Error("padding.encode input should be array of strings");for(let de of ve)if(typeof de!="string")throw new Error(`padding.decode: non-string input=${de}`);let Ee=ve.length;if(Ee*ce%8)throw new Error("Invalid padding: string should have whole number of bytes");for(;Ee>0&&ve[Ee-1]===pe;Ee--)if(!((Ee-1)*ce%8))throw new Error("Invalid padding: string has too much padding");return ve.slice(0,Ee)}}}function G(ce){if(typeof ce!="function")throw new Error("normalize fn should be function");return{encode:pe=>pe,decode:pe=>ce(pe)}}function Z(ce,pe,ve){if(pe<2)throw new Error(`convertRadix: wrong from=${pe}, base cannot be less than 2`);if(ve<2)throw new Error(`convertRadix: wrong to=${ve}, base cannot be less than 2`);if(!Array.isArray(ce))throw new Error("convertRadix: data should be array");if(!ce.length)return[];let Ee=0;const de=[],be=Array.from(ce);for(be.forEach($e=>{if(E($e),$e<0||$e>=pe)throw new Error(`Wrong integer: ${$e}`)});;){let $e=0,Ae=!0;for(let Re=Ee;Re<be.length;Re++){const Ce=be[Re],Se=pe*$e+Ce;if(!Number.isSafeInteger(Se)||pe*$e/pe!==$e||Se-Ce!==pe*$e)throw new Error("convertRadix: carry overflow");if($e=Se%ve,be[Re]=Math.floor(Se/ve),!Number.isSafeInteger(be[Re])||be[Re]*ve+$e!==Se)throw new Error("convertRadix: carry overflow");if(Ae)be[Re]?Ae=!1:Ee=Re;else continue}if(de.push($e),Ae)break}for(let $e=0;$e<ce.length-1&&ce[$e]===0;$e++)de.push(0);return de.reverse()}const Y=(ce,pe)=>pe?Y(pe,ce%pe):ce,X=(ce,pe)=>ce+(pe-Y(ce,pe));function Q(ce,pe,ve,Ee){if(!Array.isArray(ce))throw new Error("convertRadix2: data should be array");if(pe<=0||pe>32)throw new Error(`convertRadix2: wrong from=${pe}`);if(ve<=0||ve>32)throw new Error(`convertRadix2: wrong to=${ve}`);if(X(pe,ve)>32)throw new Error(`convertRadix2: carry overflow from=${pe} to=${ve} carryBits=${X(pe,ve)}`);let de=0,be=0;const $e=2**ve-1,Ae=[];for(const Re of ce){if(E(Re),Re>=2**pe)throw new Error(`convertRadix2: invalid data word=${Re} from=${pe}`);if(de=de<<pe|Re,be+pe>32)throw new Error(`convertRadix2: carry overflow pos=${be} from=${pe}`);for(be+=pe;be>=ve;be-=ve)Ae.push((de>>be-ve&$e)>>>0);de&=2**be-1}if(de=de<<ve-be&$e,!Ee&&be>=pe)throw new Error("Excess padding");if(!Ee&&de)throw new Error(`Non-zero padding: ${de}`);return Ee&&be>0&&Ae.push(de>>>0),Ae}function J(ce){return E(ce),{encode:pe=>{if(!(pe instanceof Uint8Array))throw new Error("radix.encode input should be Uint8Array");return Z(Array.from(pe),2**8,ce)},decode:pe=>{if(!Array.isArray(pe)||pe.length&&typeof pe[0]!="number")throw new Error("radix.decode input should be array of strings");return Uint8Array.from(Z(pe,ce,2**8))}}}function ne(ce,pe=!1){if(E(ce),ce<=0||ce>32)throw new Error("radix2: bits should be in (0..32]");if(X(8,ce)>32||X(ce,8)>32)throw new Error("radix2: carry overflow");return{encode:ve=>{if(!(ve instanceof Uint8Array))throw new Error("radix2.encode input should be Uint8Array");return Q(Array.from(ve),8,ce,!pe)},decode:ve=>{if(!Array.isArray(ve)||ve.length&&typeof ve[0]!="number")throw new Error("radix2.decode input should be array of strings");return Uint8Array.from(Q(ve,ce,8,pe))}}}function re(ce){if(typeof ce!="function")throw new Error("unsafeWrapper fn should be function");return function(...pe){try{return ce.apply(null,pe)}catch{}}}function ae(ce,pe){if(E(ce),typeof pe!="function")throw new Error("checksum fn should be function");return{encode(ve){if(!(ve instanceof Uint8Array))throw new Error("checksum.encode: input should be Uint8Array");const Ee=pe(ve).slice(0,ce),de=new Uint8Array(ve.length+ce);return de.set(ve),de.set(Ee,ve.length),de},decode(ve){if(!(ve instanceof Uint8Array))throw new Error("checksum.decode: input should be Uint8Array");const Ee=ve.slice(0,-ce),de=pe(Ee).slice(0,ce),be=ve.slice(-ce);for(let $e=0;$e<ce;$e++)if(de[$e]!==be[$e])throw new Error("Invalid checksum");return Ee}}}R.utils={alphabet:H,chain:U,checksum:ae,radix:J,radix2:ne,join:K,padding:W},R.base16=U(ne(4),H("0123456789ABCDEF"),K("")),R.base32=U(ne(5),H("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"),W(5),K("")),R.base32hex=U(ne(5),H("0123456789ABCDEFGHIJKLMNOPQRSTUV"),W(5),K("")),R.base32crockford=U(ne(5),H("0123456789ABCDEFGHJKMNPQRSTVWXYZ"),K(""),G(ce=>ce.toUpperCase().replace(/O/g,"0").replace(/[IL]/g,"1"))),R.base64=U(ne(6),H("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"),W(6),K("")),R.base64url=U(ne(6),H("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"),W(6),K(""));const te=ce=>U(J(58),H(ce),K(""));R.base58=te("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"),R.base58flickr=te("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"),R.base58xrp=te("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");const se=[0,2,3,5,6,7,9,10,11];R.base58xmr={encode(ce){let pe="";for(let ve=0;ve<ce.length;ve+=8){const Ee=ce.subarray(ve,ve+8);pe+=R.base58.encode(Ee).padStart(se[Ee.length],"1")}return pe},decode(ce){let pe=[];for(let ve=0;ve<ce.length;ve+=11){const Ee=ce.slice(ve,ve+11),de=se.indexOf(Ee.length),be=R.base58.decode(Ee);for(let $e=0;$e<be.length-de;$e++)if(be[$e]!==0)throw new Error("base58xmr: wrong padding");pe=pe.concat(Array.from(be.slice(be.length-de)))}return Uint8Array.from(pe)}};const ie=ce=>U(ae(4,pe=>ce(ce(pe))),R.base58);R.base58check=ie;const ye=U(H("qpzry9x8gf2tvdw0s3jn54khce6mua7l"),K("")),me=[996825010,642813549,513874426,1027748829,705979059];function _e(ce){const pe=ce>>25;let ve=(ce&33554431)<<5;for(let Ee=0;Ee<me.length;Ee++)(pe>>Ee&1)===1&&(ve^=me[Ee]);return ve}function oe(ce,pe,ve=1){const Ee=ce.length;let de=1;for(let be=0;be<Ee;be++){const $e=ce.charCodeAt(be);if($e<33||$e>126)throw new Error(`Invalid prefix (${ce})`);de=_e(de)^$e>>5}de=_e(de);for(let be=0;be<Ee;be++)de=_e(de)^ce.charCodeAt(be)&31;for(let be of pe)de=_e(de)^be;for(let be=0;be<6;be++)de=_e(de);return de^=ve,ye.encode(Q([de%2**30],30,5,!1))}function ue(ce){const pe=ce==="bech32"?1:734539939,ve=ne(5),Ee=ve.decode,de=ve.encode,be=re(Ee);function $e(Se,Te,Ne=90){if(typeof Se!="string")throw new Error(`bech32.encode prefix should be string, not ${typeof Se}`);if(!Array.isArray(Te)||Te.length&&typeof Te[0]!="number")throw new Error(`bech32.encode words should be array of numbers, not ${typeof Te}`);const Ie=Se.length+7+Te.length;if(Ne!==!1&&Ie>Ne)throw new TypeError(`Length ${Ie} exceeds limit ${Ne}`);return Se=Se.toLowerCase(),`${Se}1${ye.encode(Te)}${oe(Se,Te,pe)}`}function Ae(Se,Te=90){if(typeof Se!="string")throw new Error(`bech32.decode input should be string, not ${typeof Se}`);if(Se.length<8||Te!==!1&&Se.length>Te)throw new TypeError(`Wrong string length: ${Se.length} (${Se}). Expected (8..${Te})`);const Ne=Se.toLowerCase();if(Se!==Ne&&Se!==Se.toUpperCase())throw new Error("String must be lowercase or uppercase");Se=Ne;const Ie=Se.lastIndexOf("1");if(Ie===0||Ie===-1)throw new Error('Letter "1" must be present between prefix and data only');const Be=Se.slice(0,Ie),Le=Se.slice(Ie+1);if(Le.length<6)throw new Error("Data must be at least 6 characters long");const Ue=ye.decode(Le).slice(0,-6),Me=oe(Be,Ue,pe);if(!Le.endsWith(Me))throw new Error(`Invalid checksum in ${Se}: expected "${Me}"`);return{prefix:Be,words:Ue}}const Re=re(Ae);function Ce(Se){const{prefix:Te,words:Ne}=Ae(Se,!1);return{prefix:Te,words:Ne,bytes:Ee(Ne)}}return{encode:$e,decode:Ae,decodeToBytes:Ce,decodeUnsafe:Re,fromWords:Ee,fromWordsUnsafe:be,toWords:de}}R.bech32=ue("bech32"),R.bech32m=ue("bech32m"),R.utf8={encode:ce=>new TextDecoder().decode(ce),decode:ce=>new TextEncoder().encode(ce)},R.hex=U(ne(4),H("0123456789abcdef"),K(""),G(ce=>{if(typeof ce!="string"||ce.length%2)throw new TypeError(`hex.decode: expected string, got ${typeof ce} with length ${ce.length}`);return ce.toLowerCase()}));const he={utf8:R.utf8,hex:R.hex,base16:R.base16,base32:R.base32,base64:R.base64,base64url:R.base64url,base58:R.base58,base58xmr:R.base58xmr},we=`Invalid encoding type. Available types: ${Object.keys(he).join(", ")}`,xe=(ce,pe)=>{if(typeof ce!="string"||!he.hasOwnProperty(ce))throw new TypeError(we);if(!(pe instanceof Uint8Array))throw new TypeError("bytesToString() expects Uint8Array");return he[ce].encode(pe)};R.bytesToString=xe,R.str=R.bytesToString;const ke=(ce,pe)=>{if(!he.hasOwnProperty(ce))throw new TypeError(we);if(typeof pe!="string")throw new TypeError("stringToBytes() expects string");return he[ce].decode(pe)};R.stringToBytes=ke,R.bytes=R.stringToBytes}(lib)),lib}var bolt11,hasRequiredBolt11;function requireBolt11(){if(hasRequiredBolt11)return bolt11;hasRequiredBolt11=1;const{bech32:R,hex:E,utf8:U}=requireLib(),H={bech32:"bc",pubKeyHash:0,scriptHash:5,validWitnessVersions:[0]},K={bech32:"tb",pubKeyHash:111,scriptHash:196,validWitnessVersions:[0]},W={bech32:"tbs",pubKeyHash:111,scriptHash:196,validWitnessVersions:[0]},G={bech32:"bcrt",pubKeyHash:111,scriptHash:196,validWitnessVersions:[0]},Z={bech32:"sb",pubKeyHash:63,scriptHash:123,validWitnessVersions:[0]},Y=["option_data_loss_protect","initial_routing_sync","option_upfront_shutdown_script","gossip_queries","var_onion_optin","gossip_queries_ex","option_static_remotekey","payment_secret","basic_mpp","option_support_large_channel"],X={m:BigInt(1e3),u:BigInt(1e6),n:BigInt(1e9),p:BigInt(1e12)},Q=BigInt("2100000000000000000"),J=BigInt(1e11),ne={payment_hash:1,payment_secret:16,description:13,payee:19,description_hash:23,expiry:6,min_final_cltv_expiry:24,fallback_address:9,route_hint:3,feature_bits:5,metadata:27},re={};for(let oe=0,ue=Object.keys(ne);oe<ue.length;oe++){const he=ue[oe],we=ne[ue[oe]].toString();re[we]=he}const ae={1:oe=>E.encode(R.fromWordsUnsafe(oe)),16:oe=>E.encode(R.fromWordsUnsafe(oe)),13:oe=>U.encode(R.fromWordsUnsafe(oe)),19:oe=>E.encode(R.fromWordsUnsafe(oe)),23:oe=>E.encode(R.fromWordsUnsafe(oe)),27:oe=>E.encode(R.fromWordsUnsafe(oe)),6:se,24:se,3:ie,5:ye};function te(oe){return ue=>({tagCode:parseInt(oe),words:R.encode("unknown",ue,Number.MAX_SAFE_INTEGER)})}function se(oe){return oe.reverse().reduce((ue,he,we)=>ue+he*Math.pow(32,we),0)}function ie(oe){const ue=[];let he,we,xe,ke,ce,pe=R.fromWordsUnsafe(oe);for(;pe.length>0;)he=E.encode(pe.slice(0,33)),we=E.encode(pe.slice(33,41)),xe=parseInt(E.encode(pe.slice(41,45)),16),ke=parseInt(E.encode(pe.slice(45,49)),16),ce=parseInt(E.encode(pe.slice(49,51)),16),pe=pe.slice(51),ue.push({pubkey:he,short_channel_id:we,fee_base_msat:xe,fee_proportional_millionths:ke,cltv_expiry_delta:ce});return ue}function ye(oe){const ue=oe.slice().reverse().map(xe=>[!!(xe&1),!!(xe&2),!!(xe&4),!!(xe&8),!!(xe&16)]).reduce((xe,ke)=>xe.concat(ke),[]);for(;ue.length<Y.length*2;)ue.push(!1);const he={};Y.forEach((xe,ke)=>{let ce;ue[ke*2]?ce="required":ue[ke*2+1]?ce="supported":ce="unsupported",he[xe]=ce});const we=ue.slice(Y.length*2);return he.extra_bits={start_bit:Y.length*2,bits:we,has_required:we.reduce((xe,ke,ce)=>ce%2!==0?xe||!1:xe||ke,!1)},he}function me(oe,ue){let he,we;if(oe.slice(-1).match(/^[munp]$/))he=oe.slice(-1),we=oe.slice(0,-1);else{if(oe.slice(-1).match(/^[^munp0-9]$/))throw new Error("Not a valid multiplier for the amount");we=oe}if(!we.match(/^\d+$/))throw new Error("Not a valid human readable amount");const xe=BigInt(we),ke=he?xe*J/X[he]:xe*J;if(he==="p"&&xe%BigInt(10)!==BigInt(0)||ke>Q)throw new Error("Amount is outside of valid range");return ue?ke.toString():ke}function _e(oe,ue){if(typeof oe!="string")throw new Error("Lightning Payment Request must be string");if(oe.slice(0,2).toLowerCase()!=="ln")throw new Error("Not a proper lightning payment request");const he=[],we=R.decode(oe,Number.MAX_SAFE_INTEGER);oe=oe.toLowerCase();const xe=we.prefix;let ke=we.words,ce=oe.slice(xe.length+1),pe=ke.slice(-104);ke=ke.slice(0,-104);let ve=xe.match(/^ln(\S+?)(\d*)([a-zA-Z]?)$/);if(ve&&!ve[2]&&(ve=xe.match(/^ln(\S+)$/)),!ve)throw new Error("Not a proper lightning payment request");he.push({name:"lightning_network",letters:"ln"});const Ee=ve[1];let de;if(ue){if(ue.bech32===void 0||ue.pubKeyHash===void 0||ue.scriptHash===void 0||!Array.isArray(ue.validWitnessVersions))throw new Error("Invalid network");de=ue}else switch(Ee){case H.bech32:de=H;break;case K.bech32:de=K;break;case W.bech32:de=W;break;case G.bech32:de=G;break;case Z.bech32:de=Z;break}if(!de||de.bech32!==Ee)throw new Error("Unknown coin bech32 prefix");he.push({name:"coin_network",letters:Ee,value:de});const be=ve[2];let $e;if(be){const Be=ve[3];$e=me(be+Be,!0),he.push({name:"amount",letters:ve[2]+ve[3],value:$e})}else $e=null;he.push({name:"separator",letters:"1"});const Ae=se(ke.slice(0,7));ke=ke.slice(7),he.push({name:"timestamp",letters:ce.slice(0,7),value:Ae}),ce=ce.slice(7);let Re,Ce,Se,Te;for(;ke.length>0;){const Be=ke[0].toString();Re=re[Be]||"unknown_tag",Ce=ae[Be]||te(Be),ke=ke.slice(1),Se=se(ke.slice(0,2)),ke=ke.slice(2),Te=ke.slice(0,Se),ke=ke.slice(Se),he.push({name:Re,tag:ce[0],letters:ce.slice(0,3+Se),value:Ce(Te)}),ce=ce.slice(3+Se)}he.push({name:"signature",letters:ce.slice(0,104),value:E.encode(R.fromWordsUnsafe(pe))}),ce=ce.slice(104),he.push({name:"checksum",letters:ce});let Ne={paymentRequest:oe,sections:he,get expiry(){let Be=he.find(Le=>Le.name==="expiry");if(Be)return Ie("timestamp")+Be.value},get route_hints(){return he.filter(Be=>Be.name==="route_hint").map(Be=>Be.value)}};for(let Be in ne)Be!=="route_hint"&&Object.defineProperty(Ne,Be,{get(){return Ie(Be)}});return Ne;function Ie(Be){let Le=he.find(Ue=>Ue.name===Be);return Le?Le.value:void 0}}return bolt11={decode:_e,hrpToMillisat:me},bolt11}requireBolt11();function getRelaysForSync(R,E,U="write"){if(!R.outboxTracker)return;const H=R.outboxTracker.data.get(E);if(H)return U==="write"?H.writeRelays:H.readRelays}async function getWriteRelaysFor(R,E,U="write"){if(R.outboxTracker)return R.outboxTracker.data.has(E)||await R.outboxTracker.trackUsers([E]),getRelaysForSync(R,E,U)}function getTopRelaysForAuthors(R,E){const U=new Map;return E.forEach(K=>{const W=getRelaysForSync(R,K);W&&W.forEach(G=>{const Z=U.get(G)||0;U.set(G,Z+1)})}),Array.from(U.entries()).sort((K,W)=>W[1]-K[1]).map(K=>K[0])}function getAllRelaysForAllPubkeys(R,E,U="read"){const H=new Map,K=new Set;return E.forEach(W=>{const G=getRelaysForSync(R,W,U);G&&G.size>0?(G.forEach(Z=>{(H.get(Z)||new Set).add(W)}),H.set(W,G)):K.add(W)}),{pubkeysToRelays:H,authorsMissingRelays:K}}function chooseRelayCombinationForPubkeys(R,E,U,{count:H,preferredRelays:K}={}){H??(H=2),K??(K=new Set);const W=R.pool,G=W.connectedRelays();G.forEach(ne=>{K.add(ne.url)});const Z=new Map,{pubkeysToRelays:Y,authorsMissingRelays:X}=getAllRelaysForAllPubkeys(R,E,U),Q=getTopRelaysForAuthors(R,E),J=(ne,re)=>{const ae=Z.get(re)||[];ae.push(ne),Z.set(re,ae)};for(const[ne,re]of Y.entries()){let ae=H;for(const te of G)re.has(te.url)&&(J(ne,te.url),ae--);for(const te of re)Z.has(te)&&(J(ne,te),ae--);if(!(ae<=0))for(const te of Q){if(ae<=0)break;re.has(te)&&(J(ne,te),ae--)}}for(const ne of X)W.permanentAndConnectedRelays().forEach(re=>{const ae=Z.get(re.url)||[];ae.push(ne),Z.set(re.url,ae)});return Z}function getRelaysForFilterWithAuthors(R,E,U=2){return chooseRelayCombinationForPubkeys(R,E,"write",{count:U})}function tryNormalizeRelayUrl(R){try{return normalizeRelayUrl(R)}catch{return}}function normalizeRelayUrl(R){let E=normalizeUrl(R.toLowerCase(),{stripAuthentication:!1,stripWWW:!1,stripHash:!0});return E.endsWith("/")||(E+="/"),E}function normalize(R){const E=new Set;for(const U of R)try{E.add(normalizeRelayUrl(U))}catch{}return Array.from(E)}var DATA_URL_DEFAULT_MIME_TYPE="text/plain",DATA_URL_DEFAULT_CHARSET="us-ascii",testParameter=(R,E)=>E.some(U=>U instanceof RegExp?U.test(R):U===R),supportedProtocols=new Set(["https:","http:","file:"]),hasCustomProtocol=R=>{try{const{protocol:E}=new URL(R);return E.endsWith(":")&&!E.includes(".")&&!supportedProtocols.has(E)}catch{return!1}},normalizeDataURL=(R,{stripHash:E})=>{var J,ne,re,ae;const U=/^data:(?<type>[^,]*?),(?<data>[^#]*?)(?:#(?<hash>.*))?$/.exec(R);if(!U)throw new Error(`Invalid URL: ${R}`);let H=((J=U.groups)==null?void 0:J.type)??"",K=((ne=U.groups)==null?void 0:ne.data)??"",W=((re=U.groups)==null?void 0:re.hash)??"";const G=H.split(";");W=E?"":W;let Z=!1;G[G.length-1]==="base64"&&(G.pop(),Z=!0);const Y=((ae=G.shift())==null?void 0:ae.toLowerCase())??"",Q=[...G.map(te=>{let[se,ie=""]=te.split("=").map(ye=>ye.trim());return se==="charset"&&(ie=ie.toLowerCase(),ie===DATA_URL_DEFAULT_CHARSET)?"":`${se}${ie?`=${ie}`:""}`}).filter(Boolean)];return Z&&Q.push("base64"),(Q.length>0||Y&&Y!==DATA_URL_DEFAULT_MIME_TYPE)&&Q.unshift(Y),`data:${Q.join(";")},${Z?K.trim():K}${W?`#${W}`:""}`};function normalizeUrl(R,E){if(E={defaultProtocol:"http",normalizeProtocol:!0,forceHttp:!1,forceHttps:!1,stripAuthentication:!0,stripHash:!1,stripTextFragment:!0,stripWWW:!0,removeQueryParameters:[/^utm_\w+/i],removeTrailingSlash:!0,removeSingleSlash:!0,removeDirectoryIndex:!1,removeExplicitPort:!1,sortQueryParameters:!0,...E},typeof E.defaultProtocol=="string"&&!E.defaultProtocol.endsWith(":")&&(E.defaultProtocol=`${E.defaultProtocol}:`),R=R.trim(),/^data:/i.test(R))return normalizeDataURL(R,E);if(hasCustomProtocol(R))return R;const U=R.startsWith("//");!U&&/^\.*\//.test(R)||(R=R.replace(/^(?!(?:\w+:)?\/\/)|^\/\//,E.defaultProtocol));const K=new URL(R);if(E.forceHttp&&E.forceHttps)throw new Error("The `forceHttp` and `forceHttps` options cannot be used together");if(E.forceHttp&&K.protocol==="https:"&&(K.protocol="http:"),E.forceHttps&&K.protocol==="http:"&&(K.protocol="https:"),E.stripAuthentication&&(K.username="",K.password=""),E.stripHash?K.hash="":E.stripTextFragment&&(K.hash=K.hash.replace(/#?:~:text.*?$/i,"")),K.pathname){const G=/\b[a-z][a-z\d+\-.]{1,50}:\/\//g;let Z=0,Y="";for(;;){const Q=G.exec(K.pathname);if(!Q)break;const J=Q[0],ne=Q.index,re=K.pathname.slice(Z,ne);Y+=re.replace(/\/{2,}/g,"/"),Y+=J,Z=ne+J.length}const X=K.pathname.slice(Z,K.pathname.length);Y+=X.replace(/\/{2,}/g,"/"),K.pathname=Y}if(K.pathname)try{K.pathname=decodeURI(K.pathname)}catch{}if(E.removeDirectoryIndex===!0&&(E.removeDirectoryIndex=[/^index\.[a-z]+$/]),Array.isArray(E.removeDirectoryIndex)&&E.removeDirectoryIndex.length>0){let G=K.pathname.split("/");const Z=G[G.length-1];testParameter(Z,E.removeDirectoryIndex)&&(G=G.slice(0,-1),K.pathname=G.slice(1).join("/")+"/")}if(K.hostname&&(K.hostname=K.hostname.replace(/\.$/,""),E.stripWWW&&/^www\.(?!www\.)[a-z\-\d]{1,63}\.[a-z.\-\d]{2,63}$/.test(K.hostname)&&(K.hostname=K.hostname.replace(/^www\./,""))),Array.isArray(E.removeQueryParameters))for(const G of[...K.searchParams.keys()])testParameter(G,E.removeQueryParameters)&&K.searchParams.delete(G);if(!Array.isArray(E.keepQueryParameters)&&E.removeQueryParameters===!0&&(K.search=""),Array.isArray(E.keepQueryParameters)&&E.keepQueryParameters.length>0)for(const G of[...K.searchParams.keys()])testParameter(G,E.keepQueryParameters)||K.searchParams.delete(G);if(E.sortQueryParameters){K.searchParams.sort();try{K.search=decodeURIComponent(K.search)}catch{}}E.removeTrailingSlash&&(K.pathname=K.pathname.replace(/\/$/,"")),E.removeExplicitPort&&K.port&&(K.port="");const W=R;return R=K.toString(),!E.removeSingleSlash&&K.pathname==="/"&&!W.endsWith("/")&&K.hash===""&&(R=R.replace(/\/$/,"")),(E.removeTrailingSlash||K.pathname==="/")&&K.hash===""&&E.removeSingleSlash&&(R=R.replace(/\/$/,"")),U&&!E.normalizeProtocol&&(R=R.replace(/^http:\/\//,"//")),E.stripProtocol&&(R=R.replace(/^(?:https?:)?\/\//,"")),R}var MAX_RECONNECT_ATTEMPTS=5,FLAPPING_THRESHOLD_MS=1e3,NDKRelayConnectivity=class{constructor(R,E){le(this,"ndkRelay");le(this,"ws");le(this,"_status");le(this,"timeoutMs");le(this,"connectedAt");le(this,"_connectionStats",{attempts:0,success:0,durations:[]});le(this,"debug");le(this,"netDebug");le(this,"connectTimeout");le(this,"reconnectTimeout");le(this,"ndk");le(this,"openSubs",new Map);le(this,"openCountRequests",new Map);le(this,"openEventPublishes",new Map);le(this,"serial",0);le(this,"baseEoseTimeout",4400);le(this,"updateConnectionStats",{connected:()=>{this._connectionStats.success++,this._connectionStats.connectedAt=Date.now()},disconnected:()=>{this._connectionStats.connectedAt&&(this._connectionStats.durations.push(Date.now()-this._connectionStats.connectedAt),this._connectionStats.durations.length>100&&this._connectionStats.durations.shift()),this._connectionStats.connectedAt=void 0},attempt:()=>{this._connectionStats.attempts++,this._connectionStats.connectedAt=Date.now()}});this.ndkRelay=R,this._status=1;const U=Math.floor(Math.random()*1e3);this.debug=this.ndkRelay.debug.extend("connectivity"+U),this.ndk=E}async connect(R,E=!0){if(this._status!==2&&this._status!==1||this.reconnectTimeout){this.debug("Relay requested to be connected but was in state %s or it had a reconnect timeout",this._status);return}this.reconnectTimeout&&(clearTimeout(this.reconnectTimeout),this.reconnectTimeout=void 0),this.connectTimeout&&(clearTimeout(this.connectTimeout),this.connectTimeout=void 0),R??(R=this.timeoutMs),!this.timeoutMs&&R&&(this.timeoutMs=R),this.timeoutMs&&(this.connectTimeout=setTimeout(()=>this.onConnectionError(E),this.timeoutMs));try{this.updateConnectionStats.attempt(),this._status===1?this._status=4:this._status=2,this.ws=new WebSocket(this.ndkRelay.url),this.ws.onopen=this.onConnect.bind(this),this.ws.onclose=this.onDisconnect.bind(this),this.ws.onmessage=this.onMessage.bind(this),this.ws.onerror=this.onError.bind(this)}catch(U){throw this.debug(`Failed to connect to ${this.ndkRelay.url}`,U),this._status=1,E?this.handleReconnection():this.ndkRelay.emit("delayed-connect",2*24*60*60*1e3),U}}disconnect(){var R;this._status=0;try{(R=this.ws)==null||R.close()}catch(E){this.debug("Failed to disconnect",E),this._status=1}}onConnectionError(R){this.debug(`Error connecting to ${this.ndkRelay.url}`,this.timeoutMs),R&&!this.reconnectTimeout&&this.handleReconnection()}onConnect(){var R;(R=this.netDebug)==null||R.call(this,"connected",this.ndkRelay),this.reconnectTimeout&&(clearTimeout(this.reconnectTimeout),this.reconnectTimeout=void 0),this.connectTimeout&&(clearTimeout(this.connectTimeout),this.connectTimeout=void 0),this.updateConnectionStats.connected(),this._status=5,this.ndkRelay.emit("connect"),this.ndkRelay.emit("ready")}onDisconnect(){var R;(R=this.netDebug)==null||R.call(this,"disconnected",this.ndkRelay),this.updateConnectionStats.disconnected(),this._status===5&&this.handleReconnection(),this._status=1,this.ndkRelay.emit("disconnect")}onMessage(R){var E;(E=this.netDebug)==null||E.call(this,R.data,this.ndkRelay,"recv");try{const U=JSON.parse(R.data),[H,K,...W]=U;switch(H){case"EVENT":{const G=this.openSubs.get(K),Z=U[2];if(!G){this.debug(`Received event for unknown subscription ${K}`);return}G.onevent(Z);return}case"COUNT":{const G=U[2],Z=this.openCountRequests.get(K);Z&&(Z.resolve(G.count),this.openCountRequests.delete(K));return}case"EOSE":{const G=this.openSubs.get(K);if(!G)return;G.oneose(K);return}case"OK":{const G=U[2],Z=U[3],Y=this.openEventPublishes.get(K),X=Y==null?void 0:Y.pop();if(!Y||!X){this.debug("Received OK for unknown event publish",K);return}G?X.resolve(Z):X.reject(new Error(Z)),Y.length===0?this.openEventPublishes.delete(K):this.openEventPublishes.set(K,Y);return}case"CLOSED":{const G=this.openSubs.get(K);if(!G)return;G.onclosed(U[2]);return}case"NOTICE":this.onNotice(U[1]);return;case"AUTH":{this.onAuthRequested(U[1]);return}}}catch(U){this.debug(`Error parsing message from ${this.ndkRelay.url}: ${U.message}`,U==null?void 0:U.stack);return}}async onAuthRequested(R){var U,H,K;const E=this.ndkRelay.authPolicy??((U=this.ndk)==null?void 0:U.relayAuthDefaultPolicy);if(this.debug("Relay requested authentication",{havePolicy:!!E}),this._status===7){this.debug("Already authenticating, ignoring");return}if(this._status=6,E){if(this._status>=5){this._status=7;let W;try{W=await E(this.ndkRelay,R)}catch(G){this.debug("Authentication policy threw an error",G),W=!1}if(this.debug("Authentication policy returned",!!W),W instanceof NDKEvent||W===!0){W instanceof NDKEvent&&await this.auth(W);const G=async()=>{if(this._status>=5&&this._status<8){const Z=new NDKEvent(this.ndk);Z.kind=22242,Z.tags=[["relay",this.ndkRelay.url],["challenge",R]],await Z.sign(),this.auth(Z).then(()=>{this._status=8,this.ndkRelay.emit("authed"),this.debug("Authentication successful")}).catch(Y=>{this._status=6,this.ndkRelay.emit("auth:failed",Y),this.debug("Authentication failed",Y)})}else this.debug("Authentication failed, it changed status, status is %d",this._status)};W===!0&&((H=this.ndk)!=null&&H.signer?G().catch(Z=>{console.error("Error authenticating",Z)}):(this.debug("No signer available for authentication localhost"),(K=this.ndk)==null||K.once("signer:ready",G))),this._status=5,this.ndkRelay.emit("authed")}}}else this.ndkRelay.emit("auth",R)}onError(R){this.debug(`WebSocket error on ${this.ndkRelay.url}:`,R)}get status(){return this._status}isAvailable(){return this._status===5}isFlapping(){const R=this._connectionStats.durations;if(R.length%3!==0)return!1;const U=R.reduce((G,Z)=>G+Z,0)/R.length,H=R.map(G=>Math.pow(G-U,2)).reduce((G,Z)=>G+Z,0)/R.length;return Math.sqrt(H)<FLAPPING_THRESHOLD_MS}async onNotice(R){this.ndkRelay.emit("notice",R)}handleReconnection(R=0){if(this.reconnectTimeout)return;if(this.isFlapping()){this.ndkRelay.emit("flapping",this._connectionStats),this._status=3;return}const E=this.connectedAt?Math.max(0,6e4-(Date.now()-this.connectedAt)):5e3*(this._connectionStats.attempts+1);this.reconnectTimeout=setTimeout(()=>{this.reconnectTimeout=void 0,this._status=2,this.connect().catch(U=>{R<MAX_RECONNECT_ATTEMPTS?setTimeout(()=>{this.handleReconnection(R+1)},1e3*(R+1)^4):this.debug("Reconnect failed")})},E),this.ndkRelay.emit("delayed-connect",E),this.debug("Reconnecting in",E),this._connectionStats.nextReconnectAt=Date.now()+E}async send(R){var E,U,H;this._status>=5&&((E=this.ws)==null?void 0:E.readyState)===WebSocket.OPEN?((U=this.ws)==null||U.send(R),(H=this.netDebug)==null||H.call(this,R,this.ndkRelay,"send")):this.debug(`Not connected to ${this.ndkRelay.url} (%d), not sending message ${R}`,this._status)}async auth(R){const E=new Promise((U,H)=>{const K=this.openEventPublishes.get(R.id)??[];K.push({resolve:U,reject:H}),this.openEventPublishes.set(R.id,K)});return this.send('["AUTH",'+JSON.stringify(R.rawEvent())+"]"),E}async publish(R){const E=new Promise((U,H)=>{const K=this.openEventPublishes.get(R.id)??[];K.length>0&&console.warn("Duplicate event publishing detected, you are publishing event "+R.id+" twice"),K.push({resolve:U,reject:H}),this.openEventPublishes.set(R.id,K)});return this.send('["EVENT",'+JSON.stringify(R)+"]"),E}async count(R,E){this.serial++;const U=(E==null?void 0:E.id)||"count:"+this.serial,H=new Promise((K,W)=>{this.openCountRequests.set(U,{resolve:K,reject:W})});return this.send('["COUNT","'+U+'",'+JSON.stringify(R).substring(1)),H}close(R,E){this.send('["CLOSE","'+R+'"]');const U=this.openSubs.get(R);this.openSubs.delete(R),U&&U.onclose(E)}req(R){this.send('["REQ","'+R.subId+'",'+JSON.stringify(R.executeFilters).substring(1))+"",this.openSubs.set(R.subId,R)}get connectionStats(){return this._connectionStats}get url(){return this.ndkRelay.url}get connected(){var R;return this._status>=5&&((R=this.ws)==null?void 0:R.readyState)===WebSocket.OPEN}},NDKRelayPublisher=class{constructor(R){le(this,"ndkRelay");le(this,"debug");this.ndkRelay=R,this.debug=R.debug.extend("publisher")}async publish(R,E=2500){let U;const H=()=>new Promise((Q,J)=>{try{this.publishEvent(R).then(ne=>{this.ndkRelay.emit("published",R),R.emit("relay:published",this.ndkRelay),Q(!0)}).catch(J)}catch(ne){J(ne)}}),K=new Promise((Q,J)=>{U=setTimeout(()=>{U=void 0,J(new Error("Timeout: "+E+"ms"))},E)}),W=()=>{H().then(Q=>G(Q)).catch(Q=>Z(Q))};let G,Z;const Y=Q=>{throw this.ndkRelay.debug("Publish failed",Q,R.id),this.ndkRelay.emit("publish:failed",R,Q),R.emit("relay:publish:failed",this.ndkRelay,Q),Q},X=()=>{U&&clearTimeout(U),this.ndkRelay.removeListener("connect",W)};return this.ndkRelay.status>=5?Promise.race([H(),K]).catch(Y).finally(X):(this.ndkRelay.status<=1?(console.warn("Relay is disconnected, trying to connect to publish an event",this.ndkRelay.url),this.ndkRelay.connect()):console.warn("Relay not connected, waiting for connection to publish an event",this.ndkRelay.url),Promise.race([new Promise((Q,J)=>{G=Q,Z=J,this.ndkRelay.once("connect",W)}),K]).catch(Y).finally(X))}async publishEvent(R){return this.ndkRelay.connectivity.publish(R.rawEvent())}};function filterFingerprint(R,E){const U=[];for(const K of R){const W=Object.entries(K||{}).map(([G,Z])=>["since","until"].includes(G)?G+":"+Z:G).sort().join("-");U.push(W)}let H=E?"+":"";return H+=U.join("|"),H}function mergeFilters(R){const E=[],U={};return R.filter(H=>!!H.limit).forEach(H=>E.push(H)),R=R.filter(H=>!H.limit),R.length===0?E:(R.forEach(H=>{Object.entries(H).forEach(([K,W])=>{Array.isArray(W)?U[K]===void 0?U[K]=[...W]:U[K]=Array.from(new Set([...U[K],...W])):U[K]=W})}),[...E,U])}var NDKRelaySubscription=class{constructor(R,E){le(this,"fingerprint");le(this,"items",new Map);le(this,"topSubscriptionManager");le(this,"debug");le(this,"status",0);le(this,"onClose");le(this,"relay");le(this,"eosed",!1);le(this,"executionTimer");le(this,"fireTime");le(this,"delayType");le(this,"executeFilters");le(this,"id",Math.random().toString(36).substring(7));le(this,"_subId");le(this,"subIdParts",new Set);le(this,"executeOnRelayReady",()=>{this.status===2&&(this.status=1,this.execute())});le(this,"reExecuteAfterAuth",(()=>{const R=this.subId;this.debug("Re-executing after auth",this.items.size),this.eosed?this.relay.close(this.subId):this.debug("We are abandoning an opened subscription, once it EOSE's, the handler will close it",{oldSubId:R}),this._subId=void 0,this.status=1,this.execute(),this.debug("Re-executed after auth %s  %s",R,this.subId)}).bind(this));this.relay=R,this.debug=R.debug.extend("subscription-"+this.id),this.fingerprint=E||Math.random().toString(36).substring(7)}get subId(){return this._subId?this._subId:(this._subId=this.fingerprint.slice(0,15),this._subId)}addSubIdPart(R){this.subIdParts.add(R)}addItem(R,E){if(!this.items.has(R.internalId))switch(R.on("close",this.removeItem.bind(this,R)),this.items.set(R.internalId,{subscription:R,filters:E}),this.status!==3&&R.subId&&(!this._subId||this._subId.length<48)&&(this.status===0||this.status===1)&&this.addSubIdPart(R.subId),this.status){case 0:this.evaluateExecutionPlan(R);break;case 3:console.log("BUG: This should not happen: This subscription needs to catch up with a subscription that was already running",E);break;case 1:this.evaluateExecutionPlan(R);break;case 4:throw this.debug("Subscription is closed, cannot add new items %o (%o)",R,E),new Error("Cannot add new items to a closed subscription")}}removeItem(R){if(this.items.delete(R.internalId),this.items.size===0){if(!this.eosed)return;this.close()}}close(){if(this.status===4)return;const R=this.status;if(this.status=4,R===3)try{this.relay.close(this.subId)}catch(E){this.debug("Error closing subscription",E,this)}else this.debug("Subscription wanted to close but it wasn't running, this is probably ok",{subId:this.subId,prevStatus:R,sub:this});this.cleanup()}cleanup(){this.executionTimer&&clearTimeout(this.executionTimer),this.relay.off("ready",this.executeOnRelayReady),this.relay.off("authed",this.reExecuteAfterAuth),this.onClose&&this.onClose(this)}evaluateExecutionPlan(R){if(!R.isGroupable()){this.status=1,this.execute();return}if(R.filters.find(H=>!!H.limit)&&(this.executeFilters=this.compileFilters(),this.executeFilters.length>=10)){this.status=1,this.execute();return}const E=R.groupableDelay,U=R.groupableDelayType;if(!E)throw new Error("Cannot group a subscription without a delay");if(this.status===0)this.schedule(E,U);else{const H=this.delayType,K=this.fireTime-Date.now();if(H==="at-least"&&U==="at-least")K<E&&(this.executionTimer&&clearTimeout(this.executionTimer),this.schedule(E,U));else if(H==="at-least"&&U==="at-most")K>E&&(this.executionTimer&&clearTimeout(this.executionTimer),this.schedule(E,U));else if(H==="at-most"&&U==="at-most")K>E&&(this.executionTimer&&clearTimeout(this.executionTimer),this.schedule(E,U));else if(H==="at-most"&&U==="at-least")K>E&&(this.executionTimer&&clearTimeout(this.executionTimer),this.schedule(E,U));else throw new Error("Unknown delay type combination "+H+" "+U)}}schedule(R,E){this.status=1;const U=Date.now();this.fireTime=U+R,this.delayType=E;const H=setTimeout(this.execute.bind(this),R);E==="at-least"&&(this.executionTimer=H)}finalizeSubId(){this.subIdParts.size>0?this._subId=Array.from(this.subIdParts).join("-"):this._subId=this.fingerprint.slice(0,15),this._subId+="-"+Math.random().toString(36).substring(2,7)}execute(){if(this.status===1){if(this.relay.connected)this.relay.status<8&&this.relay.once("authed",this.reExecuteAfterAuth);else{this.status=2,this.relay.once("ready",this.executeOnRelayReady);return}this.status=3,this.finalizeSubId(),this.executeFilters=this.compileFilters(),this.relay.req(this)}}onstart(){}onevent(R){var E;(E=this.topSubscriptionManager)==null||E.seenEvent(R.id,this.relay);for(const{subscription:U}of this.items.values())matchFilters(U.filters,R)&&U.eventReceived(R,this.relay,!1)}oneose(R){if(this.eosed=!0,R!==this.subId){this.debug("Received EOSE for an abandoned subscription",R,this.subId),this.relay.close(R);return}this.items.size===0&&this.close();for(const{subscription:E}of this.items.values())E.eoseReceived(this.relay),E.closeOnEose&&this.removeItem(E)}onclose(R){this.status=4}onclosed(R){if(R)for(const{subscription:E}of this.items.values())E.closedReceived(this.relay,R)}compileFilters(){const R=[],E=Array.from(this.items.values()).map(H=>H.filters);if(!E[0])return this.debug(" No filters to merge",this.items),console.error("BUG: No filters to merge!",this.items),[];const U=E[0].length;for(let H=0;H<U;H++){const K=E.map(W=>W[H]);R.push(...mergeFilters(K))}return R}},NDKRelaySubscriptionManager=class{constructor(R,E){le(this,"relay");le(this,"subscriptions");le(this,"topSubscriptionManager");this.relay=R,this.subscriptions=new Map,this.topSubscriptionManager=E}addSubscription(R,E){let U;if(!R.isGroupable())U=this.createSubscription(R,E);else{const H=filterFingerprint(E,R.closeOnEose);H&&(U=(this.subscriptions.get(H)||[]).find(W=>W.status<3)),U??(U=this.createSubscription(R,E,H))}U.addItem(R,E)}createSubscription(R,E,U){const H=new NDKRelaySubscription(this.relay,U);H.topSubscriptionManager=this.topSubscriptionManager,H.onClose=this.onRelaySubscriptionClose.bind(this);const K=this.subscriptions.get(H.fingerprint)??[];return this.subscriptions.set(H.fingerprint,[...K,H]),H}onRelaySubscriptionClose(R){let E=this.subscriptions.get(R.fingerprint)??[];E?E.length===1?this.subscriptions.delete(R.fingerprint):(E=E.filter(U=>U.id!==R.id),this.subscriptions.set(R.fingerprint,E),console.log("removing a subscription",{fingerprint:R.fingerprint,id:R.id,newSize:this.subscriptions.size})):console.warn("Unexpectedly did not find a subscription with fingerprint",R.fingerprint)}},je,NDKRelay=(je=class extends libExports.EventEmitter{constructor(U,H,K){super();le(this,"url");le(this,"scores");le(this,"connectivity");le(this,"subs");le(this,"publisher");le(this,"authPolicy");le(this,"lowestValidationRatio");le(this,"targetValidationRatio");le(this,"validationRatioFn");le(this,"validatedEventCount",0);le(this,"nonValidatedEventCount",0);le(this,"trusted",!1);le(this,"complaining",!1);le(this,"debug");le(this,"req");le(this,"close");this.url=normalizeRelayUrl(U),this.scores=new Map,this.debug=debug7(`ndk:relay:${U}`),this.connectivity=new NDKRelayConnectivity(this,K),this.connectivity.netDebug=K==null?void 0:K.netDebug,this.req=this.connectivity.req.bind(this.connectivity),this.close=this.connectivity.close.bind(this.connectivity),this.subs=new NDKRelaySubscriptionManager(this,K==null?void 0:K.subManager),this.publisher=new NDKRelayPublisher(this),this.authPolicy=H,this.targetValidationRatio=K==null?void 0:K.initialValidationRatio,this.lowestValidationRatio=K==null?void 0:K.lowestValidationRatio,this.validationRatioFn=((K==null?void 0:K.validationRatioFn)??je.defaultValidationRatioUpdateFn).bind(this),this.updateValidationRatio(),K||console.trace("relay created without ndk")}updateValidationRatio(){setTimeout(()=>{this.updateValidationRatio()},3e4)}get status(){return this.connectivity.status}get connectionStats(){return this.connectivity.connectionStats}async connect(U,H=!0){return this.connectivity.connect(U,H)}disconnect(){this.status!==1&&this.connectivity.disconnect()}subscribe(U,H){this.subs.addSubscription(U,H)}async publish(U,H=2500){return this.publisher.publish(U,H)}referenceTags(){return[["r",this.url]]}addValidatedEvent(){this.validatedEventCount++}addNonValidatedEvent(){this.nonValidatedEventCount++}get validationRatio(){return this.nonValidatedEventCount===0?1:this.validatedEventCount/(this.validatedEventCount+this.nonValidatedEventCount)}shouldValidateEvent(){return this.trusted?!1:this.targetValidationRatio===void 0?!0:this.validationRatio<this.targetValidationRatio}get connected(){return this.connectivity.connected}},le(je,"defaultValidationRatioUpdateFn",(U,H,K)=>{if(U.lowestValidationRatio===void 0||U.targetValidationRatio===void 0)return 1;let W=U.validationRatio;if(U.validationRatio>U.targetValidationRatio){const G=H/100;W=Math.max(U.lowestValidationRatio,U.validationRatio-G)}return W<U.validationRatio?W:U.validationRatio}),je),NDKPublishError=class extends Error{constructor(E,U,H,K){super(E);le(this,"errors");le(this,"publishedToRelays");le(this,"intendedRelaySet");this.errors=U,this.publishedToRelays=H,this.intendedRelaySet=K}get relayErrors(){const E=[];for(const[U,H]of this.errors)E.push(`${U.url}: ${H}`);return E.join(`
`)}},NDKRelaySet=class Ze{constructor(E,U,H){le(this,"relays");le(this,"debug");le(this,"ndk");le(this,"pool");this.relays=E,this.ndk=U,this.pool=H??U.pool,this.debug=U.debug.extend("relayset")}addRelay(E){this.relays.add(E)}get relayUrls(){return Array.from(this.relays).map(E=>E.url)}static fromRelayUrls(E,U,H=!0,K){if(K=K??U.pool,!K)throw new Error("No pool provided");const W=new Set;for(const G of E){const Z=K.relays.get(normalizeRelayUrl(G));if(Z)Z.status<5&&H&&Z.connect(),W.add(Z);else{const Y=new NDKRelay(normalizeRelayUrl(G),U==null?void 0:U.relayAuthDefaultPolicy,U);K.useTemporaryRelay(Y,void 0,"requested from fromRelayUrls "+E),W.add(Y)}}return new Ze(new Set(W),U,K)}async publish(E,U,H=1){const K=new Set,W=new Map,G=E.isEphemeral();E.publishStatus="pending";const Z=Array.from(this.relays).map(Y=>new Promise(X=>{Y.publish(E,U).then(Q=>{K.add(Y),X()}).catch(Q=>{G||W.set(Y,Q),X()})}));if(await Promise.all(Z),K.size<H){if(!G){const Y=new NDKPublishError("Not enough relays received the event",W,K,this);throw E.publishStatus="error",E.publishError=Y,this.ndk.emit("event:publish-failed",E,Y,this.relayUrls),Y}}else E.emit("published",{relaySet:this,publishedToRelays:K});return K}get size(){return this.relays.size}},d=debug7("ndk:outbox:calculate");async function calculateRelaySetFromEvent(R,E){var G;const U=new Set,H=await getWriteRelaysFor(R,E.pubkey);H&&H.forEach(Z=>{var X;const Y=(X=R.pool)==null?void 0:X.getRelay(Z);Y&&U.add(Y)});let K=E.tags.filter(Z=>["a","e"].includes(Z[0])).map(Z=>Z[2]).filter(Z=>Z&&Z.startsWith("wss://")).filter(Z=>{try{return new URL(Z),!0}catch{return!1}}).map(Z=>normalizeRelayUrl(Z));K=Array.from(new Set(K)).slice(0,5),K.forEach(Z=>{var X;const Y=(X=R.pool)==null?void 0:X.getRelay(Z,!0,!0);Y&&(d("Adding relay hint %s",Z),U.add(Y))});const W=E.getMatchingTags("p").map(Z=>Z[1]);return W.length<5?Array.from(chooseRelayCombinationForPubkeys(R,W,"read",{preferredRelays:new Set(H)}).keys()).forEach(Y=>{var Q;const X=(Q=R.pool)==null?void 0:Q.getRelay(Y,!1,!0);X&&(d("Adding p-tagged relay %s",Y),U.add(X))}):d("Too many p-tags to consider %d",W.length),(G=R.pool)==null||G.permanentAndConnectedRelays().forEach(Z=>U.add(Z)),new NDKRelaySet(U,R)}function calculateRelaySetsFromFilter(R,E,U){const H=new Map,K=new Set;if(E.forEach(W=>{W.authors&&W.authors.forEach(G=>K.add(G))}),K.size>0){const W=getRelaysForFilterWithAuthors(R,Array.from(K));for(const G of W.keys())H.set(G,[]);for(const G of E)if(G.authors)for(const[Z,Y]of W.entries()){const X=G.authors.filter(Q=>Y.includes(Q));H.set(Z,[...H.get(Z),{...G,authors:X}])}else for(const Z of W.keys())H.set(Z,[...H.get(Z),G])}else R.explicitRelayUrls&&R.explicitRelayUrls.forEach(W=>{H.set(W,E)});return H.size===0&&U.permanentAndConnectedRelays().slice(0,5).forEach(W=>{H.set(W.url,E)}),H}function calculateRelaySetsFromFilters(R,E,U){return calculateRelaySetsFromFilter(R,E,U)}function mergeTags(R,E){const U=new Map,H=G=>G.join(","),K=(G,Z)=>G.every((Y,X)=>Y===Z[X]),W=G=>{for(const[Z,Y]of U)if(K(Y,G)||K(G,Y)){G.length>=Y.length&&U.set(Z,G);return}U.set(H(G),G)};return R.concat(E).forEach(W),Array.from(U.values())}async function generateContentTags(R,E=[]){const U=/(@|nostr:)(npub|nprofile|note|nevent|naddr)[a-zA-Z0-9]+/g,H=new RegExp(`(?<=\\s|^)(#[^\\s!@#$%^&*()=+./,[{\\]};:'"?><]+)`,"g"),K=[],W=G=>{E.find(Z=>["q",G[0]].includes(Z[0])&&Z[1]===G[1])||E.push(G)};return R=R.replace(U,G=>{try{const Z=G.split(/(@|nostr:)/)[2],{type:Y,data:X}=nip19_exports.decode(Z);let Q;switch(Y){case"npub":Q=["p",X];break;case"nprofile":Q=["p",X.pubkey];break;case"note":K.push(new Promise(async J=>{W(["e",X,await maybeGetEventRelayUrl(Z),"mention"]),J()}));break;case"nevent":K.push(new Promise(async J=>{const{id:ne,author:re}=X;let{relays:ae}=X;(!ae||ae.length===0)&&(ae=[await maybeGetEventRelayUrl(Z)]),W(["e",ne,ae[0],"mention"]),re&&W(["p",re]),J()}));break;case"naddr":K.push(new Promise(async J=>{const ne=[X.kind,X.pubkey,X.identifier].join(":");let re=X.relays??[];re.length===0&&(re=[await maybeGetEventRelayUrl(Z)]),W(["a",ne,re[0],"mention"]),W(["p",X.pubkey]),J()}));break;default:return G}return Q&&W(Q),`nostr:${Z}`}catch{return G}}),await Promise.all(K),R=R.replace(H,(G,Z)=>{const Y=["t",Z.slice(1)];return E.find(X=>X[0]===Y[0]&&X[1]===Y[1])||E.push(Y),G}),{content:R,tags:E}}async function maybeGetEventRelayUrl(R){return""}function isReplaceable(){if(this.kind===void 0)throw new Error("Kind not set");return[0,3].includes(this.kind)||this.kind>=1e4&&this.kind<2e4||this.kind>=3e4&&this.kind<4e4}function isEphemeral(){if(this.kind===void 0)throw new Error("Kind not set");return this.kind>=2e4&&this.kind<3e4}function isParamReplaceable(){if(this.kind===void 0)throw new Error("Kind not set");return this.kind>=3e4&&this.kind<4e4}var DEFAULT_ENCRYPTION_SCHEME="nip04";async function encrypt(R,E,U=DEFAULT_ENCRYPTION_SCHEME){if(!this.ndk)throw new Error("No NDK instance found!");if(E||(await this.ndk.assertSigner(),E=this.ndk.signer),!R){const H=this.getMatchingTags("p");if(H.length!==1)throw new Error("No recipient could be determined and no explicit recipient was provided");R=this.ndk.getUser({pubkey:H[0][1]})}this.content=await(E==null?void 0:E.encrypt(R,this.content,U))}async function decrypt(R,E,U=DEFAULT_ENCRYPTION_SCHEME){if(!this.ndk)throw new Error("No NDK instance found!");E||(await this.ndk.assertSigner(),E=this.ndk.signer),R||(R=this.author),this.content=await(E==null?void 0:E.decrypt(R,this.content,U))}function encode(R=5){let E=[];return this.onRelays.length>0?E=this.onRelays.map(U=>U.url):this.relay&&(E=[this.relay.url]),E.length>R&&(E=E.slice(0,R)),this.isParamReplaceable()?nip19_exports.naddrEncode({kind:this.kind,pubkey:this.pubkey,identifier:this.replaceableDTag(),relays:E}):E.length>0?nip19_exports.neventEncode({id:this.tagId(),relays:E,author:this.pubkey}):nip19_exports.noteEncode(this.tagId())}async function repost(R=!0,E){if(!E&&R){if(!this.ndk)throw new Error("No NDK instance found");this.ndk.assertSigner(),E=this.ndk.signer}const U=new NDKEvent(this.ndk,{kind:getKind(this),content:""});return U.tag(this),U.kind===16?U.tags.push(["k",`${this.kind}`]):U.content=JSON.stringify(this.rawEvent()),E&&await U.sign(E),R&&await U.publish(),U}function getKind(R){return R.kind===1?6:16}function eventHasETagMarkers(R){return R.getMatchingTags("e").some(E=>E[3])}function getRootTag(R,E){E??(E=R.tagType());const U=R.tags.find(H=>H[3]==="root");if(!U){if(eventHasETagMarkers(R))return;const H=R.getMatchingTags(E);if(H.length<3)return H[0]}return U}function getReplyTag(R,E){E??(E=R.tagType());let U=R.tags.find(H=>H[3]==="reply");if(U)return U;if(U||(U=R.tags.find(H=>H[3]==="root")),!U){if(eventHasETagMarkers(R))return;const H=R.getMatchingTags(E);if(H.length===1)return H[0];if(H.length===2)return H[1]}}async function fetchTaggedEvent(R,E){if(!this.ndk)throw new Error("NDK instance not found");const U=this.getMatchingTags(R,E);if(U.length===0)return;const[H,K,W]=U[0];return await this.ndk.fetchEvent(K,{},void 0)}async function fetchRootEvent(R){if(!this.ndk)throw new Error("NDK instance not found");const E=getRootTag(this);if(E)return this.ndk.fetchEventFromTag(E,this,R)}async function fetchReplyEvent(R){if(!this.ndk)throw new Error("NDK instance not found");const E=getReplyTag(this);if(E)return this.ndk.fetchEventFromTag(E,this,R)}function serialize(R=!1,E=!1){const U=[0,this.pubkey,this.created_at,this.kind,this.tags,this.content];return R&&U.push(this.sig),E&&U.push(this.id),JSON.stringify(U)}function deserialize(R){const E=JSON.parse(R),U={pubkey:E[1],created_at:E[2],kind:E[3],tags:E[4],content:E[5]};return E.length===7&&(U.sig=E[6]),E.length===8&&(U.id=E[7]),U}var worker,processingQueue={};function signatureVerificationInit(R){worker=R,worker.onmessage=E=>{const[U,H]=E.data,K=processingQueue[U];if(!K){console.error("No record found for event",U);return}delete processingQueue[U];for(const W of K.resolves)W(H)}}async function verifySignatureAsync(R,E){return new Promise(H=>{const K=R.serialize();let W=!1;processingQueue[R.id]||(processingQueue[R.id]={event:R,resolves:[]},W=!0),processingQueue[R.id].resolves.push(H),W&&worker.postMessage({serialized:K,id:R.id,sig:R.sig,pubkey:R.pubkey})})}var PUBKEY_REGEX=/^[a-f0-9]{64}$/;function validate(){if(typeof this.kind!="number"||typeof this.content!="string"||typeof this.created_at!="number"||typeof this.pubkey!="string"||!this.pubkey.match(PUBKEY_REGEX)||!Array.isArray(this.tags))return!1;for(let R=0;R<this.tags.length;R++){const E=this.tags[R];if(!Array.isArray(E))return!1;for(let U=0;U<E.length;U++)if(typeof E[U]=="object")return!1}return!0}var verifiedSignatures=new distExports.LRUCache({maxSize:1e3,entryExpirationTimeInMS:6e4});function verifySignature(R){var U;if(typeof this.signatureVerified=="boolean")return this.signatureVerified;const E=verifiedSignatures.get(this.id);if(E!==null)return this.signatureVerified=!!E;try{if((U=this.ndk)!=null&&U.asyncSigVerification)verifySignatureAsync(this,R).then(H=>{R&&(this.signatureVerified=H,H&&verifiedSignatures.set(this.id,this.sig)),H||(this.ndk.emit("event:invalid-sig",this),verifiedSignatures.set(this.id,!1))});else{const H=sha256$1(new TextEncoder().encode(this.serialize())),K=schnorr.verify(this.sig,H,this.pubkey);return K?verifiedSignatures.set(this.id,this.sig):verifiedSignatures.set(this.id,!1),this.signatureVerified=K}}catch{return this.signatureVerified=!1}}function getEventHash(){return getEventHashFromSerializedEvent(this.serialize())}function getEventHashFromSerializedEvent(R){const E=sha256$1(new TextEncoder().encode(R));return bytesToHex$1(E)}var skipClientTagOnKinds=[3],NDKEvent=class We extends libExports.EventEmitter{constructor(U,H){var K;super();le(this,"ndk");le(this,"created_at");le(this,"content","");le(this,"tags",[]);le(this,"kind");le(this,"id","");le(this,"sig");le(this,"pubkey","");le(this,"signatureVerified");le(this,"_author");le(this,"relay");le(this,"publishStatus","success");le(this,"publishError");le(this,"serialize",serialize.bind(this));le(this,"getEventHash",getEventHash.bind(this));le(this,"validate",validate.bind(this));le(this,"verifySignature",verifySignature.bind(this));le(this,"isReplaceable",isReplaceable.bind(this));le(this,"isEphemeral",isEphemeral.bind(this));le(this,"isParamReplaceable",isParamReplaceable.bind(this));le(this,"encode",encode.bind(this));le(this,"encrypt",encrypt.bind(this));le(this,"decrypt",decrypt.bind(this));le(this,"fetchTaggedEvent",fetchTaggedEvent.bind(this));le(this,"fetchRootEvent",fetchRootEvent.bind(this));le(this,"fetchReplyEvent",fetchReplyEvent.bind(this));le(this,"repost",repost.bind(this));this.ndk=U,this.created_at=H==null?void 0:H.created_at,this.content=(H==null?void 0:H.content)||"",this.tags=(H==null?void 0:H.tags)||[],this.id=(H==null?void 0:H.id)||"",this.sig=H==null?void 0:H.sig,this.pubkey=(H==null?void 0:H.pubkey)||"",this.kind=H==null?void 0:H.kind,H instanceof We&&(this.relay&&(this.relay=H.relay,(K=this.ndk)==null||K.subManager.seenEvent(H.id,this.relay)),this.publishStatus=H.publishStatus,this.publishError=H.publishError)}get onRelays(){let U=[];return this.ndk?U=this.ndk.subManager.seenEvents.get(this.id)||[]:this.relay&&U.push(this.relay),U}static deserialize(U,H){return new We(U,deserialize(H))}rawEvent(){return{created_at:this.created_at,content:this.content,tags:this.tags,kind:this.kind,pubkey:this.pubkey,id:this.id,sig:this.sig}}set author(U){var H;this.pubkey=U.pubkey,this._author=U,(H=this._author).ndk??(H.ndk=this.ndk)}get author(){if(this._author)return this._author;if(!this.ndk)throw new Error("No NDK instance found");const U=this.ndk.getUser({pubkey:this.pubkey});return this._author=U,U}tagExternal(U,H,K){let W=["i"],G=["k"];switch(H){case"url":const Z=new URL(U);Z.hash="",W.push(Z.toString()),G.push(`${Z.protocol}//${Z.host}`);break;case"hashtag":W.push(`#${U.toLowerCase()}`),G.push("#");break;case"geohash":W.push(`geo:${U.toLowerCase()}`),G.push("geo");break;case"isbn":W.push(`isbn:${U.replace(/-/g,"")}`),G.push("isbn");break;case"podcast:guid":W.push(`podcast:guid:${U}`),G.push("podcast:guid");break;case"podcast:item:guid":W.push(`podcast:item:guid:${U}`),G.push("podcast:item:guid");break;case"podcast:publisher:guid":W.push(`podcast:publisher:guid:${U}`),G.push("podcast:publisher:guid");break;case"isan":W.push(`isan:${U.split("-").slice(0,4).join("-")}`),G.push("isan");break;case"doi":W.push(`doi:${U.toLowerCase()}`),G.push("doi");break;default:throw new Error(`Unsupported NIP-73 entity type: ${H}`)}K&&W.push(K),this.tags.push(W),this.tags.push(G)}tag(U,H,K,W){let G=[];if(U.fetchProfile!==void 0){W??(W="p");const Y=[W,U.pubkey];H&&Y.push("",H),G.push(Y)}else if(U instanceof We){const Y=U;K??(K=(Y==null?void 0:Y.pubkey)===this.pubkey),G=Y.referenceTags(H,K,W);for(const X of Y.getMatchingTags("p"))X[1]!==this.pubkey&&(this.tags.find(Q=>Q[0]==="p"&&Q[1]===X[1])||this.tags.push(["p",X[1]]))}else if(Array.isArray(U))G=[U];else throw new Error("Invalid argument",U);this.tags=mergeTags(this.tags,G)}async toNostrEvent(U){var W,G;if(!U&&this.pubkey===""){const Z=await((G=(W=this.ndk)==null?void 0:W.signer)==null?void 0:G.user());this.pubkey=(Z==null?void 0:Z.pubkey)||""}this.created_at||(this.created_at=Math.floor(Date.now()/1e3));const{content:H,tags:K}=await this.generateTags();this.content=H||"",this.tags=K;try{this.id=this.getEventHash()}catch{}return this.rawEvent()}getMatchingTags(U,H){const K=this.tags.filter(W=>W[0]===U);return H===void 0?K:K.filter(W=>W[3]===H)}hasTag(U,H){return this.tags.some(K=>K[0]===U&&(!H||K[3]===H))}tagValue(U){const H=this.getMatchingTags(U);if(H.length!==0)return H[0][1]}get alt(){return this.tagValue("alt")}set alt(U){this.removeTag("alt"),U&&this.tags.push(["alt",U])}get dTag(){return this.tagValue("d")}set dTag(U){this.removeTag("d"),U&&this.tags.push(["d",U])}removeTag(U){const H=Array.isArray(U)?U:[U];this.tags=this.tags.filter(K=>!H.includes(K[0]))}async sign(U){var K;U?this.author=await U.user():((K=this.ndk)==null||K.assertSigner(),U=this.ndk.signer);const H=await this.toNostrEvent();return this.sig=await U.sign(H),this.sig}async publishReplaceable(U,H,K){return this.id="",this.created_at=Math.floor(Date.now()/1e3),this.sig="",this.publish(U,H,K)}async publish(U,H,K){var Z,Y;if(this.sig||await this.sign(),!this.ndk)throw new Error("NDKEvent must be associated with an NDK instance to publish");U||(U=this.ndk.devWriteRelaySet||await calculateRelaySetFromEvent(this.ndk,this)),this.kind===5&&((Z=this.ndk.cacheAdapter)!=null&&Z.deleteEvent)&&this.ndk.cacheAdapter.deleteEvent(this);const W=this.rawEvent();if((Y=this.ndk.cacheAdapter)!=null&&Y.addUnpublishedEvent)try{this.ndk.cacheAdapter.addUnpublishedEvent(this,U.relayUrls)}catch(X){console.error("Error adding unpublished event to cache",X)}this.ndk.subManager.subscriptions.forEach(X=>{X.filters.some(Q=>matchFilter(Q,W))&&X.eventReceived(this,void 0,!1,!0)});const G=await U.publish(this,H,K);return G.forEach(X=>{var Q;return(Q=this.ndk)==null?void 0:Q.subManager.seenEvent(this.id,X)}),G}async generateTags(){var W,G;let U=[];const H=await generateContentTags(this.content,this.tags),K=H.content;if(U=H.tags,this.kind&&this.isParamReplaceable()&&!this.getMatchingTags("d")[0]){const Y=this.tagValue("title");let Q=[...Array(Y?6:16)].map(()=>Math.random().toString(36)[2]).join("");Y&&Y.length>0&&(Q=Y.replace(/[^a-z0-9]+/gi,"-").replace(/^-|-$/g,"")+"-"+Q),U.push(["d",Q])}if(((W=this.ndk)!=null&&W.clientName||(G=this.ndk)!=null&&G.clientNip89)&&skipClientTagOnKinds.includes(this.kind)&&!this.tags.some(Z=>Z[0]==="client")){const Z=["client",this.ndk.clientName??""];this.ndk.clientNip89&&Z.push(this.ndk.clientNip89),U.push(Z)}return{content:K||"",tags:U}}muted(){var W,G;const U=(W=this.ndk)==null?void 0:W.mutedIds.get(this.pubkey);if(U&&U==="p")return"author";const H=this.tagReference(),K=(G=this.ndk)==null?void 0:G.mutedIds.get(H[1]);return K&&K===H[0]?"event":null}replaceableDTag(){if(this.kind&&this.kind>=3e4&&this.kind<=4e4){const U=this.getMatchingTags("d")[0];return U?U[1]:""}throw new Error("Event is not a parameterized replaceable event")}deduplicationKey(){return this.kind===0||this.kind===3||this.kind&&this.kind>=1e4&&this.kind<2e4?`${this.kind}:${this.pubkey}`:this.tagId()}tagId(){return this.isParamReplaceable()?this.tagAddress():this.id}tagAddress(){if(!this.isParamReplaceable())throw new Error("This must only be called on replaceable events");const U=this.replaceableDTag();return`${this.kind}:${this.pubkey}:${U}`}tagType(){return this.isParamReplaceable()?"a":"e"}tagReference(U){let H;return this.isParamReplaceable()?H=["a",this.tagAddress()]:H=["e",this.tagId()],this.relay?H.push(this.relay.url):H.push(""),U&&H.push(U),H}referenceTags(U,H,K){var G;let W=[];return this.isParamReplaceable()?W=[[K??"a",this.tagAddress()],[K??"e",this.id]]:W=[[K??"e",this.id]],(G=this.relay)!=null&&G.url?W=W.map(Z=>{var Y;return Z.push((Y=this.relay)==null?void 0:Y.url),Z}):U&&(W=W.map(Z=>(Z.push(""),Z))),U&&W.forEach(Z=>Z.push(U)),W=[...W,...this.getMatchingTags("h")],H||W.push(...this.author.referenceTags()),W}filter(){return this.isParamReplaceable()?{"#a":[this.tagId()]}:{"#e":[this.tagId()]}}async delete(U,H=!0){if(!this.ndk)throw new Error("No NDK instance found");this.ndk.assertSigner();const K=new We(this.ndk,{kind:5,content:U||""});return K.tag(this,void 0,!0),K.tags.push(["k",this.kind.toString()]),H&&await K.publish(),K}async react(U,H=!0){if(!this.ndk)throw new Error("No NDK instance found");this.ndk.assertSigner();const K=new We(this.ndk,{kind:7,content:U});return K.tag(this),H?await K.publish():await K.sign(),K}get isValid(){return this.validate()}};function queryFullyFilled(R){return!!(filterIncludesIds(R.filter)&&resultHasAllRequestedIds(R))}function filterIncludesIds(R){return!!R.ids}function resultHasAllRequestedIds(R){const E=R.filter.ids;return!!E&&E.length===R.eventFirstSeen.size}function filterFromId(R){let E;if(R.match(NIP33_A_REGEX)){const[U,H,K]=R.split(":"),W={authors:[H],kinds:[parseInt(U)]};return K&&(W["#d"]=[K]),W}if(R.match(BECH32_REGEX))try{switch(E=nip19_exports.decode(R),E.type){case"nevent":{const H={ids:[E.data.id]};return E.data.author&&(H.authors=[E.data.author]),E.data.kind&&(H.kinds=[E.data.kind]),H}case"note":return{ids:[E.data]};case"naddr":const U={authors:[E.data.pubkey],kinds:[E.data.kind]};return E.data.identifier&&(U["#d"]=[E.data.identifier]),U}}catch(U){console.error("Error decoding",R,U)}return{ids:[R]}}function isNip33AValue(R){return R.match(NIP33_A_REGEX)!==null}var NIP33_A_REGEX=/^(\d+):([0-9A-Fa-f]+)(?::(.*))?$/,BECH32_REGEX=/^n(event|ote|profile|pub|addr)1[\d\w]+$/;function relaysFromBech32(R,E){try{const U=nip19_exports.decode(R);if(["naddr","nevent"].includes(U==null?void 0:U.type)){const H=U.data;if(H!=null&&H.relays)return H.relays.map(K=>new NDKRelay(K,E==null?void 0:E.relayAuthDefaultPolicy,E))}}catch{}return[]}var defaultOpts={closeOnEose:!1,cacheUsage:"CACHE_FIRST",groupable:!0,groupableDelay:100,groupableDelayType:"at-most"},NDKSubscription=class extends libExports.EventEmitter{constructor(E,U,H,K,W){super();le(this,"subId");le(this,"filters");le(this,"opts");le(this,"pool");le(this,"skipVerification",!1);le(this,"skipValidation",!1);le(this,"relayFilters");le(this,"relaySet");le(this,"ndk");le(this,"debug");le(this,"eventFirstSeen",new Map);le(this,"eosesSeen",new Set);le(this,"lastEventReceivedAt");le(this,"internalId");le(this,"closeOnEose");le(this,"poolMonitor");le(this,"skipOptimisticPublishEvent",!1);le(this,"eoseTimeout");le(this,"eosed",!1);if(this.ndk=E,this.pool=(H==null?void 0:H.pool)||E.pool,this.opts={...defaultOpts,...H||{}},this.filters=U instanceof Array?U:[U],this.subId=W||(H==null?void 0:H.subId),this.internalId=Math.random().toString(36).substring(7),this.relaySet=K,this.debug=E.debug.extend(`subscription[${(H==null?void 0:H.subId)??this.internalId}]`),this.skipVerification=(H==null?void 0:H.skipVerification)||!1,this.skipValidation=(H==null?void 0:H.skipValidation)||!1,this.closeOnEose=(H==null?void 0:H.closeOnEose)||!1,this.skipOptimisticPublishEvent=(H==null?void 0:H.skipOptimisticPublishEvent)||!1,this.opts.cacheUsage==="ONLY_CACHE"&&!this.opts.closeOnEose)throw new Error("Cannot use cache-only options with a persistent subscription")}relaysMissingEose(){return this.relayFilters?Array.from(this.relayFilters.keys()).filter(U=>!this.eosesSeen.has(this.pool.getRelay(U,!1,!1))):[]}get filter(){return this.filters[0]}get groupableDelay(){var E;if(this.isGroupable())return(E=this.opts)==null?void 0:E.groupableDelay}get groupableDelayType(){var E;return((E=this.opts)==null?void 0:E.groupableDelayType)||"at-most"}isGroupable(){var E;return((E=this.opts)==null?void 0:E.groupable)||!1}shouldQueryCache(){var E;return((E=this.opts)==null?void 0:E.cacheUsage)!=="ONLY_RELAY"}shouldQueryRelays(){var E;return((E=this.opts)==null?void 0:E.cacheUsage)!=="ONLY_CACHE"}shouldWaitForCache(){var E;return this.opts.closeOnEose&&!!((E=this.ndk.cacheAdapter)!=null&&E.locking)&&this.opts.cacheUsage!=="PARALLEL"}async start(){let E;if(this.shouldQueryCache()&&(E=this.startWithCache(),this.shouldWaitForCache()&&(await E,queryFullyFilled(this)))){this.emit("eose",this);return}this.shouldQueryRelays()?(this.startWithRelays(),this.startPoolMonitor()):this.emit("eose",this)}startPoolMonitor(){this.debug.extend("pool-monitor"),this.poolMonitor=E=>{var H,K;if((H=this.relayFilters)!=null&&H.has(E.url))return;calculateRelaySetsFromFilters(this.ndk,this.filters,this.pool).get(E.url)&&((K=this.relayFilters)==null||K.set(E.url,this.filters),E.subscribe(this,this.filters))},this.pool.on("relay:connect",this.poolMonitor)}stop(){this.emit("close",this),this.poolMonitor&&this.pool.off("relay:connect",this.poolMonitor),this.removeAllListeners()}hasAuthorsFilter(){return this.filters.some(E=>{var U;return(U=E.authors)==null?void 0:U.length})}async startWithCache(){var E;if((E=this.ndk.cacheAdapter)!=null&&E.query){const U=this.ndk.cacheAdapter.query(this);this.ndk.cacheAdapter.locking&&await U}}startWithRelays(){if(!this.relaySet||this.relaySet.relays.size===0)this.relayFilters=calculateRelaySetsFromFilters(this.ndk,this.filters,this.pool);else{this.relayFilters=new Map;for(const E of this.relaySet.relays)this.relayFilters.set(E.url,this.filters)}if(!(!this.relayFilters||this.relayFilters.size===0))for(const[E,U]of this.relayFilters)this.pool.getRelay(E,!0,!0,U).subscribe(this,U)}eventReceived(E,U,H=!1,K=!1){const W=E.id,G=this.eventFirstSeen.has(W);let Z;if(E instanceof NDKEvent&&(Z=E),G){const Y=Date.now()-(this.eventFirstSeen.get(W)||0);if(this.emit("event:dup",W,U,Y,this),U){const X=verifiedSignatures.get(W);X&&typeof X=="string"&&E.sig===X&&U.addValidatedEvent()}}else{if(Z??(Z=new NDKEvent(this.ndk,E)),Z.ndk=this.ndk,Z.relay=U,!H&&!K){if(!this.skipValidation&&!Z.isValid){this.debug("Event failed validation %s from relay %s",W,U==null?void 0:U.url);return}if(U)if((U==null?void 0:U.shouldValidateEvent())!==!1){if(!this.skipVerification)if(!Z.verifySignature(!0)&&!this.ndk.asyncSigVerification){this.debug("Event failed signature validation",E);return}else U&&U.addValidatedEvent()}else U.addNonValidatedEvent();this.ndk.cacheAdapter&&this.ndk.cacheAdapter.setEvent(Z,this.filters,U)}!H&&U&&this.ndk.emit("event",Z,U),(!K||this.skipOptimisticPublishEvent!==!0)&&(this.emit("event",Z,U,this),this.eventFirstSeen.set(W,Date.now()))}this.lastEventReceivedAt=Date.now()}closedReceived(E,U){this.emit("closed",E,U)}eoseReceived(E){var G;this.debug("EOSE received from %s",E.url),this.eosesSeen.add(E);let U=this.lastEventReceivedAt?Date.now()-this.lastEventReceivedAt:void 0;const H=this.eosesSeen.size===((G=this.relayFilters)==null?void 0:G.size),K=queryFullyFilled(this),W=Z=>{var Y;this.debug("Performing EOSE: %s %d",Z,this.eosed),!this.eosed&&(this.eoseTimeout&&clearTimeout(this.eoseTimeout),this.emit("eose",this),this.eosed=!0,(Y=this.opts)!=null&&Y.closeOnEose&&this.stop())};if(K||H)W("query filled or seen all");else if(this.relayFilters){let Z=1e3;const Y=new Set(this.pool.connectedRelays().map(J=>J.url)),X=Array.from(this.relayFilters.keys()).filter(J=>Y.has(J));if(X.length===0)return;const Q=this.eosesSeen.size/X.length;if(this.eosesSeen.size>=2&&Q>=.5){if(Z=Z*(1-Q),Z===0){W("tiem to wait was 0");return}this.eoseTimeout&&clearTimeout(this.eoseTimeout);const J=()=>{U=this.lastEventReceivedAt?Date.now()-this.lastEventReceivedAt:void 0,U!==void 0&&U<20?this.eoseTimeout=setTimeout(J,Z):W("send eose timeout: "+Z)};this.eoseTimeout=setTimeout(J,Z)}}}};async function follows(R,E,U=3){var K,W;if(!this.ndk)throw new Error("NDK not set");const H=await this.ndk.fetchEvent({kinds:[U],authors:[this.pubkey]},R||{groupable:!1});if(H){const G=new Set;return H.tags.forEach(Z=>{Z[0]==="p"&&G.add(Z[1])}),E&&((W=(K=this.ndk)==null?void 0:K.outboxTracker)==null||W.trackUsers(Array.from(G))),[...G].reduce((Z,Y)=>{const X=new NDKUser({pubkey:Y});return X.ndk=this.ndk,Z.add(X),Z},new Set)}return new Set}function profileFromEvent(R){const E={};let U;try{U=JSON.parse(R.content)}catch(H){throw new Error(`Failed to parse profile event: ${H}`)}return E.created_at=R.created_at,E.profileEvent=JSON.stringify(R.rawEvent()),Object.keys(U).forEach(H=>{switch(H){case"name":E.name=U.name;break;case"display_name":E.displayName=U.display_name;break;case"image":case"picture":E.image=U.picture||U.image;break;case"banner":E.banner=U.banner;break;case"bio":E.bio=U.bio;break;case"nip05":E.nip05=U.nip05;break;case"lud06":E.lud06=U.lud06;break;case"lud16":E.lud16=U.lud16;break;case"about":E.about=U.about;break;case"zapService":E.zapService=U.zapService;break;case"website":E.website=U.website;break;default:E[H]=U[H];break}}),E}function serializeProfile(R){const E={};for(const[U,H]of Object.entries(R))switch(U){case"username":case"name":E.name=H;break;case"displayName":E.display_name=H;break;case"image":case"picture":E.picture=H;break;case"bio":case"about":E.about=H;break;default:E[U]=H;break}return JSON.stringify(E)}var NIP05_REGEX=/^(?:([\w.+-]+)@)?([\w.-]+)$/;async function getNip05For(R,E,U=fetch,H={}){return await R.queuesNip05.add({id:E,func:async()=>{if(R.cacheAdapter&&R.cacheAdapter.loadNip05){const Y=await R.cacheAdapter.loadNip05(E);if(Y!=="missing"){if(Y){const X=new NDKUser({pubkey:Y.pubkey,relayUrls:Y.relays,nip46Urls:Y.nip46});return X.ndk=R,X}else if(H.cache!=="no-cache")return null}}const K=E.match(NIP05_REGEX);if(!K)return null;const[W,G="_",Z]=K;try{const Y=await U(`https://${Z}/.well-known/nostr.json?name=${G}`,H),{names:X,relays:Q,nip46:J}=parseNIP05Result(await Y.json()),ne=X[G.toLowerCase()];let re=null;return ne&&(re={pubkey:ne,relays:Q==null?void 0:Q[ne],nip46:J==null?void 0:J[ne]}),R!=null&&R.cacheAdapter&&R.cacheAdapter.saveNip05&&R.cacheAdapter.saveNip05(E,re),re}catch(Y){return R!=null&&R.cacheAdapter&&R.cacheAdapter.saveNip05&&(R==null||R.cacheAdapter.saveNip05(E,null)),console.error("Failed to fetch NIP05 for",E,Y),null}}})}function parseNIP05Result(R){const E={names:{}};for(const[U,H]of Object.entries(R.names))typeof U=="string"&&typeof H=="string"&&(E.names[U.toLowerCase()]=H);if(R.relays){E.relays={};for(const[U,H]of Object.entries(R.relays))typeof U=="string"&&Array.isArray(H)&&(E.relays[U]=H.filter(K=>typeof K=="string"))}if(R.nip46){E.nip46={};for(const[U,H]of Object.entries(R.nip46))typeof U=="string"&&Array.isArray(H)&&(E.nip46[U]=H.filter(K=>typeof K=="string"))}return E}var ze,NDKCashuMintList=(ze=class extends NDKEvent{constructor(U,H){super(U,H);le(this,"_p2pk");this.kind??(this.kind=10019)}static from(U){return new ze(U.ndk,U)}set relays(U){this.tags=this.tags.filter(H=>H[0]!=="relay");for(const H of U)this.tags.push(["relay",H])}get relays(){const U=[];for(const H of this.tags)H[0]==="relay"&&U.push(H[1]);return U}set mints(U){this.tags=this.tags.filter(H=>H[0]!=="mint");for(const H of U)this.tags.push(["mint",H])}get mints(){const U=[];for(const H of this.tags)H[0]==="mint"&&U.push(H[1]);return Array.from(new Set(U))}get p2pk(){return this._p2pk?this._p2pk:(this._p2pk=this.tagValue("pubkey")??this.pubkey,this._p2pk)}set p2pk(U){this._p2pk=U,this.removeTag("pubkey"),U&&this.tags.push(["pubkey",U])}get relaySet(){return NDKRelaySet.fromRelayUrls(this.relays,this.ndk)}},le(ze,"kind",10019),le(ze,"kinds",[10019]),ze),d2=debug7("ndk:zapper:ln");async function getNip57ZapSpecFromLud({lud06:R,lud16:E},U){let H;if(E&&!E.startsWith("LNURL")){const[K,W]=E.split("@");H=`https://${W}/.well-known/lnurlp/${K}`}else if(R){const{words:K}=bech32.decode(R,1e3),W=bech32.fromWords(K);H=new TextDecoder("utf-8").decode(W)}if(!H)throw d2("No zap endpoint found %o",{lud06:R,lud16:E}),new Error("No zap endpoint found");try{const W=await(U.httpFetch||fetch)(H);if(W.status!==200){const G=await W.text();throw new Error(`Unable to fetch zap endpoint ${H}: ${G}`)}return await W.json()}catch(K){throw new Error(`Unable to fetch zap endpoint ${H}: ${K}`)}}var NDKUser=class Ye{constructor(E){le(this,"ndk");le(this,"profile");le(this,"_npub");le(this,"_pubkey");le(this,"relayUrls",[]);le(this,"nip46Urls",[]);le(this,"follows",follows.bind(this));E.npub&&(this._npub=E.npub),E.hexpubkey&&(this._pubkey=E.hexpubkey),E.pubkey&&(this._pubkey=E.pubkey),E.relayUrls&&(this.relayUrls=E.relayUrls),E.nip46Urls&&(this.nip46Urls=E.nip46Urls)}get npub(){if(!this._npub){if(!this._pubkey)throw new Error("pubkey not set");this._npub=nip19_exports.npubEncode(this.pubkey)}return this._npub}set npub(E){this._npub=E}get hexpubkey(){return this.pubkey}set hexpubkey(E){this._pubkey=E}get pubkey(){if(!this._pubkey){if(!this._npub)throw new Error("npub not set");this._pubkey=nip19_exports.decode(this.npub).data}return this._pubkey}set pubkey(E){this._pubkey=E}async getZapInfo(E=!0,U=["nip61","nip57"]){if(!this.ndk)throw new Error("No NDK instance found");const H=[];if(U.includes("nip61")&&H.push(10019),U.includes("nip57")&&H.push(0),H.length===0)return[];let K=await this.ndk.fetchEvents({kinds:H,authors:[this.pubkey]},{cacheUsage:"ONLY_CACHE",groupable:!1});K.size<U.length&&(K=await this.ndk.fetchEvents({kinds:H,authors:[this.pubkey]},{cacheUsage:"ONLY_RELAY"}));const W=[],G=Array.from(K).find(Y=>Y.kind===10019),Z=Array.from(K).find(Y=>Y.kind===0);if(G){const Y=NDKCashuMintList.from(G);if(Y.mints.length>0&&W.push({type:"nip61",data:{mints:Y.mints,relays:Y.relays,p2pk:Y.p2pk}}),!E)return W}if(Z){const Y=profileFromEvent(Z),{lud06:X,lud16:Q}=Y;try{const J=await getNip57ZapSpecFromLud({lud06:X,lud16:Q},this.ndk);J&&W.push({type:"nip57",data:J})}catch(J){console.error("Error getting NIP-57 zap spec",J)}}return W}async getZapConfiguration(E){if(E??(E=this.ndk),!E)throw new Error("No NDK instance found");const U=async()=>{var K,W,G,Z;if((W=(K=this.ndk)==null?void 0:K.cacheAdapter)!=null&&W.loadUsersLNURLDoc){const Y=await this.ndk.cacheAdapter.loadUsersLNURLDoc(this.pubkey);if(Y!=="missing"){if(Y===null)return;if(Y)return Y}}let H;try{if(await this.fetchProfile({groupable:!1}),this.profile){const{lud06:Y,lud16:X}=this.profile;H=await getNip57ZapSpecFromLud({lud06:Y,lud16:X},E)}}catch{}if((Z=(G=this.ndk)==null?void 0:G.cacheAdapter)!=null&&Z.saveUsersLNURLDoc&&this.ndk.cacheAdapter.saveUsersLNURLDoc(this.pubkey,H||null),!!H)return H};return await E.queuesZapConfig.add({id:this.pubkey,func:U})}async getZapperPubkey(){const E=await this.getZapConfiguration();return E==null?void 0:E.nostrPubkey}static async fromNip05(E,U,H=!1){if(!U)throw new Error("No NDK instance found");const K={};H&&(K.cache="no-cache");const W=await getNip05For(U,E,U==null?void 0:U.httpFetch,K);if(W){const G=new Ye({pubkey:W.pubkey,relayUrls:W.relays,nip46Urls:W.nip46});return G.ndk=U,G}}async fetchProfile(E,U=!1){if(!this.ndk)throw new Error("NDK not set");this.profile||(this.profile={});let H=null;if(this.ndk.cacheAdapter&&this.ndk.cacheAdapter.fetchProfile&&(E==null?void 0:E.cacheUsage)!=="ONLY_RELAY"){const G=await this.ndk.cacheAdapter.fetchProfile(this.pubkey);if(G)return this.profile=G,G}!E&&this.ndk.cacheAdapter&&this.ndk.cacheAdapter.locking&&(H=await this.ndk.fetchEvents({kinds:[0],authors:[this.pubkey]},{cacheUsage:"ONLY_CACHE",closeOnEose:!0,groupable:!1}),E={cacheUsage:"ONLY_RELAY",closeOnEose:!0,groupable:!0,groupableDelay:250}),(!H||H.size===0)&&(H=await this.ndk.fetchEvents({kinds:[0],authors:[this.pubkey]},E));const K=Array.from(H).sort((G,Z)=>G.created_at-Z.created_at);if(K.length===0)return null;const W=K[0];return this.profile=profileFromEvent(W),U&&(this.profile.profileEvent=JSON.stringify(W)),this.profile&&this.ndk.cacheAdapter&&this.ndk.cacheAdapter.saveProfile&&this.ndk.cacheAdapter.saveProfile(this.pubkey,this.profile),this.profile}tagReference(){return["p",this.pubkey]}referenceTags(E){const U=[["p",this.pubkey]];return E&&U[0].push("",E),U}async publish(){if(!this.ndk)throw new Error("No NDK instance found");if(!this.profile)throw new Error("No profile available");this.ndk.assertSigner(),await new NDKEvent(this.ndk,{kind:0,content:serializeProfile(this.profile)}).publish()}async follow(E,U,H=3){if(!this.ndk)throw new Error("No NDK instance found");if(this.ndk.assertSigner(),U||(U=await this.follows(void 0,void 0,H)),U.has(E))return!1;U.add(E);const K=new NDKEvent(this.ndk,{kind:H});for(const W of U)K.tag(W);return await K.publish(),!0}async unfollow(E,U,H=3){if(!this.ndk)throw new Error("No NDK instance found");this.ndk.assertSigner(),U||(U=await this.follows(void 0,void 0,H));const K=new Set;let W=!1;for(const Z of U)Z.pubkey!==E.pubkey?K.add(Z):W=!0;if(!W)return!1;const G=new NDKEvent(this.ndk,{kind:H});for(const Z of K)G.tag(Z);return await G.publish()}async validateNip05(E){if(!this.ndk)throw new Error("No NDK instance found");const U=await getNip05For(this.ndk,E);return U===null?null:U.pubkey===this.pubkey}async zap(E,U,H,K){return new Promise((W,G)=>{var X;if(!this.ndk){G("No NDK instance found");return}let Z=(X=this.ndk.walletConfig)==null?void 0:X.onLnPay;Z??(Z=async({pr:Q})=>{W(Q)}),this.ndk.zap(this,E,{comment:U,tags:H,signer:K,onLnPay:Z}).zap().then(W).catch(G)})}},NDKList=class Je extends NDKEvent{constructor(U,H){super(U,H);le(this,"_encryptedTags");le(this,"encryptedTagsLength");this.kind??(this.kind=30001)}static from(U){return new Je(U.ndk,U)}get title(){const U=this.tagValue("title")||this.tagValue("name");return U||(this.kind===3?"Contacts":this.kind===1e4?"Mute":this.kind===10001?"Pinned Notes":this.kind===10002?"Relay Metadata":this.kind===10003?"Bookmarks":this.kind===10004?"Communities":this.kind===10005?"Public Chats":this.kind===10006?"Blocked Relays":this.kind===10007?"Search Relays":this.kind===10050?"Direct Message Receive Relays":this.kind===10015?"Interests":this.kind===10030?"Emojis":this.tagValue("d"))}set title(U){this.removeTag(["title","name"]),U&&this.tags.push(["title",U])}get name(){return this.title}set name(U){this.title=U}get description(){return this.tagValue("description")}set description(U){this.removeTag("description"),U&&this.tags.push(["description",U])}get image(){return this.tagValue("image")}set image(U){this.removeTag("image"),U&&this.tags.push(["image",U])}isEncryptedTagsCacheValid(){return!!(this._encryptedTags&&this.encryptedTagsLength===this.content.length)}async encryptedTags(U=!0){if(U&&this.isEncryptedTagsCacheValid())return this._encryptedTags;if(!this.ndk)throw new Error("NDK instance not set");if(!this.ndk.signer)throw new Error("NDK signer not set");const H=await this.ndk.signer.user();try{if(this.content.length>0)try{const K=await this.ndk.signer.decrypt(H,this.content),W=JSON.parse(K);return W&&W[0]?(this.encryptedTagsLength=this.content.length,this._encryptedTags=W):(this.encryptedTagsLength=this.content.length,this._encryptedTags=[])}catch{console.log(`error decrypting ${this.content}`)}}catch{}return[]}validateTag(U){return!0}getItems(U){return this.tags.filter(H=>H[0]===U)}get items(){return this.tags.filter(U=>!["d","L","l","title","name","description","published_at","summary","image","thumb","alt","expiration","subject","client"].includes(U[0]))}async addItem(U,H=void 0,K=!1,W="bottom"){if(!this.ndk)throw new Error("NDK instance not set");if(!this.ndk.signer)throw new Error("NDK signer not set");let G;if(U instanceof NDKEvent)G=[U.tagReference(H)];else if(U instanceof NDKUser)G=U.referenceTags();else if(U instanceof NDKRelay)G=U.referenceTags();else if(Array.isArray(U))G=[U];else throw new Error("Invalid object type");if(H&&G[0].push(H),K){const Z=await this.ndk.signer.user(),Y=await this.encryptedTags();W==="top"?Y.unshift(...G):Y.push(...G),this._encryptedTags=Y,this.encryptedTagsLength=this.content.length,this.content=JSON.stringify(Y),await this.encrypt(Z)}else W==="top"?this.tags.unshift(...G):this.tags.push(...G);this.created_at=Math.floor(Date.now()/1e3),this.emit("change")}async removeItemByValue(U,H=!0){if(!this.ndk)throw new Error("NDK instance not set");if(!this.ndk.signer)throw new Error("NDK signer not set");const K=this.tags.findIndex(Y=>Y[1]===U);K>=0&&this.tags.splice(K,1);const W=await this.ndk.signer.user(),G=await this.encryptedTags(),Z=G.findIndex(Y=>Y[1]===U);if(Z>=0&&(G.splice(Z,1),this._encryptedTags=G,this.encryptedTagsLength=this.content.length,this.content=JSON.stringify(G),await this.encrypt(W)),H)return this.publishReplaceable();this.created_at=Math.floor(Date.now()/1e3),this.emit("change")}async removeItem(U,H){if(!this.ndk)throw new Error("NDK instance not set");if(!this.ndk.signer)throw new Error("NDK signer not set");if(H){const K=await this.ndk.signer.user(),W=await this.encryptedTags();W.splice(U,1),this._encryptedTags=W,this.encryptedTagsLength=this.content.length,this.content=JSON.stringify(W),await this.encrypt(K)}else this.tags.splice(U,1);return this.created_at=Math.floor(Date.now()/1e3),this.emit("change"),this}has(U){return this.items.some(H=>H[1]===U)}filterForItems(){const U=new Set,H=new Map,K=[];for(const W of this.items)if(W[0]==="e"&&W[1])U.add(W[1]);else if(W[0]==="a"&&W[1]){const[G,Z,Y]=W[1].split(":");if(!G||!Z)continue;const X=`${G}:${Z}`,Q=H.get(X)||[];Q.push(Y||""),H.set(X,Q)}if(U.size>0&&K.push({ids:Array.from(U)}),H.size>0)for(const[W,G]of H.entries()){const[Z,Y]=W.split(":");K.push({kinds:[parseInt(Z)],authors:[Y],"#d":G})}return K}},lists_default=NDKList,READ_MARKER="read",WRITE_MARKER="write",NDKRelayList=class Xe extends NDKEvent{constructor(E,U){super(E,U),this.kind??(this.kind=10002)}static from(E){return new Xe(E.ndk,E.rawEvent())}get readRelayUrls(){return this.tags.filter(E=>E[0]==="r"||E[0]==="relay").filter(E=>!E[2]||E[2]&&E[2]===READ_MARKER).map(E=>tryNormalizeRelayUrl(E[1])).filter(E=>!!E)}set readRelayUrls(E){for(const U of E)this.tags.push(["r",U,READ_MARKER])}get writeRelayUrls(){return this.tags.filter(E=>E[0]==="r"||E[0]==="relay").filter(E=>!E[2]||E[2]&&E[2]===WRITE_MARKER).map(E=>tryNormalizeRelayUrl(E[1])).filter(E=>!!E)}set writeRelayUrls(E){for(const U of E)this.tags.push(["r",U,WRITE_MARKER])}get bothRelayUrls(){return this.tags.filter(E=>E[0]==="r"||E[0]==="relay").filter(E=>!E[2]).map(E=>E[1])}set bothRelayUrls(E){for(const U of E)this.tags.push(["r",U])}get relays(){return this.tags.filter(E=>E[0]==="r"||E[0]==="relay").map(E=>E[1])}get relaySet(){if(!this.ndk)throw new Error("NDKRelayList has no NDK instance");return new NDKRelaySet(new Set(this.relays.map(E=>this.ndk.pool.getRelay(E))),this.ndk)}};function relayListFromKind3(R,E){try{const U=JSON.parse(E.content),H=new NDKRelayList(R),K=new Set,W=new Set;for(let[G,Z]of Object.entries(U)){try{G=normalizeRelayUrl(G)}catch{continue}if(!Z)K.add(G),W.add(G);else{const Y=Z;Y.write&&W.add(G),Y.read&&K.add(G)}}return H.readRelayUrls=Array.from(K),H.writeRelayUrls=Array.from(W),H}catch{}}var Ve,NDKNutzap=(Ve=class extends NDKEvent{constructor(U,H){super(U,H);le(this,"debug");le(this,"_proofs",[]);le(this,"sender",this.author);this.kind??(this.kind=9321),this.debug=(U==null?void 0:U.debug.extend("nutzap"))??debug7("ndk:nutzap"),this.alt||(this.alt="This is a nutzap")}static from(U){const H=new this(U.ndk,U);try{const K=H.getMatchingTags("proof");K.length?H._proofs=K.map(W=>JSON.parse(W[1])):H._proofs=JSON.parse(H.content)}catch{return}if(!(!H._proofs||!H._proofs.length))return H}set comment(U){this.content=U??""}get comment(){const U=this.tagValue("comment");return U||this.content}set proofs(U){this._proofs=U,this.tags=this.tags.filter(H=>H[0]!=="proof");for(const H of U)this.tags.push(["proof",JSON.stringify(H)]);this.removeTag("amount"),this.tags.push(["amount",this.amount.toString()])}get proofs(){return this._proofs}get p2pk(){var H;const U=this.proofs[0];try{const K=JSON.parse(U.secret);let W={};if(typeof K=="string"?(W=JSON.parse(K),this.debug("stringified payload",U.secret)):typeof K=="object"&&(W=K),W[0]==="P2PK"&&((H=W[1])==null?void 0:H.data)){const Y=W[1].data.slice(2,-1);if(Y)return Y}}catch(K){this.debug("error parsing p2pk pubkey",K,this.proofs[0])}}get mint(){return this.tagValue("u")}set mint(U){this.removeTag("u"),this.tag(["u",U])}get unit(){return this.tagValue("unit")??"msat"}set unit(U){this.removeTag("unit"),U&&this.tag(["unit",U])}get amount(){return this.proofs.reduce((H,K)=>H+K.amount,0)*1e3}set target(U){this.tags=this.tags.filter(H=>H[0]!=="p"),U instanceof NDKEvent&&this.tags.push()}set recipientPubkey(U){this.removeTag("p"),this.tag(["p",U])}get recipientPubkey(){return this.tagValue("p")}get recipient(){const U=this.recipientPubkey;return this.ndk?this.ndk.getUser({pubkey:U}):new NDKUser({pubkey:U})}get isValid(){let U=0,H=0;for(const K of this.tags)K[0]==="p"&&U++,K[0]==="u"&&H++;return U===1&&H===1&&this.proofs.length>0}},le(Ve,"kind",9321),le(Ve,"kinds",[Ve.kind]),Ve);async function payInvoice(R){return await this.sendReq("pay_invoice",{invoice:R})}var NDKPrivateKeySigner=class Qe{constructor(E){le(this,"_user");le(this,"_privateKey");if(E){if(typeof E=="string")if(E.startsWith("nsec1")){const{type:U,data:H}=nip19_exports.decode(E);U==="nsec"&&(this._privateKey=H)}else if(E.length===64)this._privateKey=hexToBytes$1(E);else throw new Error("Invalid private key provided.");else this._privateKey=E;this._privateKey&&(this._user=new NDKUser({pubkey:getPublicKey(this._privateKey)}))}}get privateKey(){if(this._privateKey)return bytesToHex$1(this._privateKey)}static generate(){const E=generateSecretKey();return new Qe(E)}async blockUntilReady(){if(!this._user)throw new Error("NDKUser not initialized");return this._user}async user(){return await this.blockUntilReady(),this._user}async sign(E){if(!this._privateKey)throw Error("Attempted to sign without a private key");return finalizeEvent(E,this._privateKey).sig}getConversationKey(E){if(!this._privateKey)throw Error("Attempted to get conversation key without a private key");const U=E.pubkey;return nip44_exports.getConversationKey(this._privateKey,U)}async nip44Encrypt(E,U){const H=this.getConversationKey(E);return await nip44_exports.encrypt(U,H)}async nip44Decrypt(E,U){const H=this.getConversationKey(E);return await nip44_exports.decrypt(U,H)}async encrypt(E,U,H=DEFAULT_ENCRYPTION_SCHEME){return H==="nip44"?this.nip44Encrypt(E,U):this.nip04Encrypt(E,U)}async decrypt(E,U,H=DEFAULT_ENCRYPTION_SCHEME){return H==="nip44"?this.nip44Decrypt(E,U):this.nip04Decrypt(E,U)}async nip04Encrypt(E,U){if(!this._privateKey)throw Error("Attempted to encrypt without a private key");const H=E.pubkey;return await nip04_exports.encrypt(this._privateKey,H,U)}async nip04Decrypt(E,U){if(!this._privateKey)throw Error("Attempted to decrypt without a private key");const H=E.pubkey;return await nip04_exports.decrypt(this._privateKey,H,U)}};async function sendReq(R,E){const U=new NDKEvent(this.ndk,{kind:23194,tags:[["p",this.walletService.pubkey]],content:JSON.stringify({method:R,params:E})});return this.debug("Sending request",U.content),await U.encrypt(this.walletService,this.signer),await U.sign(this.signer),this.debug("Request encrypted and signed"),new Promise(async(H,K)=>{try{const W=U.tagId();if(!W)throw new Error("Failed to get e-tag");const G=Y=>{this.off(W,G),this.off("event",G),this.debug("Received response",Y);try{const X=JSON.parse(Y);X.error&&K(X),H(X)}catch(X){this.debug("Failed to parse response",X),K({result_type:"error",error:{code:"failed_to_parse_response",message:X.message}})}},Z=this.ndk.subscribe({kinds:[23195],"#e":[W],limit:1},{groupable:!1,subId:`nwc-${R}`},this.relaySet);Z.on("event",async Y=>{await Y.decrypt(Y.author,this.signer),G(Y.content),Z.stop()}),this.once(W,G),this.once("event",G),this.debug("Sending request to relay",U.rawEvent()),await U.publish(this.relaySet)}catch(W){this.debug("Failed to send request",W,W.relayErrors),K({result_type:"error",error:{code:"failed_to_send_request",message:W.message}})}})}async function getBalance(){return await this.sendReq("get_balance",{})}async function getInfo(){return await this.sendReq("get_info",{})}var NDKNwc=class et extends libExports.EventEmitter{constructor({ndk:U,pubkey:H,relayUrls:K,secret:W}){super();le(this,"ndk");le(this,"debug");le(this,"walletService");le(this,"relaySet");le(this,"signer");le(this,"active",!1);le(this,"getBalance",getBalance.bind(this));this.ndk=U,this.walletService=U.getUser({pubkey:H}),this.relaySet=new NDKRelaySet(new Set(K.map(G=>U.pool.getRelay(G))),U),this.signer=new NDKPrivateKeySigner(W instanceof Uint8Array?W:hexToBytes$1(W)),this.debug=U.debug.extend("nwc"),this.debug(`Starting with wallet service ${this.walletService.npub}`)}static async fromURI(U,H){const K=new URL(H);if(K.protocol!=="nostr+walletconnect:")throw new Error("Invalid protocol");return new et({ndk:U,pubkey:K.host??K.pathname,relayUrls:K.searchParams.getAll("relay")??[""],secret:K.searchParams.get("secret")??""})}async blockUntilReady(U){const H=await this.signer.user(),K=new Promise((Z,Y)=>{setTimeout(()=>{Y(new Error("Timeout"))},U)}),G=[new Promise(Z=>{const Y=this.ndk.subscribe({kinds:[23195],"#p":[H.pubkey],limit:1},{groupable:!1,subId:"nwc"},this.relaySet);Y.on("event",async X=>{this.debug("received response",X.rawEvent());const Q=X.tagValue("e");if(!Q){this.debug("Received an event without an e-tag");return}this.debug("received an event",Q);try{await X.decrypt(X.author,this.signer),this.emit(Q,X.content)}catch(J){this.debug("Failed to decrypt event",J);return}}),Y.on("eose",()=>{this.debug("Subscription ready"),this.active=!0,Z()}),Y.on("close",()=>{this.debug("Subscription closed"),this.active=!1})})];return U&&G.push(K),await Promise.race(G)}async sendReq(U,H){return await sendReq.call(this,U,H)}async payInvoice(U){return await payInvoice.call(this,U)}async getInfo(){return await getInfo.call(this)}};function disconnect(R,E){return E??(E=debug7("ndk:relay:auth-policies:disconnect")),async U=>{E(`Relay ${U.url} requested authentication, disconnecting`),R.removeRelay(U.url)}}async function signAndAuth(R,E,U,H,K,W){try{await R.sign(U),K(R)}catch(G){H(`Failed to publish auth event to relay ${E.url}`,G),W(R)}}function signIn({ndk:R,signer:E,debug:U}={}){return U??(U=debug7("ndk:auth-policies:signIn")),async(H,K)=>{U(`Relay ${H.url} requested authentication, signing in`);const W=new NDKEvent(R);return W.kind=22242,W.tags=[["relay",H.url],["challenge",K]],E??(E=R==null?void 0:R.signer),new Promise(async(G,Z)=>{E?await signAndAuth(W,H,E,U,G,Z):R==null||R.once("signer:ready",async Y=>{await signAndAuth(W,H,Y,U,G,Z)})})}}var NDKRelayAuthPolicies={disconnect,signIn},NDKPool=class extends libExports.EventEmitter{constructor(E=[],U=[],H,K){super();le(this,"_relays",new Map);le(this,"autoConnectRelays",new Set);le(this,"blacklistRelayUrls");le(this,"debug");le(this,"temporaryRelayTimers",new Map);le(this,"flappingRelays",new Set);le(this,"backoffTimes",new Map);le(this,"ndk");this.debug=K??H.debug.extend("pool"),this.ndk=H,this.relayUrls=E,this.blacklistRelayUrls=new Set(U)}get relays(){return this._relays}set relayUrls(E){this._relays.clear();for(const U of E){const H=new NDKRelay(U,void 0,this.ndk);H.connectivity.netDebug=this.ndk.netDebug,this.addRelay(H,!1)}}set name(E){this.debug=this.debug.extend(E)}useTemporaryRelay(E,U=3e4,H){const K=this.relays.has(E.url);K||(this.addRelay(E),this.debug("Adding temporary relay %s for filters %o",E.url,H));const W=this.temporaryRelayTimers.get(E.url);if(W&&clearTimeout(W),!K||W){const G=setTimeout(()=>{var Z;(Z=this.ndk.explicitRelayUrls)!=null&&Z.includes(E.url)||this.removeRelay(E.url)},U);this.temporaryRelayTimers.set(E.url,G)}}addRelay(E,U=!0){var te,se;const H=this.relays.has(E.url),K=(te=this.blacklistRelayUrls)==null?void 0:te.has(E.url),W=E.url.includes("/npub1");let G=!0;const Z=E.url;if(H)return;if(K){this.debug(`Refusing to add relay ${Z}: blacklisted`);return}if(W){this.debug(`Refusing to add relay ${Z}: is a filter relay`);return}if((se=this.ndk.cacheAdapter)!=null&&se.getRelayStatus){const ie=this.ndk.cacheAdapter.getRelayStatus(Z);if(ie&&ie.dontConnectBefore)if(ie.dontConnectBefore>Date.now()){const ye=ie.dontConnectBefore-Date.now();this.debug(`Refusing to add relay ${Z}: delayed connect for ${ye}ms`),setTimeout(()=>{this.addRelay(E,U)},ye);return}else G=!1}const Y=ie=>this.emit("notice",E,ie),X=()=>this.handleRelayConnect(Z),Q=()=>this.handleRelayReady(E),J=()=>this.emit("relay:disconnect",E),ne=()=>this.handleFlapping(E),re=ie=>this.emit("relay:auth",E,ie),ae=()=>this.emit("relay:authed",E);E.off("notice",Y),E.off("connect",X),E.off("ready",Q),E.off("disconnect",J),E.off("flapping",ne),E.off("auth",re),E.off("authed",ae),E.on("notice",Y),E.on("connect",X),E.on("ready",Q),E.on("disconnect",J),E.on("flapping",ne),E.on("auth",re),E.on("authed",ae),E.on("delayed-connect",ie=>{var ye;(ye=this.ndk.cacheAdapter)!=null&&ye.updateRelayStatus&&this.ndk.cacheAdapter.updateRelayStatus(E.url,{dontConnectBefore:Date.now()+ie})}),this.relays.set(Z,E),U&&this.autoConnectRelays.add(Z),U&&(this.emit("relay:connecting",E),E.connect(void 0,G).catch(ie=>{this.debug(`Failed to connect to relay ${Z}`,ie)}))}removeRelay(E){const U=this.relays.get(E);if(U)return U.disconnect(),this.relays.delete(E),this.autoConnectRelays.delete(E),this.emit("relay:disconnect",U),!0;const H=this.temporaryRelayTimers.get(E);return H&&(clearTimeout(H),this.temporaryRelayTimers.delete(E)),!1}isRelayConnected(E){const U=normalizeRelayUrl(E),H=this.relays.get(U);return H?H.status===5:!1}getRelay(E,U=!0,H=!1,K){let W=this.relays.get(normalizeRelayUrl(E));return W||(W=new NDKRelay(E,void 0,this.ndk),W.connectivity.netDebug=this.ndk.netDebug,H?this.useTemporaryRelay(W,3e4,K):this.addRelay(W,U)),W}handleRelayConnect(E){this.emit("relay:connect",this.relays.get(E)),this.stats().connected===this.relays.size&&this.emit("connect")}handleRelayReady(E){this.emit("relay:ready",E)}async connect(E){var K;const U=[];this.debug(`Connecting to ${this.relays.size} relays${E?`, timeout ${E}...`:""}`);const H=new Set(this.autoConnectRelays.keys());(K=this.ndk.explicitRelayUrls)==null||K.forEach(W=>{const G=normalizeRelayUrl(W);H.add(G)});for(const W of H){const G=this.relays.get(W);if(!G)continue;const Z=new Promise((Y,X)=>(this.emit("relay:connecting",G),G.connect(E).then(Y).catch(X)));if(E){const Y=new Promise((X,Q)=>{setTimeout(()=>Q(`Timed out after ${E}ms`),E)});U.push(Promise.race([Z,Y]).catch(X=>{this.debug(`Failed to connect to relay ${G.url}: ${X??"No reason specified"}`)}))}else U.push(Z)}E&&setTimeout(()=>{const W=this.stats().connected===this.relays.size,G=this.stats().connected>0;!W&&G&&this.emit("connect")},E),await Promise.all(U)}checkOnFlappingRelays(){const E=this.flappingRelays.size,U=this.relays.size;if(E/U>=.8)for(const H of this.flappingRelays)this.backoffTimes.set(H,0)}handleFlapping(E){this.debug(`Relay ${E.url} is flapping`);let U=this.backoffTimes.get(E.url)||5e3;U=U*2,this.backoffTimes.set(E.url,U),this.debug(`Backoff time for ${E.url} is ${U}ms`),setTimeout(()=>{this.debug(`Attempting to reconnect to ${E.url}`),this.emit("relay:connecting",E),E.connect(),this.checkOnFlappingRelays()},U),E.disconnect(),this.emit("flapping",E)}size(){return this.relays.size}stats(){const E={total:0,connected:0,disconnected:0,connecting:0};for(const U of this.relays.values())E.total++,U.status===5?E.connected++:U.status===1?E.disconnected++:U.status===4&&E.connecting++;return E}connectedRelays(){return Array.from(this.relays.values()).filter(E=>E.status>=5)}permanentAndConnectedRelays(){return Array.from(this.relays.values()).filter(E=>E.status>=5&&!this.temporaryRelayTimers.has(E.url))}urls(){return Array.from(this.relays.keys())}};function dedup(R,E){return R.created_at>E.created_at?R:E}async function getRelayListForUser(R,E){return(await getRelayListForUsers([R],E)).get(R)}async function getRelayListForUsers(R,E,U=!1){var Q;const H=E.outboxPool||E.pool,K=new Set;for(const J of H.relays.values())K.add(J);const W=new Map,G=new Map,Z=new NDKRelaySet(K,E);if((Q=E.cacheAdapter)!=null&&Q.locking&&!U){const J=await E.fetchEvents({kinds:[3,10002],authors:R},{cacheUsage:"ONLY_CACHE"});for(const ne of J)ne.kind===10002&&W.set(ne.pubkey,NDKRelayList.from(ne));for(const ne of J)if(ne.kind===3){if(W.has(ne.pubkey))continue;const re=relayListFromKind3(E,ne);re&&G.set(ne.pubkey,re)}R=R.filter(ne=>!W.has(ne)&&!G.has(ne))}if(R.length===0)return W;const Y=new Map,X=new Map;return new Promise(async J=>{const ne=E.subscribe({kinds:[3,10002],authors:R},{closeOnEose:!0,pool:H,groupable:!0,cacheUsage:"ONLY_RELAY",subId:"ndk-relay-list-fetch"},Z,!1);ne.on("event",re=>{if(re.kind===10002){const ae=Y.get(re.pubkey);if(ae&&ae.created_at>re.created_at)return;Y.set(re.pubkey,re)}else if(re.kind===3){const ae=X.get(re.pubkey);if(ae&&ae.created_at>re.created_at)return;X.set(re.pubkey,re)}}),ne.on("eose",()=>{for(const re of Y.values())W.set(re.pubkey,NDKRelayList.from(re));for(const re of R){if(W.has(re))continue;const ae=X.get(re);if(!ae)continue;const te=relayListFromKind3(E,ae);te&&W.set(re,te)}J(W)}),ne.start()})}var OutboxItem=class{constructor(R){le(this,"type");le(this,"relayUrlScores");le(this,"readRelays");le(this,"writeRelays");this.type=R,this.relayUrlScores=new Map,this.readRelays=new Set,this.writeRelays=new Set}},OutboxTracker=class extends libExports.EventEmitter{constructor(E){super();le(this,"data");le(this,"ndk");le(this,"debug");this.ndk=E,this.debug=E.debug.extend("outbox-tracker"),this.data=new distExports.LRUCache({maxSize:1e5,entryExpirationTimeInMS:2*60*1e3})}async trackUsers(E,U=!1){const H=[];for(let K=0;K<E.length;K+=400){const G=E.slice(K,K+400).map(Z=>getKeyFromItem(Z)).filter(Z=>!this.data.has(Z));if(G.length!==0){for(const Z of G)this.data.set(Z,new OutboxItem("user"));H.push(new Promise(Z=>{getRelayListForUsers(G,this.ndk,U).then(Y=>{for(const[X,Q]of Y){let J=this.data.get(X);if(J??(J=new OutboxItem("user")),Q){J.readRelays=new Set(normalize(Q.readRelayUrls)),J.writeRelays=new Set(normalize(Q.writeRelayUrls));for(const ne of J.readRelays)this.ndk.pool.blacklistRelayUrls.has(ne)&&J.readRelays.delete(ne);for(const ne of J.writeRelays)this.ndk.pool.blacklistRelayUrls.has(ne)&&J.writeRelays.delete(ne);this.data.set(X,J)}}}).finally(Z)}))}}return Promise.all(H)}track(E,U,H=!0){const K=getKeyFromItem(E);U??(U=getTypeFromItem(E));let W=this.data.get(K);return W||(W=new OutboxItem(U),E instanceof NDKUser&&this.trackUsers([E])),W}};function getKeyFromItem(R){return R instanceof NDKUser?R.pubkey:R}function getTypeFromItem(R){return R instanceof NDKUser?"user":"kind"}function correctRelaySet(R,E){const U=E.connectedRelays();if(!Array.from(R.relays).some(K=>U.map(W=>W.url).includes(K.url)))for(const K of U)R.addRelay(K);if(U.length===0)for(const K of E.relays.values())R.addRelay(K);return R}function isValidHint(R){if(!R||R==="")return!1;try{return new URL(R),!0}catch{return!1}}async function fetchEventFromTag(R,E,U,H={type:"timeout"}){const K=this.debug.extend("fetch-event-from-tag"),[W,G,Z]=R;U={},K("fetching event from tag",R,U,H);const Y=getRelaysForSync(this,E.pubkey);if(Y&&Y.size>0){K("fetching event from author relays %o",Array.from(Y));const te=NDKRelaySet.fromRelayUrls(Array.from(Y),this),se=await this.fetchEvent(G,U,te);if(se)return se}else K("no author relays found for %s",E.pubkey,E);const X=calculateRelaySetsFromFilters(this,[{ids:[G]}],this.pool);K("fetching event without relay hint",X);const Q=await this.fetchEvent(G,U);if(Q)return Q;if(Z&&Z!==""){const te=await this.fetchEvent(G,U,this.pool.getRelay(Z,!0,!0,[{ids:[G]}]));if(te)return te}let J;const ne=isValidHint(Z)?this.pool.getRelay(Z,!1,!0,[{ids:[G]}]):void 0,re=new Promise(te=>{this.fetchEvent(G,U,ne).then(te)});if(!isValidHint(Z)||H.type==="none")return re;const ae=new Promise(async te=>{const se=H.relaySet,ie=H.timeout??1500,ye=new Promise(me=>setTimeout(me,ie));if(H.type==="timeout"&&await ye,J)te(J);else{K("fallback fetch triggered");const me=await this.fetchEvent(G,U,se);te(me)}});switch(H.type){case"timeout":return Promise.race([re,ae]);case"eose":return J=await re,J||ae}}var SPEC_PATH="/.well-known/nostr/nip96.json",Nip96=class{constructor(R,E){le(this,"ndk");le(this,"spec");le(this,"url");le(this,"nip98Required",!1);this.url=`https://${R}${SPEC_PATH}`,this.ndk=E}async prepareUpload(R,E="POST"){if(this.validateHttpFetch(),this.spec||await this.fetchSpec(),!this.spec)throw new Error("Failed to fetch NIP96 spec");let U={};return this.nip98Required&&(U={Authorization:await this.generateNip98Header(this.spec.api_url,E,R)}),{url:this.spec.api_url,headers:U}}async xhrUpload(R,E){const U="POST",{url:H,headers:K}=await this.prepareUpload(E,U);R.open(U,H,!0),K.Authorization&&R.setRequestHeader("Authorization",K.Authorization);const W=new FormData;return W.append("file",E),new Promise((G,Z)=>{R.onload=function(){R.status>=200&&R.status<300?G(JSON.parse(R.responseText)):Z(new Error(R.statusText))},R.onerror=function(){Z(new Error("Network Error"))},R.send(W)})}async upload(R){const E="POST",{url:U,headers:H}=await this.prepareUpload(R,E),K=new FormData;K.append("file",R);const W=await this.ndk.httpFetch(this.spec.api_url,{method:E,headers:H,body:K});if(W.status!==200)throw new Error(`Failed to upload file to ${U}`);const G=await W.json();if(G.status!=="success")throw new Error(G.message);return G}validateHttpFetch(){if(!this.ndk)throw new Error("NDK is required to fetch NIP96 spec");if(!this.ndk.httpFetch)throw new Error("NDK must have an httpFetch method to fetch NIP96 spec")}async fetchSpec(){this.validateHttpFetch();const R=await this.ndk.httpFetch(this.url);if(R.status!==200)throw new Error(`Failed to fetch NIP96 spec from ${this.url}`);const E=await R.json();if(!E)throw new Error(`Failed to parse NIP96 spec from ${this.url}`);this.spec=E,this.nip98Required=this.spec.plans.free.is_nip98_required}async generateNip98Header(R,E,U){const H=new NDKEvent(this.ndk,{kind:27235,tags:[["u",R],["method",E]]});if(["POST","PUT","PATCH"].includes(E)){const W=await this.calculateSha256(U);H.tags.push(["payload",W])}return await H.sign(),`Nostr ${btoa(JSON.stringify(H.rawEvent()))}`}async calculateSha256(R){const E=await R.arrayBuffer(),U=await crypto.subtle.digest("SHA-256",E);return Array.from(new Uint8Array(U)).map(W=>W.toString(16).padStart(2,"0")).join("")}},Queue=class{constructor(R,E){le(this,"queue",[]);le(this,"maxConcurrency");le(this,"processing",new Set);le(this,"promises",new Map);this.maxConcurrency=E}add(R){if(this.promises.has(R.id))return this.promises.get(R.id);const E=new Promise((U,H)=>{this.queue.push({...R,func:()=>R.func().then(K=>(U(K),K),K=>{throw H(K),K})}),this.process()});return this.promises.set(R.id,E),E.finally(()=>{this.promises.delete(R.id),this.processing.delete(R.id),this.process()}),E}process(){if(this.processing.size>=this.maxConcurrency||this.queue.length===0)return;const R=this.queue.shift();!R||this.processing.has(R.id)||(this.processing.add(R.id),R.func())}clear(){this.queue=[]}clearProcessing(){this.processing.clear()}clearAll(){this.clear(),this.clearProcessing()}length(){return this.queue.length}},NDKSubscriptionManager=class{constructor(R){le(this,"subscriptions");le(this,"seenEvents",new Map);le(this,"debug");this.subscriptions=new Map,this.debug=R.extend("sub-manager")}add(R){this.subscriptions.set(R.internalId,R),R.on("close",()=>{this.subscriptions.delete(R.internalId)})}seenEvent(R,E){const U=this.seenEvents.get(R)||[];U.push(E),this.seenEvents.set(R,U)}},debug6=debug7("ndk:active-user");async function getUserRelayList(R){if(!this.autoConnectUserRelays)return;const E=await getRelayListForUser(R.pubkey,this);if(E){for(const U of E.relays){let H=this.pool.relays.get(U);H||(H=new NDKRelay(U,this.relayAuthDefaultPolicy,this),this.pool.addRelay(H))}return E}}async function setActiveUser(R){const E=this.outboxPool||this.pool;E.connectedRelays.length>0?setActiveUserConnected.call(this,R):E.once("connect",()=>{setActiveUserConnected.call(this,R)})}async function setActiveUserConnected(R){const E=await getUserRelayList.call(this,R),U=[{kinds:[10006],authors:[R.pubkey]}];this.autoFetchUserMutelist&&U[0].kinds.push(1e4);const H=E?E.relaySet:void 0,K=this.subscribe(U,{subId:"active-user-settings",closeOnEose:!0},H,!1),W=new Map;K.on("event",G=>{const Z=W.get(G.kind);Z&&Z.created_at>=G.created_at||W.set(G.kind,G)}),K.on("eose",()=>{for(const G of W.values())processEvent.call(this,G)}),K.start()}async function processEvent(R){R.kind===10006?processBlockRelayList.call(this,R):R.kind===1e4&&processMuteList.call(this,R)}function processBlockRelayList(R){const E=lists_default.from(R);for(const U of E.items)this.pool.blacklistRelayUrls.add(U[0]);debug6("Added %d relays to relay blacklist",E.items.length)}function processMuteList(R){const E=lists_default.from(R);for(const U of E.items)this.mutedIds.set(U[1],U[0]);debug6("Added %d users to mute list",E.items.length)}async function generateZapRequest(R,E,U,H,K,W,G,Z,Y){const X=U.callback,Q=nip57_exports.makeZapRequest({profile:H,event:null,amount:K,comment:G||"",relays:W.slice(0,4)});if(R instanceof NDKEvent){const re=R.referenceTags().filter(ae=>ae[0]!=="p");Q.tags.push(...re)}Q.tags.push(["lnurl",X]);const J=new NDKEvent(E,Q);return Z&&(J.tags=J.tags.concat(Z)),J.tags=J.tags.filter(ne=>ne[0]!=="p"),J.tags.push(["p",H]),await J.sign(Y),J}var d3=debug7("ndk:zapper"),NDKZapper=class extends libExports.EventEmitter{constructor(E,U,H="msat",K,W,G,Z){super();le(this,"target");le(this,"ndk");le(this,"comment");le(this,"amount");le(this,"unit");le(this,"tags");le(this,"signer");le(this,"zapMethod");le(this,"onLnPay");le(this,"onCashuPay");le(this,"onComplete");le(this,"maxRelays",3);if(this.target=E,this.ndk=W||E.ndk,!this.ndk)throw new Error("No NDK instance provided");this.amount=U,this.comment=K,this.unit=H,this.tags=G,this.signer=Z}async zap(){const E=this.getZapSplits(),U=new Map;return await Promise.all(E.map(async H=>{let K;try{K=await this.zapSplit(H)}catch(W){K=W}this.emit("split:complete",H,K),U.set(H,K)})),this.emit("complete",U),this.onComplete&&this.onComplete(U),U}async zapSplit(E){let U=await this.getZapMethods(this.ndk,E.pubkey),H;if(U.length===0)throw new Error("No zap method available for recipient");U=U.sort((W,G)=>W.type==="nip61"?-1:G.type==="nip61"?1:0);const K=await this.relays(E.pubkey);for(const W of U){d3("Zapping to %s with %d %s using %s",E.pubkey,E.amount,this.unit,W.type);try{switch(W.type){case"nip61":{const G=W.data;let Z;if(Z=await this.onCashuPay({target:this.target,comment:this.comment,tags:this.tags,recipientPubkey:E.pubkey,amount:E.amount,unit:this.unit,...G}),d3("NIP-61 Zap result: %o",Z),Z instanceof Error)H=Z;else if(Z){const{proofs:Y,mint:X}=Z;if(!Y||!X)throw new Error("Invalid zap confirmation: missing proofs or mint: "+Z);const Q=NDKRelaySet.fromRelayUrls(K,this.ndk),J=new NDKNutzap(this.ndk);return J.tags=[...J.tags,...this.tags||[]],J.proofs=Y,J.mint=X,J.comment=this.comment,J.unit=this.unit,J.recipientPubkey=E.pubkey,await J.sign(this.signer),await J.publish(Q),J}break}case"nip57":{const G=W.data,Z=await generateZapRequest(this.target,this.ndk,G,E.pubkey,E.amount,K,this.comment,this.tags,this.signer);if(!Z)throw d3("Unable to generate zap request"),new Error("Unable to generate zap request");const Y=await this.getLnInvoice(Z,E.amount,G);if(!Y)throw d3("Unable to get payment request"),new Error("Unable to get payment request");H=await this.onLnPay({target:this.target,comment:this.comment,recipientPubkey:E.pubkey,amount:E.amount,unit:this.unit,pr:Y});break}}}catch(G){G instanceof Error?H=G:H=new Error(G),d3("Error zapping to %s with %d %s using %s: %o",E.pubkey,E.amount,this.unit,W.type,G)}}if(H instanceof Error)throw H;return H}async getLnInvoice(E,U,H){const K=H.callback,W=JSON.stringify(E.rawEvent());d3(`Fetching invoice from ${K}?`+new URLSearchParams({amount:U.toString(),nostr:W}));const G=new URL(K);G.searchParams.append("amount",U.toString()),G.searchParams.append("nostr",W),d3(`Fetching invoice from ${G.toString()}`);const Z=await fetch(G.toString());if(d3(`Got response from zap endpoint: ${K}`,{status:Z.status}),Z.status!==200){d3(`Received non-200 status from zap endpoint: ${K}`,{status:Z.status,amount:U,nostr:W});const X=await Z.text();throw new Error(`Unable to fetch zap endpoint ${K}: ${X}`)}return(await Z.json()).pr}getZapSplits(){if(this.target instanceof NDKUser)return[{pubkey:this.target.pubkey,amount:this.amount}];const E=this.target.getMatchingTags("zap");if(E.length===0)return[{pubkey:this.target.pubkey,amount:this.amount}];const U=[],H=E.reduce((K,W)=>K+parseInt(W[2]),0);for(const K of E){const W=K[1],G=Math.floor(parseInt(K[2])/H*this.amount);U.push({pubkey:W,amount:G})}return U}async getZapMethods(E,U){const H=[];H.push("nip61"),H.push("nip57");const K=E.getUser({pubkey:U}),W=await K.getZapInfo(!1,H);return d3("Zap info for %s: %o",K.npub,W),W}async relays(E){var H,K,W;let U=[];if((H=this.ndk)!=null&&H.activeUser){const G=await getRelayListForUsers([this.ndk.activeUser.pubkey,E],this.ndk),Z=new Map;for(const Y of G.values())for(const X of Y.readRelayUrls){const Q=Z.get(X)||0;Z.set(X,Q+1)}U=Array.from(Z.entries()).sort((Y,X)=>X[1]-Y[1]).map(([Y])=>Y).slice(0,this.maxRelays)}return(W=(K=this.ndk)==null?void 0:K.pool)!=null&&W.permanentAndConnectedRelays().length&&(U=this.ndk.pool.permanentAndConnectedRelays().map(G=>G.url)),U.length||(U=[]),U}},DEFAULT_OUTBOX_RELAYS=["wss://purplepag.es/","wss://nos.lol/"],DEFAULT_BLACKLISTED_RELAYS=["wss://brb.io/","wss://nostr.mutinywallet.com/"],NDK=class extends libExports.EventEmitter{constructor(E={}){super();le(this,"_explicitRelayUrls");le(this,"pool");le(this,"outboxPool");le(this,"_signer");le(this,"_activeUser");le(this,"cacheAdapter");le(this,"debug");le(this,"devWriteRelaySet");le(this,"outboxTracker");le(this,"mutedIds");le(this,"clientName");le(this,"clientNip89");le(this,"queuesZapConfig");le(this,"queuesNip05");le(this,"asyncSigVerification",!1);le(this,"initialValidationRatio",1);le(this,"lowestValidationRatio",1);le(this,"validationRatioFn");le(this,"subManager");le(this,"publishingFailureHandled",!1);le(this,"relayAuthDefaultPolicy");le(this,"httpFetch");le(this,"netDebug");le(this,"autoConnectUserRelays",!0);le(this,"autoFetchUserMutelist",!0);le(this,"walletConfig");le(this,"fetchEventFromTag",fetchEventFromTag.bind(this));this.debug=E.debug||debug7("ndk"),this.netDebug=E.netDebug,this._explicitRelayUrls=E.explicitRelayUrls||[],this.subManager=new NDKSubscriptionManager(this.debug),this.pool=new NDKPool(E.explicitRelayUrls||[],E.blacklistRelayUrls||DEFAULT_BLACKLISTED_RELAYS,this),this.pool.name="main",this.pool.on("relay:auth",async(U,H)=>{this.relayAuthDefaultPolicy&&await this.relayAuthDefaultPolicy(U,H)}),this.autoConnectUserRelays=E.autoConnectUserRelays??!0,this.autoFetchUserMutelist=E.autoFetchUserMutelist??!0,this.clientName=E.clientName,this.clientNip89=E.clientNip89,this.relayAuthDefaultPolicy=E.relayAuthDefaultPolicy,E.enableOutboxModel&&(this.outboxPool=new NDKPool(E.outboxRelayUrls||DEFAULT_OUTBOX_RELAYS,E.blacklistRelayUrls||DEFAULT_BLACKLISTED_RELAYS,this,this.debug.extend("outbox-pool")),this.outboxPool.name="outbox",this.outboxTracker=new OutboxTracker(this)),this.signer=E.signer,this.cacheAdapter=E.cacheAdapter,this.mutedIds=E.mutedIds||new Map,E.devWriteRelayUrls&&(this.devWriteRelaySet=NDKRelaySet.fromRelayUrls(E.devWriteRelayUrls,this)),this.queuesZapConfig=new Queue("zaps",3),this.queuesNip05=new Queue("nip05",10),this.signatureVerificationWorker=E.signatureVerificationWorker,this.initialValidationRatio=E.initialValidationRatio||1,this.lowestValidationRatio=E.lowestValidationRatio||1;try{this.httpFetch=fetch}catch{}}set explicitRelayUrls(E){this._explicitRelayUrls=E,this.pool.relayUrls=E}get explicitRelayUrls(){return this._explicitRelayUrls||[]}set signatureVerificationWorker(E){this.asyncSigVerification=!!E,E&&signatureVerificationInit(E)}addExplicitRelay(E,U,H=!0){let K;return typeof E=="string"?K=new NDKRelay(E,U,this):K=E,this.pool.addRelay(K,H),this.explicitRelayUrls.push(K.url),K}toJSON(){return{relayCount:this.pool.relays.size}.toString()}get activeUser(){return this._activeUser}set activeUser(E){var H;const U=((H=this._activeUser)==null?void 0:H.pubkey)!==(E==null?void 0:E.pubkey);this._activeUser=E,E&&U?setActiveUser.call(this,E):E||(this.mutedIds=new Map)}get signer(){return this._signer}set signer(E){this._signer=E,E&&this.emit("signer:ready",E),E==null||E.user().then(U=>{U.ndk=this,this.activeUser=U})}async connect(E){var H,K;this._signer&&this.autoConnectUserRelays&&(this.debug("Attempting to connect to user relays specified by signer %o",await((K=(H=this._signer).relays)==null?void 0:K.call(H,this))),this._signer.relays&&(await this._signer.relays(this)).forEach(G=>this.pool.addRelay(G)));const U=[this.pool.connect(E)];return this.outboxPool&&U.push(this.outboxPool.connect(E)),this.debug("Connecting to relays %o",{timeoutMs:E}),Promise.allSettled(U).then(()=>{})}getUser(E){const U=new NDKUser(E);return U.ndk=this,U}async getUserFromNip05(E,U=!1){return NDKUser.fromNip05(E,this,U)}subscribe(E,U,H,K=!0){var G;const W=new NDKSubscription(this,E,U,H);if(this.subManager.add(W),H)for(const Z of H.relays)this.pool.useTemporaryRelay(Z,void 0,W.filters);if(this.outboxPool&&W.hasAuthorsFilter()){const Z=W.filters.filter(Y=>{var X;return Y.authors&&((X=Y.authors)==null?void 0:X.length)>0}).map(Y=>Y.authors).flat();(G=this.outboxTracker)==null||G.trackUsers(Z)}return K&&setTimeout(()=>W.start(),0),W}async publish(E,U,H){return this.debug("Deprecated: Use `event.publish()` instead"),E.publish(U,H)}async fetchEvent(E,U,H){let K,W;if(H instanceof NDKRelay?W=new NDKRelaySet(new Set([H]),this):H instanceof NDKRelaySet&&(W=H),!H&&typeof E=="string"&&!isNip33AValue(E)){const G=relaysFromBech32(E,this);G.length>0&&(W=new NDKRelaySet(new Set(G),this),W=correctRelaySet(W,this.pool))}if(typeof E=="string"?K=[filterFromId(E)]:Array.isArray(E)?K=E:K=[E],K.length===0)throw new Error(`Invalid filter: ${JSON.stringify(E)}`);return new Promise(G=>{let Z=null;const Y=this.subscribe(K,{...U||{},closeOnEose:!0},W,!1),X=setTimeout(()=>{Y.stop(),G(Z)},1e4);Y.on("event",Q=>{Q.ndk=this,Q.isReplaceable()?(!Z||Z.created_at<Q.created_at)&&(Z=Q):(clearTimeout(X),G(Q))}),Y.on("eose",()=>{clearTimeout(X),G(Z)}),Y.start()})}async fetchEvents(E,U,H){return new Promise(K=>{const W=new Map,G=this.subscribe(E,{...U||{},closeOnEose:!0},H,!1),Z=Y=>{Y instanceof NDKEvent||(Y=new NDKEvent(void 0,Y));const X=Y.deduplicationKey(),Q=W.get(X);Q&&(Y=dedup(Q,Y)),Y.ndk=this,W.set(X,Y)};G.on("event",Z),G.on("eose",()=>{K(new Set(W.values()))}),G.start()})}assertSigner(){if(!this.signer)throw this.emit("signer:required"),new Error("Signer required")}getNip96(E){return new Nip96(E,this)}async nwc(E,U=2e3){const H=await NDKNwc.fromURI(this,E);return U!==!1&&await H.blockUntilReady(U),H}zap(E,U,{comment:H,unit:K,signer:W,tags:G,onLnPay:Z,onCashuPay:Y,onComplete:X}){var J,ne,re;W||this.assertSigner();const Q=new NDKZapper(E,U,K,H,this,G,W);return Z!==!1&&(Q.onLnPay=Z??((J=this.walletConfig)==null?void 0:J.onLnPay)),Y!==!1&&(Q.onCashuPay=Y??((ne=this.walletConfig)==null?void 0:ne.onCashuPay)),Q.onComplete=X??((re=this.walletConfig)==null?void 0:re.onPaymentComplete),Z&&Q.zap(),Q}},GroupEventKind=(R=>(R[R.JoinRequest=9021]="JoinRequest",R[R.LeaveRequest=9022]="LeaveRequest",R[R.PutUser=9e3]="PutUser",R[R.RemoveUser=9001]="RemoveUser",R[R.EditMetadata=9002]="EditMetadata",R[R.DeleteEvent=9005]="DeleteEvent",R[R.CreateGroup=9007]="CreateGroup",R[R.DeleteGroup=9008]="DeleteGroup",R[R.CreateInvite=9009]="CreateInvite",R))(GroupEventKind||{});class NostrGroupError extends Error{constructor(E){super(E),this.name="NostrGroupError"}}class NostrClient{constructor(E,U){le(this,"ndk");le(this,"config");try{this.config={relayUrl:"ws://127.0.0.1:8080",...U};const H=new NDKPrivateKeySigner(E);this.ndk=new NDK({explicitRelayUrls:[this.config.relayUrl],signer:H}),this.ndk.pool.on("relay:connect",K=>{K.authPolicy=NDKRelayAuthPolicies.signIn({ndk:this.ndk})}),console.log("NostrClient initialized",this.ndk),console.log("pool",this.ndk.pool),console.log("config",this.config)}catch(H){throw new NostrGroupError(`Failed to initialize NostrClient: ${H}`)}}get ndkInstance(){return this.ndk}async connect(){try{await this.ndk.connect();const E=Array.from(this.ndk.pool.relays.values()),U=await Promise.race(E.map(H=>new Promise((K,W)=>{if(H.status===5){K(H);return}const G=()=>{H.status===5&&(X(),K(H))},Z=Q=>{X(),W(Q)};H.on("authed",()=>{X(),K(H)}),H.on("disconnect",()=>Z(new Error("Relay disconnected"))),H.on("auth:failed",Q=>Z(new Error(`Auth failed: ${Q.message}`)));const Y=setInterval(G,100),X=()=>{clearInterval(Y),H.removeAllListeners("authed"),H.removeAllListeners("disconnect"),H.removeAllListeners("auth:failed")};setTimeout(()=>{X(),W(new Error("Connection timeout waiting for authentication"))},5e3)})));console.log("Connected to relays:",E.map(H=>({url:H.url,status:H.status===U.status?"ready":H.status,connected:H.connected})))}catch(E){throw new NostrGroupError(`Failed to connect: ${E}`)}}async publishEvent(E,U,H=""){try{if(Array.from(this.ndk.pool.relays.values()).filter(Z=>Z.status===5).length===0)throw new NostrGroupError("No ready relays available. Please ensure you are authenticated.");const W=new NDKEvent(this.ndk);W.kind=E,W.tags=U,W.content=H,await W.sign(),console.log("ndkEvent",JSON.stringify(W.rawEvent()));const G=await W.publish();return console.log("Event published successfully:",!!G),W}catch(K){if(K instanceof NDKPublishError)for(const[W,G]of K.errors)throw new NostrGroupError(`${W.url}: ${G.message}`);throw new NostrGroupError(`Failed to publish event: ${K}`)}}async sendJoinRequest(E,U){const H=[["h",E]];return U&&H.push(["code",U]),this.publishEvent(9021,H)}async acceptJoinRequest(E,U){return this.publishEvent(9e3,[["h",E],["p",U,"member"]])}async createGroup(E,U,H="",K=""){await this.publishEvent(9007,[["h",E]]);const W=[["h",E]];return U&&W.push(["name",U]),H&&W.push(["about",H]),K&&W.push(["picture",K]),W.push(["public"]),W.push(["open"]),this.publishEvent(9002,W)}async updateGroupName(E,U){return this.publishEvent(9002,[["h",E],["name",U]])}async updateGroupMetadata(E){const U=[["h",E.id]];return E.name&&U.push(["name",E.name]),E.picture&&U.push(["picture",E.picture]),E.about&&U.push(["about",E.about]),U.push([E.private?"private":"public"]),U.push([E.closed?"closed":"open"]),this.publishEvent(9002,U)}async leaveGroup(E){return this.publishEvent(9022,[["h",E]])}async addModerator(E,U){return this.publishEvent(9e3,[["h",E],["p",U,"moderator"]])}async removeModerator(E,U){return this.publishEvent(9001,[["h",E],["p",U]])}async removeMember(E,U){return this.publishEvent(9001,[["h",E],["p",U]])}async addMember(E,U){return this.publishEvent(9e3,[["h",E],["p",U,"member"]])}async createInvite(E,U){return this.publishEvent(9009,[["h",E],["code",U],["roles","member"]])}}class InviteSection extends x{constructor(U){super(U);le(this,"handleCreateInvite",async U=>{if(U.preventDefault(),!!this.state.inviteCode.trim()){this.setState({error:"",isCreatingInvite:!0});try{await this.props.client.createInvite(this.props.group.id,this.state.inviteCode),this.setState({inviteCode:""})}catch(H){console.error("Failed to create invite:",H),this.setState({error:"Failed to create invite. Please try again."})}finally{this.setState({isCreatingInvite:!1})}}});this.state={isCreatingInvite:!1,inviteCode:"",error:""}}render(){const{group:U}=this.props,{isCreatingInvite:H,inviteCode:K,error:W}=this.state,G=Z=>Z.slice(0,8)+"...";return u$1("section",{class:"border-t border-[var(--color-border)] p-3",children:[u$1("h3",{class:"flex items-center gap-1 text-sm font-semibold text-[var(--color-text-primary)] mb-2",children:[u$1("span",{class:"text-base",children:""})," Invites"]}),u$1("form",{onSubmit:this.handleCreateInvite,class:"mb-3",children:[u$1("div",{class:"flex gap-2",children:[u$1("input",{type:"text",value:K,onInput:Z=>this.setState({inviteCode:Z.target.value}),placeholder:"Enter invite code",class:`flex-1 rounded border border-[var(--color-border)] px-2 py-1 text-xs
                     bg-[var(--color-bg-tertiary)] text-[var(--color-text-primary)]
                     focus:border-[var(--color-accent)] focus:outline-none focus:ring-1
                     focus:ring-[var(--color-accent)]/10 transition-all`,required:!0,disabled:H}),u$1("button",{type:"submit",disabled:H||!K.trim(),class:`px-2 py-1 bg-[var(--color-accent)] text-white rounded text-xs font-medium
                     hover:bg-[var(--color-accent-hover)] active:transform active:translate-y-0.5
                     transition-all flex items-center gap-1 disabled:opacity-50 whitespace-nowrap`,children:H?u$1(k,{children:[u$1("span",{class:"animate-spin",children:""}),"Creating..."]}):"Create Invite"})]}),W&&u$1("div",{class:"mt-1 text-xs text-red-400",children:W})]}),U.invites&&Object.entries(U.invites).length>0?u$1("ul",{class:"space-y-2",children:Object.entries(U.invites).map(([Z,Y])=>u$1("li",{class:"py-1",children:u$1("div",{class:"space-y-2",children:[u$1("div",{class:"flex items-center justify-between gap-2",children:u$1("div",{class:"text-xs text-[var(--color-text-secondary)] font-mono",children:["Code: ",Z]})}),Y.pubkey&&u$1("div",{class:"flex items-center justify-between gap-2",children:u$1("div",{class:"text-xs text-[var(--color-text-secondary)] font-mono hover:text-[var(--color-text-primary)] transition-colors","data-tooltip":Y.pubkey,children:["Used by: ",G(Y.pubkey)]})})]})},Z))}):u$1("p",{class:"text-xs text-[var(--color-text-secondary)]",children:"No invites created yet."})]})}}class JoinRequestForm extends x{constructor(U){super(U);le(this,"handleSubmit",async U=>{if(U.preventDefault(),!this.state.sec.trim())return;let H=this.state.sec;if(this.state.sec.startsWith("nsec"))try{const{data:K}=nip19_exports.decode(this.state.sec);H=K}catch{this.setState({error:"Invalid nsec format. Please check your private key."});return}this.setState({error:"",isSubmitting:!0});try{const K=new NostrClient(H,{relayUrl:this.props.relayUrl});try{await K.connect()}catch(W){const G=W;throw new Error(`Failed to connect to relay: ${(G==null?void 0:G.message)||"Unknown error"}`)}console.log("connected");try{await K.sendJoinRequest(this.props.groupId,this.state.inviteCode||void 0),this.setState({sec:"",inviteCode:""})}catch(W){const G=W;throw(G==null?void 0:G.name)==="NostrGroupError"?new Error(G.message||"Unknown group error"):new Error(`Failed to send join request: ${(G==null?void 0:G.message)||"Unknown error"}`)}}catch(K){const W=K;console.error("Join request error:",W),this.setState({error:(W==null?void 0:W.message)||"Failed to send join request. Please check your nsec and try again."})}finally{this.setState({isSubmitting:!1})}});this.state={sec:"",inviteCode:"",isSubmitting:!1,error:""}}render(){const{sec:U,inviteCode:H,isSubmitting:K,error:W}=this.state;return u$1("form",{onSubmit:this.handleSubmit,class:"space-y-2",children:[u$1("div",{children:[u$1("label",{htmlFor:"nsec",class:"block text-xs font-medium text-[var(--color-text-secondary)] mb-0.5",children:"Your nsec"}),u$1("input",{type:"password",id:"nsec",value:U,onInput:G=>this.setState({sec:G.target.value}),placeholder:"nsec1...",class:`block w-full rounded border border-[var(--color-border)] px-2 py-1 text-xs
                   bg-[var(--color-bg-tertiary)] text-[var(--color-text-primary)]
                   focus:border-[var(--color-accent)] focus:outline-none focus:ring-1
                   focus:ring-[var(--color-accent)]/10 transition-all`,required:!0,disabled:K})]}),u$1("div",{children:[u$1("label",{htmlFor:"inviteCode",class:"block text-xs font-medium text-[var(--color-text-secondary)] mb-0.5",children:"Invite Code (optional)"}),u$1("input",{type:"text",id:"inviteCode",value:H,onInput:G=>this.setState({inviteCode:G.target.value}),placeholder:"Enter invite code",class:`block w-full rounded border border-[var(--color-border)] px-2 py-1 text-xs
                   bg-[var(--color-bg-tertiary)] text-[var(--color-text-primary)]
                   focus:border-[var(--color-accent)] focus:outline-none focus:ring-1
                   focus:ring-[var(--color-accent)]/10 transition-all`,disabled:K})]}),u$1("button",{type:"submit",disabled:K||!U.trim(),class:`w-full px-2 py-1 bg-[var(--color-accent)] text-white rounded text-xs font-medium
                 hover:bg-[var(--color-accent-hover)] active:transform active:translate-y-0.5
                 transition-all flex items-center justify-center gap-1 disabled:opacity-50`,children:K?u$1(k,{children:[u$1("span",{class:"animate-spin",children:""}),"Joining..."]}):"Join Group"}),W&&u$1("div",{class:"text-xs text-red-400",children:W})]})}}class JoinRequestSection extends x{constructor(U){super(U);le(this,"handleAcceptRequest",async U=>{try{await this.props.client.acceptJoinRequest(this.props.group.id,U)}catch(H){console.error("Failed to accept join request:",H)}});this.state={showJoinForm:!1}}render(){var Z;const{group:U,client:H}=this.props,{showJoinForm:K}=this.state,W=((Z=U.join_requests)==null?void 0:Z.filter(Y=>!U.members.some(X=>X.pubkey===Y)))||[],G=Y=>Y.slice(0,8)+"...";return u$1("section",{class:"border-t border-[var(--color-border)] p-3",children:[u$1("div",{class:"flex items-center justify-between mb-2",children:u$1("button",{onClick:()=>this.setState({showJoinForm:!K}),class:"text-[var(--color-accent)] hover:text-[var(--color-accent-hover)] text-xs",children:K?"Cancel Join":"Join Group"})}),K&&u$1("div",{class:"mb-3 border border-[var(--color-border)] rounded p-2 bg-[var(--color-bg-tertiary)]",children:u$1(JoinRequestForm,{groupId:U.id,relayUrl:H.config.relayUrl})}),W.length>0?u$1("ul",{class:"space-y-2",children:W.map(Y=>u$1("li",{class:"py-1",children:u$1("div",{class:"flex items-center justify-between gap-2",children:[u$1("div",{class:"text-xs text-[var(--color-text-secondary)] font-mono hover:text-[var(--color-text-primary)] transition-colors","data-tooltip":Y,children:G(Y)}),u$1("button",{onClick:()=>this.handleAcceptRequest(Y),class:`px-2 py-1 bg-[var(--color-accent)] text-white text-xs rounded
                           hover:bg-[var(--color-accent-hover)] active:transform active:translate-y-0.5
                           transition-all flex-shrink-0`,children:"Accept"})]})},Y))}):u$1("p",{class:"text-xs text-[var(--color-text-secondary)]",children:"No pending join requests."})]})}}function ContentSection({group:R}){var E;return(E=R.content)!=null&&E.length?u$1("section",{class:"border-t border-gray-200 p-3",children:[u$1("h3",{class:"flex items-center gap-1 text-sm font-semibold text-gray-900 mb-2",children:[u$1("span",{class:"text-base",children:""})," Recent Activity"]}),u$1("ul",{class:"space-y-2",children:R.content.map((U,H)=>u$1("li",{class:"py-1",children:u$1("div",{class:"space-y-1",children:[u$1("div",{class:"flex items-center gap-2",children:[u$1("div",{class:"text-xs text-gray-500",children:U.pubkey}),u$1("span",{class:"text-xs text-gray-400",children:new Date(U.created_at*1e3).toLocaleString()})]}),u$1("div",{class:"text-xs text-gray-900",children:U.content})]})},H))})]}):null}class GroupCard extends x{constructor(U){super(U);le(this,"handleNameEdit",()=>{this.setState({isEditingName:!0})});le(this,"handleNameSave",async()=>{if(!this.state.newName.trim()||this.state.newName===this.props.group.name){this.setState({isEditingName:!1});return}try{await this.props.client.updateGroupName(this.props.group.id,this.state.newName),this.props.group.name=this.state.newName,this.setState({isEditingName:!1}),this.props.showMessage("Group name updated successfully!","success")}catch(U){console.error("Failed to update group name:",U),this.props.showMessage("Failed to update group name: "+U,"error")}});le(this,"handleAboutEdit",()=>{this.setState({isEditingAbout:!0})});le(this,"handleAboutSave",async()=>{if(this.state.newAbout===this.props.group.about){this.setState({isEditingAbout:!1});return}try{const U={...this.props.group,about:this.state.newAbout};await this.props.client.updateGroupMetadata(U),this.props.group.about=this.state.newAbout,this.setState({isEditingAbout:!1}),this.props.showMessage("Group description updated successfully!","success")}catch(U){console.error("Failed to update about:",U),this.props.showMessage("Failed to update group description: "+U,"error")}});le(this,"handleMetadataChange",async(U,H)=>{try{const K={...this.props.group,[U]:H};await this.props.client.updateGroupMetadata(K),this.props.group[U]=H,this.props.showMessage(`Group ${U} setting updated successfully!`,"success")}catch(K){console.error("Error updating metadata:",K),this.props.showMessage(`Failed to update group ${U} setting: `+K,"error")}});le(this,"handleRemoveMember",async U=>{try{await this.props.client.removeMember(this.props.group.id,U),this.props.showMessage("Member removed successfully!","success")}catch(H){console.error("Failed to remove member:",H),this.props.showMessage("Failed to remove member: "+H,"error")}});le(this,"handleAddMember",async U=>{if(U.preventDefault(),!!this.state.newMemberPubkey.trim()){this.setState({isAddingMember:!0});try{await this.props.client.addMember(this.props.group.id,this.state.newMemberPubkey),this.setState({newMemberPubkey:""}),this.props.showMessage("Member added successfully!","success")}catch(H){console.error("Failed to add member:",H),this.props.showMessage("Failed to add member: "+H,"error")}finally{this.setState({isAddingMember:!1})}}});this.state={isEditingName:!1,newName:U.group.name||"",isEditingAbout:!1,newAbout:U.group.about||"",newMemberPubkey:"",isAddingMember:!1}}render(){const{group:U,client:H}=this.props,{isEditingName:K,newName:W,isEditingAbout:G,newAbout:Z,newMemberPubkey:Y,isAddingMember:X}=this.state,Q=J=>J.slice(0,8)+"...";return u$1("article",{class:"bg-[var(--color-bg-secondary)] rounded-lg shadow-lg border border-[var(--color-border)] overflow-hidden",children:u$1("div",{class:"flex flex-col lg:flex-row lg:divide-x divide-[var(--color-border)]",children:[u$1("div",{class:"lg:w-1/3 flex flex-col",children:[u$1("header",{class:"p-3 border-b border-[var(--color-border)] bg-gradient-to-r from-[var(--color-bg-tertiary)] to-[var(--color-bg-secondary)]",children:u$1("div",{class:"flex items-center gap-3",children:[U.picture&&u$1("img",{src:U.picture,alt:U.name,class:"w-8 h-8 rounded object-cover flex-shrink-0",onError:J=>{J.target.style.display="none"}}),u$1("div",{class:"flex-grow min-w-0",children:K?u$1("div",{class:"flex items-center gap-2",children:[u$1("input",{type:"text",value:W,onInput:J=>this.setState({newName:J.target.value}),class:`flex-1 rounded border border-[var(--color-border)] px-2 py-1 text-xs
                               bg-[var(--color-bg-tertiary)] text-[var(--color-text-primary)]
                               focus:border-[var(--color-accent)] focus:outline-none focus:ring-1
                               focus:ring-[var(--color-accent)]/10 transition-all`,autoFocus:!0}),u$1("button",{onClick:this.handleNameSave,class:`px-2 py-1 bg-[var(--color-accent)] text-white rounded text-xs font-medium
                               hover:bg-[var(--color-accent-hover)] active:transform active:translate-y-0.5
                               transition-all disabled:opacity-50`,children:"Save"})]}):u$1("h2",{class:`text-base font-semibold text-[var(--color-text-primary)] cursor-pointer px-2 py-1
                             rounded group hover:bg-[var(--color-bg-tertiary)] transition-colors flex items-center gap-1
                             truncate`,onClick:this.handleNameEdit,children:[u$1("span",{class:"truncate",children:U.name}),u$1("span",{class:"text-xs text-[var(--color-text-secondary)] opacity-0 group-hover:opacity-100 transition-opacity flex-shrink-0",children:" edit"})]})})]})}),u$1("div",{class:"p-3 flex-grow",children:u$1("div",{class:"space-y-3",children:[u$1("div",{children:[u$1("span",{class:"text-xs font-medium text-[var(--color-text-secondary)] uppercase tracking-wide",children:"ID:"}),u$1("div",{class:"mt-0.5 text-xs text-[var(--color-text-primary)] break-all",children:U.id})]}),u$1("div",{children:[u$1("span",{class:"text-xs font-medium text-[var(--color-text-secondary)] uppercase tracking-wide",children:"About:"}),G?u$1("div",{class:"mt-0.5 flex items-start gap-2",children:[u$1("textarea",{value:Z,onInput:J=>this.setState({newAbout:J.target.value}),class:`flex-1 rounded border border-[var(--color-border)] px-2 py-1 text-xs
                               bg-[var(--color-bg-tertiary)] text-[var(--color-text-primary)]
                               focus:border-[var(--color-accent)] focus:outline-none focus:ring-1
                               focus:ring-[var(--color-accent)]/10 transition-all resize-none`,rows:2,autoFocus:!0}),u$1("button",{onClick:this.handleAboutSave,class:`px-2 py-1 bg-[var(--color-accent)] text-white rounded text-xs font-medium
                               hover:bg-[var(--color-accent-hover)] active:transform active:translate-y-0.5
                               transition-all disabled:opacity-50`,children:"Save"})]}):u$1("div",{class:`mt-0.5 text-xs text-[var(--color-text-primary)] cursor-pointer group
                             hover:bg-[var(--color-bg-tertiary)] transition-colors rounded px-2 py-1 -mx-2
                             flex items-center gap-1`,onClick:this.handleAboutEdit,children:[U.about||"No description",u$1("span",{class:"text-xs text-[var(--color-text-secondary)] opacity-0 group-hover:opacity-100 transition-opacity",children:" edit"})]})]}),u$1("div",{children:[u$1("span",{class:"text-xs font-medium text-[var(--color-text-secondary)] uppercase tracking-wide",children:"Type:"}),u$1("div",{class:"mt-1 flex gap-3",children:[u$1("label",{class:"flex items-center gap-1.5 cursor-pointer",children:[u$1("input",{type:"checkbox",checked:U.private,onChange:()=>this.handleMetadataChange("private",!U.private),class:`w-3 h-3 rounded border-[var(--color-border)] text-[var(--color-accent)]
                               focus:ring-[var(--color-accent)] cursor-pointer bg-[var(--color-bg-tertiary)]`}),u$1("span",{class:"text-xs text-[var(--color-text-primary)]",children:"Private"})]}),u$1("label",{class:"flex items-center gap-1.5 cursor-pointer",children:[u$1("input",{type:"checkbox",checked:U.closed,onChange:()=>this.handleMetadataChange("closed",!U.closed),class:`w-3 h-3 rounded border-[var(--color-border)] text-[var(--color-accent)]
                               focus:ring-[var(--color-accent)] cursor-pointer bg-[var(--color-bg-tertiary)]`}),u$1("span",{class:"text-xs text-[var(--color-text-primary)]",children:"Closed"})]})]})]}),u$1("div",{class:"space-y-1",children:u$1("div",{children:[u$1("span",{class:"text-xs font-medium text-[var(--color-text-secondary)] uppercase tracking-wide",children:"Created:"}),u$1("div",{class:"text-xs text-[var(--color-text-secondary)]",children:new Date(U.created_at*1e3).toLocaleString()})]})})]})})]}),u$1("div",{class:"lg:w-1/3",children:u$1("div",{class:"p-3",children:[u$1("h3",{class:"flex items-center gap-1 text-sm font-semibold text-[var(--color-text-primary)] mb-2",children:[u$1("span",{class:"text-base",children:""})," Members"]}),u$1("form",{onSubmit:this.handleAddMember,class:"mb-3",children:u$1("div",{class:"flex gap-2",children:[u$1("input",{type:"text",value:Y,onInput:J=>this.setState({newMemberPubkey:J.target.value}),placeholder:"Enter member pubkey",class:`flex-1 rounded border border-[var(--color-border)] px-2 py-1 text-xs
                           bg-[var(--color-bg-tertiary)] text-[var(--color-text-primary)]
                           focus:border-[var(--color-accent)] focus:outline-none focus:ring-1
                           focus:ring-[var(--color-accent)]/10 transition-all font-mono`,required:!0,disabled:X}),u$1("button",{type:"submit",disabled:X||!Y.trim(),class:`px-2 py-1 bg-[var(--color-accent)] text-white rounded text-xs font-medium
                           hover:bg-[var(--color-accent-hover)] active:transform active:translate-y-0.5
                           transition-all flex items-center gap-1 disabled:opacity-50 whitespace-nowrap`,children:X?u$1(k,{children:[u$1("span",{class:"animate-spin",children:""}),"Adding..."]}):"Add Member"})]})}),u$1("ul",{class:"space-y-2 max-h-[300px] overflow-y-auto",children:U.members.map(J=>u$1("li",{class:"py-1",children:u$1("div",{class:"flex items-center justify-between gap-2",children:[u$1("div",{class:"text-xs text-[var(--color-text-secondary)] font-mono hover:text-[var(--color-text-primary)] transition-colors","data-tooltip":J.pubkey,children:Q(J.pubkey)}),u$1("div",{class:"flex items-center gap-2",children:[u$1("div",{class:"flex flex-wrap gap-1 flex-shrink-0",children:J.roles.map(ne=>{const re=ne.toLowerCase(),[ae]=re.includes("admin")?[""]:re.includes("moderator")?[""]:[""];return u$1("span",{class:`role-badge ${re.includes("admin")?"admin":re.includes("moderator")?"moderator":"member"} text-xs`,children:[ae," ",ne]})})}),u$1("button",{onClick:()=>this.handleRemoveMember(J.pubkey),class:"text-red-400 hover:text-red-300 transition-colors flex-shrink-0 p-1",title:"Remove member",children:""})]})]})},J.pubkey))})]})}),u$1("div",{class:"lg:w-1/3 flex flex-col",children:[u$1(InviteSection,{group:U,client:H}),u$1(JoinRequestSection,{group:U,client:H}),u$1(ContentSection,{group:U})]})]})})}}class GroupList extends x{render(){const{groups:E,client:U,showMessage:H}=this.props;return u$1("div",{class:"space-y-4",children:E.map(K=>u$1(GroupCard,{group:K,client:U,showMessage:H},K.id))})}}function generateGroupId(){const R="abcdefghijklmnopqrstuvwxyz0123456789";return Array.from({length:12},()=>R[Math.floor(Math.random()*R.length)]).join("")}class CreateGroupForm extends x{constructor(U){super(U);le(this,"handleSubmit",async U=>{U.preventDefault(),this.setState({isSubmitting:!0});try{await this.props.client.createGroup(this.state.groupId,this.state.name,this.state.about,this.state.picture),this.props.showMessage("Group created successfully!","success"),this.setState({groupId:generateGroupId(),name:"",about:"",picture:""})}catch(H){console.error("Failed to create group:",H),this.props.showMessage("Failed to create group: "+H,"error")}finally{this.setState({isSubmitting:!1})}});this.state={groupId:generateGroupId(),name:"",about:"",picture:"",isSubmitting:!1}}render(){const{groupId:U,name:H,about:K,picture:W,isSubmitting:G}=this.state;return u$1("form",{onSubmit:this.handleSubmit,class:"bg-[var(--color-bg-secondary)] rounded-lg shadow-lg border border-[var(--color-border)] p-2 w-full",children:[u$1("h2",{class:"text-sm font-semibold text-[var(--color-text-primary)] mb-2",children:"Create New Group"}),u$1("div",{class:"space-y-1.5",children:[u$1("div",{children:[u$1("label",{htmlFor:"groupId",class:"block text-xs font-medium text-[var(--color-text-secondary)] mb-0.5",children:"Group ID"}),u$1("input",{type:"text",id:"groupId",value:U,class:`block w-full rounded border border-[var(--color-border)] px-2 py-1 text-xs
                     bg-[var(--color-bg-tertiary)] text-[var(--color-text-primary)]
                     focus:border-[var(--color-accent)] focus:outline-none focus:ring-1
                     focus:ring-[var(--color-accent)]/10 transition-all font-mono`,disabled:!0})]}),u$1("div",{children:[u$1("label",{htmlFor:"name",class:"block text-xs font-medium text-[var(--color-text-secondary)] mb-0.5",children:"Name *"}),u$1("input",{type:"text",id:"name",value:H,onInput:Z=>this.setState({name:Z.target.value}),class:`block w-full rounded border border-[var(--color-border)] px-2 py-1 text-xs
                     bg-[var(--color-bg-tertiary)] text-[var(--color-text-primary)]
                     focus:border-[var(--color-accent)] focus:outline-none focus:ring-1
                     focus:ring-[var(--color-accent)]/10 transition-all`,required:!0})]}),u$1("div",{children:[u$1("label",{htmlFor:"about",class:"block text-xs font-medium text-[var(--color-text-secondary)] mb-0.5",children:"About"}),u$1("textarea",{id:"about",value:K,onInput:Z=>this.setState({about:Z.target.value}),rows:2,class:`block w-full rounded border border-[var(--color-border)] px-2 py-1 text-xs
                     bg-[var(--color-bg-tertiary)] text-[var(--color-text-primary)]
                     focus:border-[var(--color-accent)] focus:outline-none focus:ring-1
                     focus:ring-[var(--color-accent)]/10 transition-all`})]}),u$1("div",{children:[u$1("label",{htmlFor:"picture",class:"block text-xs font-medium text-[var(--color-text-secondary)] mb-0.5",children:"Picture URL"}),u$1("input",{type:"url",id:"picture",value:W,onInput:Z=>this.setState({picture:Z.target.value}),class:`block w-full rounded border border-[var(--color-border)] px-2 py-1 text-xs
                     bg-[var(--color-bg-tertiary)] text-[var(--color-text-primary)]
                     focus:border-[var(--color-accent)] focus:outline-none focus:ring-1
                     focus:ring-[var(--color-accent)]/10 transition-all`})]}),u$1("button",{type:"submit",disabled:G||!H.trim(),class:`w-full mt-1.5 flex justify-center py-1 px-2 border border-transparent rounded text-xs
                   font-medium text-white bg-[var(--color-accent)] hover:bg-[var(--color-accent-hover)]
                   focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-[var(--color-accent)]
                   disabled:opacity-50 transition-all`,children:G?"Creating...":"Create Group"})]})]})}}class FlashMessage extends x{componentDidUpdate(E){this.props.message&&!E.message&&setTimeout(()=>{this.props.onDismiss()},5e3)}render(){const{message:E,type:U="info"}=this.props;if(!E)return null;const H={success:"bg-green-500",error:"bg-red-500",info:"bg-blue-500"}[U];return u$1("div",{class:`fixed top-0 left-0 right-0 z-50 flex items-center justify-center transition-transform duration-300 ${E?"translate-y-0":"-translate-y-full"}`,children:u$1("div",{class:`${H} text-white px-6 py-3 rounded-b-lg shadow-lg flex items-center gap-2 max-w-2xl mx-auto`,children:[u$1("span",{class:"text-sm font-medium",children:E}),u$1("button",{onClick:this.props.onDismiss,class:"ml-2 text-white hover:text-gray-200 transition-colors","aria-label":"Dismiss message",children:""})]})})}}const metadataKinds=[39e3,39001,39002,39003];class App extends x{constructor(U){super(U);le(this,"groupsMap");le(this,"showMessage",(U,H="info")=>{this.setState({flashMessage:{message:U,type:H}})});le(this,"dismissMessage",()=>{this.setState({flashMessage:null})});le(this,"updateGroupsMap",U=>{U(this.groupsMap);const H=Array.from(this.groupsMap.values()).sort((K,W)=>W.created_at-K.created_at);this.setState({groups:H})});le(this,"processEvent",(U,H)=>{var K,W,G,Z,Y,X,Q,J;if(console.log("processing event",U.kind,U),U.kind===GroupEventKind.CreateGroup){const ne=(K=U.tags.find(re=>re[0]==="h"))==null?void 0:K[1];if(!ne)return;if(!H.has(ne)){const re={id:ne,name:"",about:"",picture:"",private:!1,closed:!1,created_at:U.created_at,members:[],invites:{},join_requests:[],content:[]};H.set(ne,re)}}if(U.kind>=39e3&&U.kind<=39003){const ne=(W=U.tags.find(ae=>ae[0]==="d"))==null?void 0:W[1];if(!ne)return;let re=H.get(ne)||{id:ne,name:"",about:"",picture:"",private:!1,closed:!1,created_at:U.created_at,members:[],invites:{},join_requests:[],content:[]};switch(U.kind){case 39e3:for(const[te,se]of U.tags)switch(te){case"name":re.name=se;break;case"about":re.about=se;break;case"picture":re.picture=se;break;case"private":re.private=!0;break;case"public":re.private=!1;break;case"closed":re.closed=!0;break;case"open":re.closed=!1;break}break;case 39001:re.members=re.members.filter(te=>!te.roles.includes("admin")),U.tags.filter(te=>te[0]==="p").forEach(te=>{const[se,ie,...ye]=te,me=re.members.findIndex(_e=>_e.pubkey===ie);me>=0?re.members[me].roles=ye:re.members.push({pubkey:ie,roles:ye})});break;case 39002:const ae=re.members.filter(te=>te.roles.some(se=>se!=="member"));re.members=ae,U.tags.filter(te=>te[0]==="p").forEach(te=>{const se=te[1];re.members.some(ie=>ie.pubkey===se)||re.members.push({pubkey:se,roles:["member"]})});break}H.set(ne,re)}if(U.kind===9||U.kind===11){const ne=(G=U.tags.find(te=>te[0]==="h"))==null?void 0:G[1];if(!ne)return;const re=H.get(ne);if(!re)return;const ae={pubkey:U.pubkey,kind:U.kind,content:U.content,created_at:U.created_at};re.content=[ae,...re.content||[]].slice(0,50),H.set(ne,{...re})}if(U.kind===GroupEventKind.CreateInvite){const ne=(Z=U.tags.find(se=>se[0]==="h"))==null?void 0:Z[1];if(!ne)return;const re=H.get(ne);if(!re)return;const ae=(Y=U.tags.find(se=>se[0]==="code"))==null?void 0:Y[1],te=((Q=(X=U.tags.find(se=>se[0]==="roles"))==null?void 0:X[1])==null?void 0:Q.split(","))||["member"];ae&&(re.invites={...re.invites,[ae]:{roles:te}},H.set(ne,{...re}))}if(U.kind===GroupEventKind.JoinRequest){console.log("join request",U);const ne=(J=U.tags.find(ae=>ae[0]==="h"))==null?void 0:J[1];if(!ne)return;const re=H.get(ne);if(!re)return;re.join_requests.includes(U.pubkey)||(re.join_requests.push(U.pubkey),H.set(ne,{...re}))}});this.state={groups:[],flashMessage:null},this.groupsMap=new Map}async componentDidMount(){const U=async()=>{try{const K=await this.props.client.ndkInstance.fetchEvents({kinds:[...metadataKinds].map(G=>G)});Array.from(K).sort((G,Z)=>G.created_at-Z.created_at).forEach(G=>this.processEvent(G,this.groupsMap));const W=Array.from(this.groupsMap.values()).sort((G,Z)=>Z.created_at-G.created_at);this.setState({groups:W})}catch(K){console.error("Error fetching metadata events:",K)}};(async()=>{try{await U();const K=this.props.client.ndkInstance.subscribe({kinds:[...metadataKinds,9,11,GroupEventKind.CreateGroup,GroupEventKind.CreateInvite,GroupEventKind.PutUser,GroupEventKind.RemoveUser,GroupEventKind.JoinRequest].map(W=>W)},{closeOnEose:!1});return K.on("event",async W=>{console.log("received event",W.kind),this.processEvent(W,this.groupsMap);const G=Array.from(this.groupsMap.values()).sort((Z,Y)=>Y.created_at-Z.created_at);this.setState({groups:G}),W.kind<3e4&&(console.log("fetching metadata events"),await new Promise(Z=>setTimeout(Z,1e3)),await U())}),()=>{K.stop()}}catch(K){console.error("Error fetching groups:",K)}})()}render(){const{flashMessage:U}=this.state;return u$1(k,{children:[u$1(FlashMessage,{message:(U==null?void 0:U.message)||null,type:U==null?void 0:U.type,onDismiss:this.dismissMessage}),u$1("div",{class:"container mx-auto px-4 py-8",children:[u$1("h1",{class:"text-2xl font-bold text-[var(--color-text-primary)] mb-8",children:"Nostr Groups"}),u$1("div",{class:"flex flex-col lg:flex-row gap-4",children:[u$1("div",{class:"lg:w-[240px] flex-shrink-0",children:u$1(CreateGroupForm,{updateGroupsMap:this.updateGroupsMap,client:this.props.client,showMessage:this.showMessage})}),u$1("div",{class:"flex-1",children:u$1(GroupList,{groups:this.state.groups,client:this.props.client,showMessage:this.showMessage})})]})]})]})}}const RELAY_SECRET_KEY="6b911fd37cdf5c81d4c0adb1ab7fa822ed253ab0ad9aa18d77257c88b29b718e",client=new NostrClient(RELAY_SECRET_KEY,{relayUrl:"ws://127.0.0.1:8080"});client.connect().then(()=>{D(u$1(App,{client}),document.getElementById("app"))}).catch(console.error);
